\documentclass[twoside]{article} %用draft选项找到badbox的位置
\input{articlemodelparta.tex}
%%----------------------------------------------------------------------
%%                  参考文献库添加
%%----------------------------------------------------------------------
\addbibresource[location=local]{./exampleandimage/example.bib}
%论文1的参考文献的bib文件

%%----------------------------------------------------------------------
%%                  正文
\begin{document}
%%----------------------------------------------------------------------

%----------------------------------------------------------------------
%                  第一篇论文-填写基本信息
%----------------------------------------------------------------------
\qikanming{\LaTeX 爱好者}                       %期刊名,journal name
\nianfen{2016}                                  %年份,year
\juanshu{1}                                    %卷数,volume
\qishu{1}                                       %期数,number
\zongqishu{99}                                  %总期数,

\wenzhangdoi{10.11729/tex-lover}                   %doi号
\wenzhangbianhao{1672-9897（2016）01-0000-00}   %文章编号
\zhongtu{（V211.751）}                          %中图分类号
\wenxianbiaozhi{A}                              %文献标志码

\biaoti{\LaTeX 文档中文参考文献的biblatex解决方案}                     %标题,title
\fubiaoti{}                               %副标题,subtitle

\authorinput{胡振震} %作者间用英文分号隔开
\schoolinput{~LEETC~~CHINA~~100000~}                        %单位间用英文分号隔开
\includinput{1}              %各作者所属单位用英文分号隔开，
                                     %一位作者的多个所属单位用英文逗号隔开

                                                %摘要,abstract
\zhaiyao{针对中文\LaTeX{} 环境的参考文献生成问题，以入门教程为出发点，介绍了文档源代码、bib数据库、编译方法、文献表生成、格式修改、多语言、筛选和排序等大量细节问题，为国内用户提供了一套基于biblatex宏包的完整参考文献解决方案。
介绍了biblatex-gb7714-2015样式包和一个样式定制示例的设计思路和实现过程，揭示了基于biblatex标准样式定制样式的一般原理和开发方法，为biblatex参考文献样式定制提供了完整示范。}
%old-bak-20190127针对\LaTeX 文档的参考文献相关问题，分析了参考文献生成的一般需求，给出基于biblatex宏包全套解决方案。从文献数据源文件准备，tex源文档的组成，tex/bib文件的编译，分章参考文献和书后文献表，文献表标题和内容格式，参考文献著录和标注样式，多语言文献，脚注题注小页环境中的引用，脚注旁注中的文献表，文献表分类筛选打印，beamer 类中的参考文献等方面详实地介绍了biblatex参考文献生成方法，并提供所有示例代码，为用户提供参考。介绍了biblatex-gb7714-2015样式包的设计思路和实现方法，给出了一个参考文献样式定制项目示例，介绍了bbx和cbx文件开发的方法、步骤和过程，揭示了基于biblatex标准样式定制参考文献的一般原理，为定制参考文献样式提供完整示范。
%old-bak-20171031:针对\LaTeX 文档的中文参考文献问题，对其需求展开分析，提出利用biblatex宏包的解决思路，并针对性地给出了各项需求的解决方案(包括示例代码)，为\LaTeX 文档参考文献生成提供便利。

                                                %关键词,keywords
                                                %多个关键词用\kongge隔开
\guanjianci{\LaTeX{} \kongge 参考文献 \kongge biblatex}
                                                %use \kongge as separation

                                          %收稿等时间,第一/通信作者简介,
%% history:

\def\versionnumber{v1.0g}    %版本和修改时间信息
\def\versiondate{2018-08-12}
\diyizuozhe{The files have version number \versionnumber, last revised \today.\\ 第一作者简介：}
                                          %introduction of corresponding author
\zuozhejianjie{HU ZHENZHEN，A \LaTeX ~LOVER，Email: hzzmail@163.com。}


%----------------------------------------------------------------------
%                  第一篇论文-正文内容
\input{articlemodelpartb.tex}
%----------------------------------------------------------------------
\section{引言}

参考文献是科技文档写作中的重要内容，在写作中常碰到这样的问题，比如：怎么生成满足格式要求的参考文献表？正文中的文献引用如何能够产生满足格式要求的标注标签？怎么生成分章文献表和统一的全书文献表？等等。这些问题尽管不会成为困扰，但可能牵扯文档作者不少精力。为使\LaTeX{} 文档作者能更便捷地生成参考文献，有必要对相关问题进行总结梳理，并给出简单解决方案，以便随时参考和应用。 %移植和

对于一般需求而言，利用传统的\LaTeX{} 参考文献生成方法\cite{Oetiker--,刘海洋2013--,胡伟2011--}配合相关的bst 样式文件基本能够满足要求。但如果要实现一些特殊格式或要求，就需要应用一些辅助宏包，
比如 chapterbib(用于分章文献表)\cite{Daly2010--}，
multibib(用于单文档内生成多文献表)\cite{Hansen2008--}，
natbib(用于标注并提供著录样式)\cite{Arseneau2010--}，
mcitesplus(用于标注)\cite{Shell2013--}，
inlinebib(用于文献表置于脚注中)\cite{Seindal1994--}等。这些工具从多个方面提供了需求功能，但多个宏包同时使用可能不兼容等局限。另外，由于使用bibtex/bibtex8程序本身的原因，非utf-8编码的bib文件无法使用中文的引用关键字，中文文献排序往往也需要附加很多特殊处理，甚至当参考文献量足够大时可能出现内存不足的问题。

而biblatex宏包\cite{Lehman2015}旨在提供了一套完整的方案，既解决传统方法的一些局限，也覆盖大量辅助宏包的功能，更提供如动态数据修改等大量新功能。biblatex的强大和完善使它成为\LaTeX{} 参考文献生成的一个绝佳选择。由于使用习惯及存量bst广泛应用，传统方法无法完全取代，但由于biblatex的大量优点，基于biblatex的方法呈逐渐流行态势，目前CTAN 上面已经有包括APA、MLA、science、ieee、nature、iso690、gb7714-2015 等数十种第三方样式可以选用，结合biblatex的强大定制功能，利用biblatex一个宏包完全可以简单而直接满足所有可能需求。

然而正是由于biblatex的完整性，biblatex宏包相当的庞大，其说明文档(\href{https://github.com/hushidong/biblatex-zh-cn}{中译版})长达300页。对于初学者或者无深度需求的使用者来说，biblatex手册就像一个技术说明书，详实的介绍宏包功能和接口，但却没有提供一个像lshort这样的简单入门教程。类似biblatex-gb7714-2015这样的样式包\cite{胡振震2016}，虽然也介绍了一些biblatex的使用方法但并不详细。%其重点主要还在样式包的设计、实现和使用上。

总的来说，对于biblatex参考文献生成目前还没有较为系统的入门手册
\footnote{准确的说是中文入门手册，因为：\par
biblatex 3.12版以后，宏包作者提供了一个简单的
\href{https://github.com/plk/biblatex/blob/dev/doc/latex/biblatex/biblatex-quickstart.tex}{入门教程}\href{run:exampleandimage/biblatex-quickstart.pdf}{（见pdf文档）}\par
另外Paul Stanley也提供了一个
\href{https://github.com/PaulStanley/biblatex-tutorial}{入门教程}
\href{https://github.com/hushidong/biblatex-tutorial-cn}{（见pdf文档）}，该教程对基本概念介绍相当清晰，感兴趣的读者可以细看。}。
本文正是出于这样的现状考虑，希望从初级用户的角度，面向应用，以示范的形式，给出一个简易但全面的使用说明书，为用户入门提供帮助。

%事实上随着biblatex宏包及其biber后端程序的完善，利用它可以满足对于参考文献的绝大多数功能需求。如果利用一个宏包就能完成以前多个宏包才能实现的功能，那么问题实际上就简化了，这正是用户所期待的。利用biblatex宏包“简单化、便利化”地满足\LaTeX 文档写作中的各种中文参考文献需求正是本文写作的初衷所在。

需要提示的是: 本文所有的示例和测试都基于texlive发行版，2014/2015/2016/2017/2018均可，文档均采用UTF-8编码，编译使用xelatex+biber，texlive的安装和使用可以参考texlive安装手册\cite{Berry2016--}
以及\href{http://bbs.ctex.org/forum.php}{ctex论坛ctex论坛}
或\href{http://www.latexstudio.net/}{latex sudio}上分享的各种方法。


\section{为什么使用biblatex}


\subsection{latex参考文献基本原理}

\LaTeX{} 中参考文献生成主要借助于\verb|thebibliography|环境。这个环境可以手工在tex 源文档中输入，也可以利用外部程序 bibtex 程序生成。

首先我们看一下手工写 \verb|thebibliography| 环境的方法。在环境中每一条文献用\verb|\bibitem| 命令组织，第一遍编译时，由于\verb|\bibitem| 命令的宏替换，文献latex编译程序将在 aux 文件中写入对应标签生成命令\verb|\bibcite| 。第二遍编译时，latex会读入 aux 文件并根据\verb|\bibcite| 命令生成对应引用关键词的标签，编译过程中当遇到\verb|\cite|命令，则调用对应引用关键词的标签，以生成引用标签。

基于bibtex的参考文献生成方法，本质上是类似的，只是利用了外部程序bibtex
生成\verb|thebibliography|环境。在tex源文档中，利用命令\verb|\bibliographystyle|命令指定bibtex程序需要使用的bst文件，利用命令\verb|\bibliography|命令指定bibtex需要处理的bib文件，在第一步latex编译中，编译程序将这两个文件信息写入到aux文件中。接着运行bibtex程序，该程序会读取 aux 文件中的两个指定文件，并处理生成一个bbl 文件，该文件中包含\verb|\thebibliography| 环境。第二遍latex编译时，latex读取bbl 文件，并利用\verb|\bibitem|命令将标签生成命令\verb|\bibcite|写入到aux文件中。第三遍latex编译时，latex再次读取aux文件并依据\verb|\cite|命令将标签输出。

其中参考文献的著录格式由\verb|\thebibliography|环境的\verb|\bibitem|命令后跟着的文献内容决定，因此可以采用手动输入方式来实现需要的格式，或者由满足要求的bst样式文件来生成。而引用文献的标注标签格式则由\verb|\bibcite|命令的定义及其参数决定。该命令的定义在latex中有原始的定义，一些宏包比如natbib，jurabib等会对其重新定义以生成满足某种要求的格式。但如果该命令的输入参数中如果没有足够的信息，那么再多的格式要求也会巧妇难为无米之炊。因此要实现一些特殊的格式就需要为其提供足够的文献信息。而这一信息又来源于\verb|\bibitem|命令的写入aux操作，
\verb|\bibitem| 命令通常会把其后跟着的[]中的可选参数内容当做\verb|\bibcite|命令的参数，因此标签生成的重点之一是在\verb|\bibitem| 后面的[]内写入足够文献信息，同样这也可以手工写入，也可以利用样式文件bst完成。对于natbib宏包来说，通常需要在\verb|\bibitem| 命令后的[]中写入三个信息：作者的缩写信息、由()包围的年份信息、以及作者的详细信息，其中()作为定界符来读取这三个信息。因此利用natbib宏包生成标注标签时，通常要对\verb|\bibitem| 后面[]的内容做文章，无论是通过手工写的方法还是通过bst样式文件生成。jurabib宏包也有类似情况，只是其解析方式更为复杂，需要写入更多的信息，以便在标签生成时生成更多的内容，比如文献的题名等。

总结起来，\LaTeX{} 参考文献生成的基本方法是利用\verb|\thebibliography|环境写参考文献的著录格式，并利用\verb|\bibitem| 命令将其可选参数信息输出作为引用标签处理的基础来生成正文中的参考文献引用标签。其中如果要采用非手工方式生成该环境，那么就要利用外部程序bibtex和参考文献样式bst文件以及参考文献的数据源bib文件。其中bib文件是以BibTeX格式统一规范的文本文件，该格式简单且通用，是默认的参考文献数据源标准，bib文件作为文本文件也非常容易生成，
关于该格式在第\ref{sec:bib:file}节还有详细介绍。而bst则是与bibtex程序配合使用的样式文件，以一种能被bibtex程序识别的语法实现，该语法与tex基本语法迥异，因此一般用户学习起来不太容易，因此要设计某种样式的bst文件也相对困难。而bibtex程序则是用于处理bib文件生成bbl文件的程序，通常由tex发行版附带。


\subsection{biblatex参考文献生成的基本原理}

基于biblatex的参考文献生成方法，从根子上就不再利用\verb|thebibliography|环境，但操作方式有点类似于基于bibtex的方法，相似点在于同样利用外部程序处理参考文献数据源，也同样需要利用辅助文件。
biblatex 的设计出发点就是要达成两个主要目的，
一是要避免传统参考文献生成方法过度的读写辅助文件，
二是要利用tex命令实现对参考文献信息和格式的完全控制。

基于bibtex的方法总共有四遍编译，第一遍latex将信息写入aux、文件，第二遍bibtex读取aux文件将信息写入bbl文件，第三遍latex读取bbl文件将信息写入aux文件，第四遍编译latex再次读取aux文件。
这在biblatex设计者看来是没有必要的，既然要实现对参考文献信息的完全控制，那么将参考文献信息放在内存中是最好的方式，也没有必要过多的读写文件。如果参考文献信息能够以一种合适的方式读入内存，并能在tex宏中应用，那么就可以解决问题。
因此biblatex设计并实现了这种新的方式，在第一遍latex编译时，将需要的信息写入到bcf文件中，然后利用外部程序biber读取该文件，并处理bib文件得到一个bbl文件，其内包含biblatex宏包设计的能被tex宏读取并利用的固定格式的信息，这一信息包含了所有的参考文献信息，可以很方便地用于参考文献著录表和参考文献引用标注的输出。第二遍编译时，latex读取bbl文件，biblatex识别并利用其中的信息输出引用标签和文献表。这种新的方式仅用一次latex编译过程中的aux文件写入，一次外部程序编译，和第二次的latex编译就实现了参考文献生成，相比传统的基于bibtex的方法少了一次latex 编译，同时也实现了将全部参考文献信息保存到内存中以便进一步利用的目的。

如前所述，参考文献生成包含两个部分，一个是著录文献表，一个是正文中的引用标注。对于latex传统方法，前者以手工写或者bibtex结合bst文件生成，后者则由标注宏包如natbib读取手动写或者bibtex结合bst文件给出的标签信息生成。而biblatex由于已经把全部参考文献信息读取到内存中，因此可以由tex宏完全控制。biblatex提供了所有这些参考文献信息的控制接口，著录表格式由一系列宏进行控制，标注格式也由一系列宏进行控制，前者通常放在bbx文件中，后者则放在cbx文件中，一些通用的宏则放在biblatex.sty 和 biblatex.def 文件中。

简单来说，对于著录文献表，biblatex通过driver控制条目中的域(项)和顺序，通过fieldformat 控制各个项的格式，其中利用一套异步标点控制机制和一套本地化字符串系统辅助。对于标注标签，则通过各类cite命令及其内部接口进行控制，同样使用标点控制和本地化字符串机制。此外，biblatex充分利用tex的局部化机制，提供各种局部化设置方式，比如利用文境refcontext区分不同的数据和排序机制，利用各cite命令和bibliography和biblist环境区分各种分隔符的输出格式，利用各类条目类型的驱动环境设置域的不同输出格式。可以说，biblatex 因为解决了参考文献全部信息的控制问题，为利用tex宏控制参考文献和引用标签提供了无限可能，只有想不到，没有做不到。


\subsection{biblatex参考文献生成的优缺点}

如前所述，biblatex通过写bcf文件(格式实际为xml)为biber提供处理信息，biber根据这些信息处理bib文件中相关条目，完成筛选、排序等操作，并将处理结果写入bbl文件中，接着biblatex再次读取bbl中的完整数据以进一步处理输出。biblatex基于这样一种新的机制实现了更简化的文献编译，实现了参考文献信息的完全tex宏控制，还实现了大量功能以覆盖其它辅助宏包。这有赖于biblatex宏包的全面设计以及后端程序biber的强大支持。总结起来biblatex加上其后端程序biber具有如下主要特点:

\begin{itemize}
  \item biblatex 包含许多用于人文社科类的样式，用于生成人文社科类的文献表和标注标签。而基于bibtex的方法引用标注主要包括作者年制和数字顺序编码制，缺乏人文社科类文献常用的作者标题制或者脚注样式，需要利用类似jurabib这样的宏包以及专门的bst文件。

  \item biblatex 提供便捷的参考文献格式控制机制，包括友好的宏包选项控制和简单的tex宏格式修改，非常易学。而传统的方法则要么手工改写文献表内容，要么修改bst样式文件，而学习bst文件采用的与tex语法迥异的语法并不是一件轻松的事情。

  \item biblatex 提供完全的unicode支持，提供自动的编码转换，提供自动的姓名和姓名列表非模糊处理，支持可定制的数据继承规则，提供非常灵活的数据映射(动态处理)。

  \item biblatex 提供强大排序功能，支持排序定制，支持unicode字符的排序，更支持本地语言的排序调整，比如中文的按笔画数排序等，可以实现丰富的效果。而基于bibtex的方法能支持utf-8编码的bib 文件，但不支持非ASCII字符的排序。

  \item biblatex 使用的后端biber，具有处理大文献量的能力，不用担心bibtex可能存在的内存问题。biber还支持远程的参考文献数据库。

  \item biblatex 兼容 BibTeX 格式外，还支持更多更广泛的条目类型和域。也支持除BibTeX 外的更多格式的文献数据库，也支持其他格式的文献数据的输出和转换。
      
  \item biblatex 提供参考文献分节、分类筛选等功能。在文档中打印多个文献表非常方便，而不再需要使用其它宏包，比如chapterbib等。
      
  \item biblatex 是包含biber程序的一个大型宏包。biblatex 提供了覆盖natbib、jurabib、chapterbib、multibib、mcite、inlinecite 等宏包的完整功能体系。

\end{itemize}

当然也不存在十全十美的事物，biblatex 也存在一些局限，包括：

\begin{itemize}
 \item 虽然biblatex已经取得了广泛应用，但一些期刊和出版商长期维护使用专门设计的bibtex样式bst文件，因此可能不接收使用biblatex的文档。

 \item biblatex 生成处理完的参考文献信息，不是thebibliography环境，而是biblatex预设的格式，因此其代码并不能像thebibliography环境中的内容一般可以直接拷贝进文档使用。

 \item biblatex 还在不断更新和升级，尽管已经基本稳定，但可能存在后向兼容问题。比如随着biblatex的升级，一些基于老版本biblatex的第三方样式可能会无法使用，而基于新版本biblatex的样式可能无法应用于老版本biblatex的环境，这需样式作者持续维护。

 \item biblatex 因为功能强大且全面，说明文档很大很全，有点类似技术说明书，但作为初级用户的入门却并不合适，而对于宏包作者这一类的用户，biblatex 宏包的代码实现和解析说明相对较少，也不利于这类人员深入学习和参与维护。
\end{itemize}

从前述的优缺点可以看到，虽然biblatex宏包还并不完美，但基于biblatex生成参考文献的确可以获得很多优势，因此对于一般用户来说，使用biblatex不失为一种好的选择。

\section{参考文献常见需求与解决方案}

\subsection{参考文献生成的常见需求}
\LaTeX 中文写作对于参考文献一般会有哪些需求？最直接地，我们会想到文章投稿时的参考文献格式要求，比如: 参考文献标题的字体字号前后间距段落格式; 参考文献内容的字体字号; 各条目的间距; 条目的内容格式如文献标识符、标点等; 双语参考文献; 上标、带年份、带页码等标注要求等等。在书籍之类的文档排版中有时也会遇到比如: 分章参考文献表; 文后参考文献总表; 参考文献的目录链接; 脚注中引用参考文献; 脚注中直接显示参考文献; 在合适位置按需插入文献表等等。还有一些比如文献的排序;PDF文档中标注和文献条目的正反超链接等。总结起来可能包括如下常见需求:
%，这里根据本文作者的理解，按照重要程度列出:
%(注意这里所列的问题可能并不全面，仅列出了本文作者所知道的一些问题，更多未遇问题只能以后完善，也希望大家帮助一起完善)
\begin{enumerate}
  \item 参考文献表基本生成方法-数据源文件准备(手动、利用winedt、利用texstudio 、Jabref、随\LaTeX 文档生成)
  \item 参考文献表基本生成方法-文档的组成(基本结构、宏包加载、样式包加载、文献引用、文献表打印)
  \item 参考文献表基本生成方法-文档的编译(手动、利用winedt、利用texstudio、脚本)
  \item 书后参考文献和分章参考文献
  \item 分类筛选、缩略信息和索引打印
  \item 参考文献标题格式(重定义heading，利用titlesec)
  \item 参考文献内容格式(重定义内容命令)
  \item 参考文献著录样式(顺序编码制、作者年制、域、位置、标点、排序)
  \item 参考文献标注样式(页码、年份、对应natbib/mcite等的标注命令)
  \item 多语言文献
  \item 脚注题注小页环境中的引用
  \item 脚注旁注中的文献表
  \item beamer类中的参考文献
\end{enumerate}


下面针对前述提出的需求，一一进行解答。解决方案主要应用于一般文档类(book，report，article)，beamer类的问题放到最后一小节中专门介绍。

\subsection{参考文献数据文件准备}\label{sec:bib:file}
\LaTeX 文档中生成参考文献除了利用 thebibliography 环境手工输入参考文献条目信息这一简单方式外，bibliography+bibliographystyle+bibtex 方式或者 biblatex方式都需要准备一个参考文献数据源文件即bib文件。这一文件内保存有各条参考文献的信息，每一条参考文献记录都是一个bibtex item(bibtex项)，一条参考文献记录基本格式如下:
\begin{codetex}{参考文献信息基本格式即bibtex格式}{fmt:bibtex}
@ARTICLE{entrykey,
  author =       {Author A and Author B and Author C and others},
  title =        {A title of a paper},
  journal =      {A title of a jounal},
  year =         {2005},
  volume =       {31},
  number =       {6},
  pages =        {75-81},
}
\end{codetex}

其中\verb|@|符号后面紧跟着条目的类型比如article(期刊文章)，book(专著)等，编组符号\{后紧跟的是该条参考文献信息的bibtex key即引用关键字，在cite标注（引用）命令中用该关键字来表示对此文献的引用。逗号后面跟着的是构成参考文献记录的各个域的信息，比如作者域，题名域等等，参考文献信息放在各个域名等号后面的编组内，一些域的录入比如author域的英文名录入是有特殊格式要求的，具体可以参考biblatex宏包手册和biblatex-gb7714-2015样式包手册\cite{胡振震2016}中关于域信息录入的说明。

尽管biblatex在传统bibtex格式基础上增加了很多新的条目类型和域，但它完全兼容传统的BibTeX格式文件，出于兼容性考虑，我们在准备bib文件时，可以完全按照\href{https://en.wikipedia.org/wiki/BibTeX}{传统的BibTeX格式规范}来进行。BibTeX格式中有两个基本概念：一是条目类型(Entry type)，即一个参考文献条目的类型，是book(专著)，是inbook(专著析出的文献)，或其它类型。二是域(Field)，即纪录参考文献信息并组成参考文献条目的信息项，比如author(作者)，title(题名)，或者其它。BibTeX格式中条目类型和域
如表\ref{tab:bibtex:fmt}、\ref{tab:bibtex:field}所示，这些条目和域是bibtex附带的默认样式bst文件能识别的条目类型和域，而第三方的bst文件有可能支持其它条目类型和域，比如一些bst样式为了兼容biblatex的条目和域而做的处理。biblatex 虽然支持更多的条目类型和域，详见biblatex手册，但通常情况下BibTeX默认的条目和域已够用。

\begin{table}[!htb]
\centering
\caption{BibTeX格式的条目类型和域}\label{tab:bibtex:fmt}
\footnotesize
\begin{tabular}{p{2cm}p{3cm}p{3cm}p{6cm}}
   \hline
条目类型 & 类型说明 & 条目必选域 & 条目可选域 \\ \hline
article & An article from a journal or magazine.
author, title, journal,
year, volume &
number, pages, month, note, key\\

book & A book with an explicit
publisher. &
author/editor, title,
publisher, year &
volume/number, series, address, edition, month,
note, key, url \\

booklet & A work that is printed
and bound, but without a named publisher or sponsoring institution. &
title &
author, howpublished, address, month, year, note, key \\

inproceedings / conference & An article in a conference proceedings.
& author, title, booktitle, year & volume/number, series, pages, address, month, organization, publisher, note, key\\

inbook &
A part of a book, usually untitled. May be a chapter (or section, etc.) and/or a range of pages. &
author/editor, title, chapter/pages, publisher, year &
volume/number, series, type, address, edition, month, note, key \\

incollection &
A part of a book having its own title. &
author, title, booktitle, publisher, year &
editor, volume/number, series, type, chapter, pages, address, edition, month, note, key \\

proceedings &
The proceedings of a conference. &
title, year &
editor, volume/number, series, address, month, publisher, organization, note, key \\

manual &
Technical documentation. &
title &
author, organization, address, edition, month, year, note, key \\

mastersthesis &
A Master's thesis. &
author, title, school, year &
type, address, month, note, key \\

phdthesis &
A Ph.D. thesis. &
author, title, school, year &
type, address, month, note, key \\

techreport &
A report published by a school or other institution, usually numbered within a series. &
author, title, institution, year &
type, number, address, month, note, key \\

misc &
For use when nothing else fits. &
none &
author, title, howpublished, month, year, note, key \\

unpublished &
A document having an author and title, but not formally published. &
author, title, note &
Optional fields: month, year, key\\ \hline
    \end{tabular}
\end{table}%

\begin{table}[!htb]
\centering
\caption{BibTeX格式中的域说明}\label{tab:bibtex:field}
\footnotesize
\begin{tabular}{p{3cm}p{12cm}}
   \hline
域名称 & 域说明 \\ \hline
address &
Publisher's address (usually just the city, but can be the full address for lesser-known publishers) \\

annote &
An annotation for annotated bibliography styles (not typical)\\

author &
The name(s) of the author(s) (in the case of more than one author, separated by and) \\

booktitle &
The title of the book, if only part of it is being cited \\

chapter &
The chapter number \\

crossref &
The key of the cross-referenced entry \\

edition &
The edition of a book, long form (such as "First" or "Second") \\

editor &
The name(s) of the editor(s) \\

howpublished &
How it was published, if the publishing method is nonstandard \\

institution &
The institution that was involved in the publishing, but not necessarily the publisher \\

journal &
The journal or magazine the work was published in \\

key &
A hidden field used for specifying or overriding the alphabetical order of entries (when the "author" and "editor" fields are missing). Note that this is very different from the key (mentioned just after this list) that is used to cite or cross-reference the entry.\\

month &
The month of publication (or, if unpublished, the month of creation) \\

note &
Miscellaneous extra information \\

number &
The "(issue) number" of a journal, magazine, or tech-report, if applicable. (Most publications have a "volume", but no "number" field.) \\

organization &
The conference sponsor \\

pages &
Page numbers, separated either by commas or double-hyphens. \\

publisher &
The publisher's name \\

school &
The school where the thesis was written \\

series &
The series of books the book was published in (e.g. "The Hardy Boys" or "Lecture Notes in Computer Science") \\

title &
The title of the work \\

type &
The field overriding the default type of publication (e.g. "Research Note" for techreport, "{PhD} dissertation" for phdthesis, "Section" for inbook/incollection) \\

volume &
The volume of a journal or multi-volume book \\

year &
The year of publication (or, if unpublished, the year of creation) \\ \hline
    \end{tabular}
\end{table}%


参考文献源文件本质上只是一个文本文件，只是其内容需要遵守BibTeX格式，所以可以有多种生成方式:

\subsubsection{手动文本文件生成}

利用文本编辑器比如notepad++等，生成或者编辑bib源文件是一种很简单的方式，直接新建bib文件，用notepad++打开，填入需要的参考文献信息，保存就可以得到一个bib源文件，如图\ref{bib:texteditor}所示。notepad++，notepad2等文本编辑器均可在其官网下载到。

\begin{figure}[!htb]
  \centering
  \includegraphics[width=\figwd\textwidth]{bib-text-editor}
  \caption{文本编辑器生成bib文件}\label{bib:texteditor}
\end{figure}

\subsubsection{利用winedt生成}
在windows下常用winedt编辑latex文档，所以用其生成bib文件也是一种不错的方式，特别是它提供了各种条目类型的信息模板(图\ref{bib:winedt})。winedt可以在其官网(\url{http://www.winedt.com/})下载到，非注册版本不影响功能使用。

\begin{figure}[!htb]
  \centering
  \includegraphics[width=\figwd\textwidth]{bib-winedt}
  \caption{winedt生成bib文件}\label{bib:winedt}
\end{figure}

\subsubsection{利用texstudio生成}
texstudio软件可以在多平台使用，linux下因为没有winedt所以比较常用，用其生成bib文件也很方便，它也提供各种条目类型的信息模板(图\ref{bib:texstudio})。texstudio软件下载地址\url{https://sourceforge.net/projects/texstudio/?source=navbar}。

\begin{figure}[!htb]
  \centering
  \includegraphics[width=\figwd\textwidth]{bib-texstudio}
  \caption{texstudio生成bib文件}\label{bib:texstudio}
\end{figure}

\subsubsection{利用Jabref软件生成}
利用Jabref软件是最重要的一种方式，因为它也是一个较强的参考文献管理工具。新建一个数据库就是新建一个bib文件(图\ref{bib:jabref-a})，新建一个记录就是加入一条参考文献信息(图\ref{bib:jabref-b})，参考文献的信息的录入也是可视化输入栏形式(图\ref{bib:jabref-c})。jabref软件可在官网(\url{http://www.jabref.org/})下载。

\begin{figure}[!htb]
  \centering
  \includegraphics[width=\figwd\textwidth]{bib-jabref-a}
  \caption{Jabref软件生成bib文件}\label{bib:jabref-a}
\end{figure}

\begin{figure}[!htb]
  \centering
  \includegraphics[width=\figwd\textwidth]{bib-jabref-b}
  \caption{Jabref软件增加参考文献条目}\label{bib:jabref-b}
\end{figure}

\begin{figure}[!htb]
  \centering
  \includegraphics[width=\figwd\textwidth]{bib-jabref-c}
  \caption{Jabref软件录入参考文献信息}\label{bib:jabref-c}
\end{figure}

\subsubsection{随\LaTeX 文档生成}
\LaTeX 提供了filecontents环境允许在\LaTeX 文档编译的时候自动将信息写入文件中，自然这也可以用来生成bib文件。比如在导言区加入如下代码，可以生成一个example.bib源文件。
\begin{codetex}{利用filecontents环境随latex文档生成bib}{bib:genwithlatex}
\usepackage{filecontents}
\begin{filecontents}{example.bib}
@Article{傅刚2000--,
  Title                    = {大风沙过后的思考},
  Author                   = {傅刚 and 赵承 and 李佳路},
  Note                     = {news},
  Number                   = {14},
  Url                      = {http://www.bjyouth.com.cn/Bqb/20000412/GB/4216%5ED0412B1401.htm},
  Urldate                  = {2005-07-12},
  Date                     = {2000-04-12},
  Journaltitle             = {北京青年报}
}
@Book{顾炎武1982--,
  Title                    = {昌平山水记},
  Author                   = {顾炎武},
  Publisher                = {北京古籍出版社},
  Year                     = {1982},
  Location                 = {北京},
  Titleaddon               = {东京考古录}
}
\end{filecontents}
\end{codetex}

\subsubsection{获取标准bib文件}
上述给出的方法都是手动编写bib文件的方法，事实上这些手工编写方法还是比较繁琐的。那么是否有其它方法可以直接获取bib文件或其内容避免自己手工编写呢？答案是有的，latexstudio上共分享了这方面的几篇文章\cite{北京交通大学研究生公众号2016--}\cite{olref2016--}\cite{文献助手2016--}。总结起来主要有几个渠道:
\begin{enumerate}
  \item Google 学术: 检索文献 >> Cite（引用） >> BibTeX >> 复制粘贴到 mybibtex.bib 文件
  \item CNKI，（以 firefox 为例）: (确保安装 Zotero 的 firefox 扩展 >>) CNKI 检索文献 >> 点击一下 url 输入框末尾的文件夹图标 >> 选中要导出的文献 >> 导出为 BibTeX 引用格式 >> 复制粘贴导出的 BibTeX 文献到 mybibtex.bib 文件。
  \item 必应学术（必应学术 – 学无止境，术有乾坤）、百度学术（百度学术 – 保持学习的态度）类似于google学术。
  \item 从一些学术期刊官网直接获取bib文件，比如IEEE，Springer，Elsevier等
  \item 使用文献助手工具，地址:\url{http://cite.latexstudio.net}
\end{enumerate}

熟练使用这些方法，应该可以进一步提高工作效率。说明一下: latexstudio网站原创、收集、整理了很多latex方面的知识、信息和资源，内容不一，对不同程度的latex爱好者都具有一定的参考价值，各位朋友可以了解学习。


\subsubsection{从pdf或文本文件转换bib文件}
批量生成参考文献数据以构成bib文件，还有一种方式是从参考文献表文本转换。比如从一个包含GB/T 7714-2015格式的参考文献表的pdf文件中，讲文献表拷贝到一个文本文件中，比如 textfilename 文件，其中每一条文献信息构成一个行。然后利用biblatex-gb7714-2015样式宏包附带的perl脚本gb7714texttobib.pl将其转换为bib文件比如bibfilename。该脚本的使用命令为:

\begin{codetex}{利用gb7714texttobib.pl将参考文献文本转换为bib文件}{code:trans2bib}
perl gb7714texttobib.pl in=textfilename out=bibfilename
\end{codetex}

其中in=后面是输入的参考文献文本文件，out=后面是输出的bib文件。

\subsubsection{利用biber转换输出新的bib文件}
对于使用biblatex的用户来说，当需要从一个大的bib数据库，输出其中的部分文献数据到一个新的bib文件时，可以利用biber命令选项\verb|--output-format=bibtex|。事实上，因为平时的积累我们通常会维护一个参考文献数据库，但写文章的时候只是引用其中的部分文献，当需要提交文章时，我们提交仅包含引用文献数据的bib文件即可，这可以通过biber轻松完成。例给出了一个biber命令示范，其中jobname是当前引用文献的tex文档名，运行该命令后会得到一个\verb|jobname_biber.bib|的文件包含有该文档所引用文献的数据。

\begin{codetex}{利用biber转换出新的bib文件}{code:biber:trans}
biber --output-format=bibtex jobname.bcf
\end{codetex}



\subsection{\LaTeX 文档的组成}
\LaTeX 文档源文件是由具有某种结构和模式的代码所构成，参考文献自然也遵守这样的结构和模式。

\subsubsection{文档源文件基本结构}
\LaTeX 文档源文件的代码基本结构由导言区和正文区构成，导言区位于documentclass命令与begin\{document\}命令之间，而正文区位于begin\{document\}命令和end\{document\}命令之间。宏包在导言区加载，具体文档内容在正文区编辑。
\begin{codetex}{文档源文件的代码基本结构}{code:doc:structrue}
\documentclass{article}%文档类

%导言区:
%ctex中文设置
\usepackage{ctex}
%定义版面
\usepackage[paperwidth=210mm,paperheight=290mm,left=20mm,right=20mm,top=25mm, bottom=15mm]{geometry}
%书签功能，选项去掉链接红色方框
\usepackage[colorlinks=true,pdfstartview=FitH,linkcolor=blue,anchorcolor=violet,citecolor=magenta]{hyperref}

\begin{document}%正文区开始
正文内容
\end{document}
\end{codetex}

\subsubsection{biblatex宏包、参考文献数据源和样式的加载}
利用 biblatex 宏包生成参考文献可以说非常简单，只要在上述\LaTeX 基本文档基础上载入biblatex宏包和bib数据源，选择需要的参考文献样式，然后在正文需要的地方引用bib文件中准备的参考文献，然后在文档合适位置比如文档末尾打印参考文献表即可，例\ref{code:doc:structrue}和图\ref{fig:eg:ref}给出了示例代码及其结果。

\begin{codetex}{biblatex参考文献生成最小工作示例}{code:doc:structrue}
\documentclass{article}%文档类
%导言区开始:
%加载ctex宏包，中文支持
\usepackage{ctex}
%加载geometry宏包，定义版面
\usepackage[left=20mm,right=20mm,top=25mm, bottom=15mm]{geometry}
%加载hyperref宏包，使用超链接
\usepackage[colorlinks=true,pdfstartview=FitH,linkcolor=blue,anchorcolor=violet,citecolor=magenta]{hyperref}
%加载biblatex宏包，使用参考文献
%其中后端backend使用biber
%标注(引用)样式citestyle，著录样式bibstyle都采用gb7714-2015样式
\usepackage[backend=biber,bibstyle=gb7714-2015,%nature,%
citestyle=gb7714-2015%,backref=true%
]{biblatex}
%biblatex宏包的参考文献数据源加载方式
\addbibresource[location=local]{example.bib}

%正文区开始:
\begin{document}
%正文内容，引用参考文献
详见文献\cite{Peebles2001-100-100}\parencite{Miroslav2004--}
参考文献\cite[见][49页]{蔡敏2006--}\parencite[见][49页]{Miroslav2004--}

%打印参考文献表
\printbibliography[heading=bibliography,title=参考文献]
\end{document}
\end{codetex}

\begin{refsection}
\begin{figure}[!htb]
\centering
\fbox{
\parbox{15cm}{%\raggedright
详见文献\cite{Peebles2001-100-100}\parencite{Miroslav2004--}
参考文献\cite[见][49页]{蔡敏2006--}\parencite[见][49页]{Miroslav2004--}
\printbibliography[heading=subbibliography,title=参考文献]
}
}
\caption{最小工作示例的结果}\label{fig:eg:ref}
\end{figure}
\end{refsection}

其中，biblatex宏包和参考文献数据源都在导言区加载(例\ref{code:pkg:load})，宏包加载命令为usepackage，数据源加载命令为addbibresource。

\begin{codetex}{biblatex宏包、数据源和样式的加载}{code:pkg:load}
%biblatex宏包加载
%其中后端backend使用biber
%引用样式citestyle，著录样式bibstyle都采用gb7714-2015样式
\usepackage[backend=biber,bibstyle=gb7714-2015,%nature,%
citestyle=gb7714-2015%,backref=true%
]{biblatex}

%参考文献数据源加载
\addbibresource[location=local]{example.bib}
\end{codetex}

其中，参考文献样式作为biblatex宏包的可选参数加载，即用bibstyle选项加载著录样式，用citestyle选项加载标注样式，当两者使用同名样式时，可以用一个选项style表示，例\ref{code:pkg:load}中bibstyle和citestyle都选择使用gb7714-2015样式。实际上，标注样式和著录样式分开加载有时是很有用的，有朋友可能想用gb7714-2015的参考文献著录样式，但引用标注又不想要用上标？最简单的方式是著录样式使用gb7714-2015样式，而标注样式使用其他样式比如numeric-comp。当然修改gb7714-2015的标注样式文件中cite等命令也可以实现。参考文献样式还有许多，可以使用biblatex宏包提供的标准样式(标准样式详见biblatex手册Standard Styles一节)，或者使用其它作者提供的定制样式，比如nature，science等，具体参见\label{sec:bib:style}节，用户可以根据需要选择使用。

为利用 biblatex 的高级功能，后端 backend 应尽量采用 biber 而不用 bibtex (如果backend为bibtex8，则biblatex宏包利用bibtex8和aux文件进行编译(\LaTeX 传统方法)，而backend为biber则是利用biber和bcf文件进行编译)。

另外，biblatex宏包还提供一系列宏包选项，用于控制文献著录表，标注的标签等内容，详细内容参考biblatex手册宏包选项一节。

值得注意的是: 参考文献数据库源文件即bib文件可以是本地的，也可以是网络上的(具体参考biblatex手册Bibliography Commands一节中关于addbibresource命令的说明)。本地的数据源可以指定绝对路径或者相对路径，注意其中目录层级之间的间隔符用/而不是\textbackslash ，windows下默认复制的间隔符是\textbackslash ，需要将其改为/。数据源还可以制定标签，以便不同的参考文献节中使用不同的文献源。数据源添加示例见例\ref{ref:addresource}。

\begin{codetex}{添加参考文献数据源的两种方式}{ref:addresource}
\addbibresource{bibfile1.bib} %本地数据源
\addbibresource{bibfile2.bib}
\addbibresource[location=local]{D:/zlatexreference/paperone.bib}
\addbibresource[location=remote]{http://www.citeulike.org/bibtex/group/9517} %网络数据源
\addbibresource[location=remote,label=lan]{ftp://192.168.1.57/~user/file.bib}

%指定文献源标签
\addbibresource[label=drofnats]{./bibfiles/drofnats.bib}
\addbibresource[label=frobwangler]{./bibfiles/frobwangler.bib}
\addbibresource[label=everyone]{./bibfiles/everyone.bib}

%在不同的文献节中使用不同的标签的文献源
\newrefsection[drofnats,everyone]
section contents
\endrefsection

\begin{refsection}[frobwangler,everyone]
section contents
\end{refsection}
\end{codetex}

\subsubsection{文献的标注（引用）}
文献的标注（引用）可以采用\LaTeX 提供的cite命令(注意biblatex对其进行了重定义)，也可以使用biblatex提供的其它命令比如parencite等，也可以采用参考文献样式包提供的定制命令比如gb7714-2015样式提供的pagescite，yearpagescite等。在文档中引用文献仅需要在合适的位置插入标注（引用）命令，命令的必选参数是所引用参考文献的bibtex键(引用关键字)。比如:

\begin{codetex}{参考文献的引用命令}{ref:cite:cmd}
详见文献\cite{Peebles2001-100-100}\parencite{Miroslav2004--}
参考文献\cite[见][49页]{蔡敏2006--}\parencite[见][49页]{Miroslav2004--}
详见文献\pagescite{Peebles2001-100-100}\pagescite[][201-301]{Peebles2001-100-100}
见赵耀东\yearpagescite[][205]{赵耀东1998--}和Simon\yearpagescite[][15]{Simon2001--}的文献。
\end{codetex}

当需要在参考文献表中打印不标注的文献时，可以使用nocite命令引入这些文献。其参数是具体条目的引用关键词(bibtex键)或者星号，星号表示将bib文件中所有的参考文献引入。使用命令如:

\begin{codetex}{不标注的文献的引用命令}{ref:nocite:cmd}
参考文献表中打印不标注的文献引入\nocite{Miroslav2004--,蔡敏2006--}。
参考文献表中打印不标注的文献引入，引入bib文件中中全部文献\nocite{*}。
\end{codetex}

另外，在biblatex中使用动态文献集也能产生类似nocite命令的效果，即打印文献表时也会自动输出定义在动态文献集中的文献。

\subsubsection{文献表的打印（输出）}

基于 biblatex 宏包的参考文献表打印（输出）与\LaTeX 传统方式不同，采用的命令是printbibliography。如果全文仅需一个参考文献，那么只要在合适的地方插入如下命令即可：

\begin{codetex}{参考文献表打印命令}{ref:bibprint:cmd}
\printbibliography[heading=bibliography,title=参考文献]
\end{codetex}

注意：printbibliography可以有很多可选参数，用于复杂的文献表控制，具体见biblatex宏包手册。

\subsubsection{参考文献正反超链接}

当加载hyperref宏包后，biblatex宏包除了提供正向超链接外还能提供功能强大的反向超链接。使用方式也很简单，就是使用backref选项。
例\ref{ref:hyperlink:back}给出了代码:
\begin{codetex}{参考文献反向超链接选项}{ref:hyperlink:back}
\usepackage[backend=biber,bibstyle=gb7714-2015,citestyle=gb7714-2015,%
backref=true%
]{biblatex}
\end{codetex}

需要注意的是，反向超链接主要是对页码进行链接，而对页码进行正确超链接需要一个前提，即当前链接的页码是唯一的。当有两页具有相同的页码时，超链接总是链接到第一个具有该页码的页面上。比如当封面页页码是1，正文第一页页码也是1，那么到正文第一页的反向超链接总会链接到封面页上。解决该问题就是要解决页码的唯一性问题。当页码的表示形式不同时，页码也能得到正确的区分。比如封面页用罗马字母I表示，而正文第一页用阿拉伯数字1表示，那么就能得到正确的反向超链接。

测试文档见:
\href{run:exampleandimage/test-backref.tex}{test-backref.tex}。


\subsection{\LaTeX 文档的编译}
文档的编译与\LaTeX 传统方法一致，只是中间的参考文献编译过程略有变化，biblatex宏包使用biber后端时，准备参考文献数据用的命令为biber filename。编译命令可以利用软件调用，也可以自行在命令行输入，后面给出利用winedt、texstudio、命令行、和脚本等不同方式的具体操作过程。

需要注意，无论采用哪种方式编译，如果参考文献数据中存在一些特殊符号比如\&等，编译时会报错。对于这个问题除了手动修改bib文件中参考文献信息这一种方法外，还有两种自动处理方式，一是利用jabref，jabref有bibtex和biblatex两种模式，在biblatex模式下，对于一些特殊字符的输入，比如\&，jabref会自动将其转换为\textbackslash\&。二是使用gb7714-2015样式，在bib数据源不经任何处理的情况下，gb7714-2015样式也能自动处理一些特殊字符。

\subsubsection{编译命令}

一般情况下采用xelatex进行编译，命令为:
\begin{codetex}{xelatex编译命令}{cmd:xelatex}
    xelatex jobname.tex
    biber jobname
    xelatex jobname.tex
    xelatex jobname.tex
\end{codetex}

当然也可以使用pdflatex进行编译，命令为:
\begin{codetex}{pdflatex编译命令}{cmd:pdflatex}
    pdflatex jobname.tex
    biber jobname
    pdflatex jobname.tex
    pdflatex jobname.tex
\end{codetex}

但要注意的是使用pdflatex进行编译，可能因为某些样式比如authoryear，使用了xstring宏包中的一些命令，进而导致错误，但numeric类样式通常没有问题。这一问题在biblatex更新到3.12版本后取消xstring宏包后得以解决。

中文用户编译还需要注意编码问题。utf-8编码的文档，采用xelatex编译没有任何注意事项，但使用pdflatex编译时，需要给ctex宏包加载UTF8选项，比如\verb|\usepackage[UTF8]{ctex}|，该选项在文档类加载时给出也可，比如\verb|\documentclass[[UTF8]{article}|，同时引用文献时使用的引用关键词应使用英文。当文档使用其他编码时，xelatex编译通常需要指定一个文档编码，比如windows环境下的GB2312编码的文档需要指定\verb|\XeTeXinputencoding "GBK"|，否则会显示乱码。使用pdflatex进行编译时，如果biblatex不能正确的处理编码问题，那么需要为其明确的指定texencoding和bibencoding选项。比如windows环境下的GB2312编码的文档，需要指定\verb|\usepackge[texencoding=GBK]{biblatex}|。

参考测试文档:
\href{run:exampleandimage/test-gbk-pdflatex.tex}{test-gbk-pdflatex.tex}，
\href{run:exampleandimage/test-gbk-pdflatex.tex}{test-gbk-xelatex.tex}，
\href{run:exampleandimage/test-gbk-pdflatex.tex}{test-utf8-pdflatex-cls.tex}，
\href{run:exampleandimage/test-gbk-pdflatex.tex}{test-utf8-pdflatex-pkg.tex}。


\subsubsection{利用winedt}
当文档准备好之后，第一步点击winedt工具栏的xelatex按钮(\parbox{1.2cm}{\includegraphics[width=1.2cm]{button-compiler-winedt}}图中红框内的按钮)完成第一遍\LaTeX 编译；
第二步，打开命令行(可以用winedt菜单accessories下command prompt项)输入命令biber filename完成参考文献数据准备；
第三步，再次点击xelatex编译按钮，完成编译，如果存在反向超链接，那么再次用xelatex编译一遍可以得到正确结果。

\subsubsection{利用texstudio}
texstudio可以多平台使用，在windows和linux下均可。texstudio可以通过利用元命令构建编译命令实现一键编译，进入选项菜单的设置texstudio项，首先在常规选项卡下设置语言为zh\_cn将texstudio界面语言转变为中文，然后在构建选项卡设置默认的编译器为xelatex，设置默认文献工具为biber(图\ref{texstudio:defaulttool})，然后点击构建并查看的配置按钮(\parbox{0.5cm}{\includegraphics[width=0.5cm]{texstudio-cmd-set}})，设置工具栏构建并查看按钮(\parbox{0.5cm}{\includegraphics[width=0.5cm]{texstudio-cmd-build}})对应的命令由5个元命令构成(图\ref{texstudio:compilerchain})。这样点击构建并查看按钮即可完成一键编译功能。其编译的过程提示信息如例\ref{texstudio:onekeycompile}所示(环境为windows 7 x64+texlive 2016+tex studio 2.10.8)。

\begin{codetex}{texstudio一键编译过程提示}{texstudio:onekeycompile}
开始 : xelatex.exe -synctex=1 -interaction=nonstopmode "test".tex
完成

开始 : biber.exe "test"
INFO - This is Biber 2.5
INFO - Logfile is 'test.blg'
INFO - Reading 'test.bcf'
INFO - Found 0 citekeys in bib section 0
INFO - Found 4 citekeys in bib section 1
INFO - Found 0 citekeys in bib section 0
INFO - Processing section 1
INFO - Looking for bibtex format file 'example.bib' for section 1
INFO - Decoding LaTeX character macros into UTF-8
INFO - Found BibTeX data source 'example.bib'
WARN - Overwriting field 'year' with year value from field 'date' for entry ' 鍒樻捣娲013--'
WARN - Overwriting field 'year' with year value from field 'date' for entry ' 鑳′紵2011--'
WARN - BibTeX subsystem: C:\Users\ADMINI~1\AppData\Local\Temp\pru9Tr4B7_\example.bib_6592.utf8, line 1198, warning: possible runaway string started at line 1197
INFO - Overriding locale 'en-US' defaults 'normalization = NFD' with 'normalization = prenormalized'
INFO - Overriding locale 'en-US' defaults 'variable = shifted' with 'variable = non-ignorable'
INFO - Sorting list 'none/global/' of type 'entry' with scheme 'none' and locale 'en-US'
INFO - No sort tailoring available for locale 'en-US'
INFO - Writing 'test.bbl' with encoding 'UTF-8'
INFO - Output to test.bbl
INFO - WARNINGS: 3
完成

开始 : xelatex.exe -synctex=1 -interaction=nonstopmode "test".tex
完成

开始 : xelatex.exe -synctex=1 -interaction=nonstopmode "test".tex
完成
\end{codetex}


\begin{figure}[!htb]
  \centering
  \includegraphics[width=\figwd\textwidth]{texstudio-defaulttool}
  \caption{texstudio设置默认的编译工具}\label{texstudio:defaulttool}
\end{figure}

\begin{figure}[!htb]
  \centering
  \includegraphics[width=\figwd\textwidth]{texstudio-compilerchain}
  \caption{texstudio配置构建并查看命令}\label{texstudio:compilerchain}
\end{figure}

linux(以deepin linux x64 v15+texlive 2016+texsudio为例)下texstudio的设置是类似的，但要正常编译还有一个关键问题，即还需要设置路径，这不是系统环境的路径设置，而是要告诉texstudio编译工具所在的路径，这同样在菜单选项下的设置texstudio项中设置，仍然进入构建选项卡，左下角点选显示高级选项，然后设置命令(\$PATH)为/usr/local/texlive/2016/bin/x86\_64-linux，如图\ref{texstudio:path:linux}所示。

\begin{figure}[!htb]
  \centering
  \includegraphics[width=\figwd\textwidth]{texstudio-path-linux}
  \caption{linux下texstudio设置命令路径}\label{texstudio:path:linux}
\end{figure}

\subsubsection{命令行或脚本}

命令行编译本质上是在命令行手动输入命令，命令过程仍然是一遍xelatex编译，biber编译，两边xelatex编译，命令如下:

\begin{codetex}{命令行手动输入的命令}{cmd:prompt}
xelatex.exe -synctex=1 -interaction=nonstopmode "test".tex
biber.exe "test"
xelatex.exe -synctex=1 -interaction=nonstopmode "test".tex
xelatex.exe -synctex=1 -interaction=nonstopmode "test".tex
\end{codetex}


利用脚本编译原理是一样的，只是利用编译脚本文件进行自动编译，注意:linux下的脚本文件需要添加一下路径。比如:
\begin{codetex}{window下的bat脚本文件}{bat:file:cmd}
@echo off
:: compile the tex file
xelatex.exe --synctex=-1 "test".tex
:: compile bibliography
biber "test"
:: compile again
xelatex.exe --synctex=-1 "test".tex
::to do it again for backref
xelatex.exe --synctex=-1 "test".tex
:: clear aux files
del /q *.aux *.bbl *.blg *.log *.out *.toc *.bcf *.xml *.synctex *.nlo *.nls *.bak *.ind *.idx *.ilg *.lof *.lot *.ent-x *.tmp *.ltx *.los *.lol *.loc *.listing *.gz
\end{codetex}

\begin{codetex}{linux下的sh脚本文件}{sh:file:cmd}
#!/bin/bash
# exec path for tex live 2016
export PATH=${PATH}:/usr/local/texlive/2016/bin/x86_64-linux

#compile the tex file
xelatex --synctex=-1 "test".tex
#compile bibliography
biber "test"
#compile again
xelatex --synctex=-1 "test".tex
#to do it again for backref
xelatex --synctex=-1 "test".tex
#clear aux files
rm -r *.aux *.bbl *.blg *.log *.out *.toc *.bcf *.xml *.synctex *.nlo *.nls *.bak *.ind *.idx *.ilg *.lof *.lot *.ent-x *.tmp *.ltx *.los *.lol *.loc *.listing *.gz
\end{codetex}

\subsubsection{利用latexmk宏包}
利用latexmk宏包可以实现一键编译，即使用一条命令即可完成整个编译过程。
\begin{codetex}{latexmk编译命令}{cmd:latexmk}
latexmk -xelatex "test.tex"
\end{codetex}

利用latexmk进行编译的方式也可以在winedt中实现，即定制winedt的工具按钮以实现一键编译功能。具体参见：
\href{https://blog.csdn.net/xenonhu/article/details/80010659}{Winedt 一键编译 LaTeX 文档}

\subsection{分章参考文献和书后参考文献}

分章参考文献在书籍写作中是一种比较常见的需求。在 LateX 传统方法中，利用thebibliography 环境可是实现，但其格式只能在 bibitem 内输入，对于文献量较大时是不适合的。

而利用 bibliographystyle 和 bibliography 命令生成的参考文献可以与thebibliography 环境同时存在，生成多个不同的文献表，可以插入多个文献表但却是相同的，这是因为编译文档时，所有的信息都是写入一个 aux 文件中的。所以要实现分章参考文献表，需要使用 chapterbib 或 multibib 宏包，使用 chapterbib 时要把需要生成文献表的章放到单独的 tex 文件中，然后用 include 命令包含进主文件，这样可以生成多个 aux 文件以便生成分章参考文献表。而使用 biblatex 宏包可以很方便的在一个 \LaTeX 文档中实现多种形式的参考文献划分，其中分章参考文献可以利用refsection环境或者宏包选项来实现。

\subsubsection{利用 refsection 环境分章}

利用 refsection 环境可以显式的设置需要打印参考文献的文档结构部分，比如把chapter 的所有内容放在 refsection 环境内，那么在该 refsection 中使用参考文献打印命令 printbibliography 就会得到该环境内的参考文献信息，
例\ref{bib:refsection}给出的代码，
结果如图\ref{bib:refsection:resa}，\ref{bib:refsection:resb}所示。

\begin{codetex}{分章参考文献}{bib:refsection}
\documentclass{report}%%file:egrefsection.tex
\usepackage{ctex}
\usepackage[paperwidth=12cm,paperheight=6cm,top=0cm, bottom=1.5cm, left=1cm,right=1cm]{geometry}
\usepackage{titlesec}
\titleformat{\chapter}{\zihao{4}\heiti}{\thechapter}{1em}{}
\titlespacing*{\chapter}{0pt}{0.0\baselineskip}{0.5\baselineskip}[0pt]
\titleformat{\section}{\zihao{5}\heiti}{\thesection}{1em}{}
\titlespacing*{\section}{0pt}{0.5\baselineskip}{0.5\baselineskip}[0pt]
\usepackage[backend=biber,style=gb7714-2015]{biblatex}
\addbibresource[location=local]{example.bib}

\begin{document}
\chapter{序章}
\begin{refsection}
序章内容\cite{GPS1988--}
\printbibliography[heading=subbibliography,title=本章参考文献]
\end{refsection}

\chapter{正文章一}
\begin{refsection}
正文内容一\cite{杨洪升2013-56-75}
\printbibliography[heading=subbibliography,title=本章参考文献]
\end{refsection}

\chapter{正文章二}
\begin{refsection}
正文内容二\cite{马克思2013-302-302}
\printbibliography[heading=subbibliography,title=本章参考文献]
\end{refsection}
\end{document}
\end{codetex}

\begin{figure}[!htb]
  \centering
  \fbox{\includegraphics[width=\figwd\textwidth,page=1]{egrefsection.pdf}}
  \caption{分章参考文献举例-序章}\label{bib:refsection:resa}
\end{figure}

\begin{figure}[!htb]
  \centering
  \fbox{\includegraphics[width=\figwd\textwidth,page=2]{egrefsection.pdf}}
  \caption{分章参考文献举例-章一}\label{bib:refsection:resb}
\end{figure}

\subsubsection{利用宏包选项 refsection 分章}
除了利用 refsection 环境显式方法外，还可以利用宏包选项 refsection=chapter 等来设置需要区分打印参考文献的文档结构，这里设置 refsection=chapter 表示以章为单位区分打印参考文献，也可以设置成 section，那么就是以节为单位进行区分打印。
例\ref{bib:opt:refsection}给出的代码，结果如图\ref{bib:refsection:resc}所示，可以看到其结果与图\ref{bib:refsection:resa}完全一致。

需要注意的时，因为使用refsection选项需要利用chapter或section这样的命令进行文献分节处理，所以biblatex会对这些命令进行充定义，因此也就导致了与其它需要重定义这些命令的宏包的可能冲突，比如titlesec宏包。当然这种冲突也只是在使用refsection选项的情况下，当不使用该选项时，biblatex也不会做patch，因此也就不会产生冲突。

\begin{codetex}{利用宏包选项实现分章参考文献}{bib:opt:refsection}
\documentclass{report}%%file:egrefsectionb.tex
\usepackage{ctex}
\usepackage[paperwidth=12cm,paperheight=6cm,top=0cm, bottom=1.5cm, left=1cm,right=1cm]{geometry}
\usepackage{titlesec}
\titleformat{\chapter}{\zihao{4}\heiti}{\thechapter}{1em}{}
\titlespacing*{\chapter}{0pt}{0.0\baselineskip}{0.5\baselineskip}[0pt]
\titleformat{\section}{\zihao{5}\heiti}{\thesection}{1em}{}
\titlespacing*{\section}{0pt}{0.5\baselineskip}{0.5\baselineskip}[0pt]
\usepackage[backend=biber,refsection=chapter,style=gb7714-2015]{biblatex}
\addbibresource[location=local]{example.bib}

\begin{document}
\chapter{序章}
序章内容\cite{GPS1988--}
\printbibliography[heading=subbibliography,title=本章参考文献]

\chapter{正文章一}
正文内容一\cite{杨洪升2013-56-75}
\printbibliography[heading=subbibliography,title=本章参考文献]

\chapter{正文章二}
正文内容二\cite{马克思2013-302-302}
\printbibliography[heading=subbibliography,title=本章参考文献]
\end{document}
\end{codetex}

\begin{figure}[!htb]
  \centering
  \fbox{\includegraphics[width=\figwd\textwidth,page=1]{egrefsectionb.pdf}}
  \caption{设置宏包选项实现分章参考文献}\label{bib:refsection:resc}
\end{figure}

\subsubsection{统一的全局参考文献}

biblatex 参考文献利用 refsection 很容易生成分章节的参考文献，但如果要生成一个全局的参考文献，那么可以不使用任何的 refsection 或者使用一个 refsection 包含全部的文档(注意: 两种方法一般情况下都是可行的，但在 beamer 类第二种方法不能使用，见第\ref{sec:bib:inbeamer}节的说明)。

但还有一种情况是既要生成分章参考文献又要有一个全局的参考文献。那么最简单的方式在文末利用 printbibliography 的 section 选项对所有的 refsection 同时打印一遍，代码如例\ref{bib:global:refsection}所示，但这样的方式更像是文献表堆积，不像一个统一的文献表，且其中的各章的文献引用标注序号不是全局的，只是各refsection 内部的序号。

\begin{codetex}{利用refsection的全局参考文献}{bib:global:refsection}
\printbibliography[section=1,heading=subbibliography,title=第一章参考文献]
\printbibliography[section=2,heading=subbibliography,title=第二章参考文献]
\printbibliography[section=3,heading=subbibliography,title=第三章参考文献]
\end{document}
\end{codetex}

这个问题可以在 refsection 外使用 nocite 后再打印一个全局文献表来解决，也可以用refsegment 代替 refsection 来解决。

refsegment 与 refsection 作用很像，也用于划分，但其内部的文献序号是全文统一的。每一个 segment 都有一个编号(从1开始)，用 printbibliography 命令打印在某个refsegment 环境内的使用参考文献，只需要给出 segment=编号整数 的一个值，该值表示第几个 refsegment 环境。而在 refsegment 环境外的参考文献默认在 segment=0 的segment 内，若 printbibliography 命令中给出 segment=0 则打印不在任一refsegment 环境内的文献，若不给出 segment 参数则遍历所有可以打印的参考文献，包括各个 refsegment 内的文献。

注意: refsection 内部不可以有 refsection ，即 refsection 不可嵌套，但其内部可以使用 refsegment。printbibliography 命令也可以对 refsection 内的所有refsegment 遍历打印，也可以指定 refsection 内的某一个 refsegment 中的文献，只要给出 segment 参数，当 printbibliography 在 refsection 外打印其内 refsegment 中的文献，则还需指定 section 参数。

例\ref{eg:global:complex}给出一个测试代码，
其结果如图\ref{fig:eg:global:complex}所示。其中“文献全局”命令遍历打印了所有不在 refsection 内的文献，包括 refSegment A，refSegment B，以及不在其内的Gradshteyn 文献和附录的 Section E 中的 Parsons 文献。

注意到，其中全局文献表的顺序编码是正常的全局顺序，但对于每一分段(segment 内)该编码就不是当前段内的编码顺序。如果使用 defernumbers 选项，那么可以将每个segment 内的编码改为第一次打印该文献时的编码，当因为 segment 内的文献编码都是全局的，所以无法在一个 segment 内从1开始编码。

另外，如果不使用refsegment来实现全局的文献表，那么完全可以利用nocite命令在文档末尾引入需要出现在全局文献表中的文献，但此时文献表中文献的顺序可能与各章出现的顺序不一致，但从显示文献表的角度，这时完全没有问题的。

\begin{codetex}{全局参考文献综合示例}{eg:global:complex}
%file:egbibdiv.tex
%file:egbibdiva.tex
\end{codetex}

见：\href{run:exampleandimage/egbibdiv.tex}{egbibdiv.tex}，
\href{run:exampleandimage/egbibdiva.tex}{egbibdiva.tex}。

\begin{figure}[!htb]
	\centering
	% Requires \usepackage{graphicx}
	\fbox{\includegraphics[width=0.9\linewidth]{egbibdiv.pdf}}\\
	\caption{全局参考文献综合示例}\label{fig:eg:global:complex}
\end{figure}

\subsection{参考文献著录和标注样式}\label{sec:bib:style}

参考文献著录和标注样式是排版的主要内容之一，但对于普通用户来说只要学会选择使用即可，因为其格式已经由样式作者所设定。当然如果用户需要在某种样式的基础上有进一步的修改，那么完全可以开展这方面的工作。其中著录样式的在*.bbx文件中修改，而标注样式在*.cbx文件中修改。

\subsubsection{标准样式}
biblatex提供了一些标准的样式，比如numeric，authoryear，这两个样式是比较常用的，也是样式作者定制自定义样式的重要基础。biblatex还提供了更多著录样式，比如alphabetic，authortitle，verbose等，详见 biblatex 手册 Bibliography Styles 一节。标注样式也还有 numeric-comp，numeric-verb，alphabetic，authortitle 等，详见 biblatex 手册 Citation Styles 一节。

\emph{特别需要强调的是numeric-comp，authoryear-comp是针对顺序编码和作者年制的两个标签压缩样式，顺序编码制的压缩样式主要针对多篇文献传递给一个标注命令的情况，而作者年制的压缩样式除了给一个标注命令传递多篇文献外，还需要连续引用文献具有相同作者，而要使相同作者的文献连续，可以通过手动方式给出，也可以通过自动排序方式实现}。

读者可以参考biblatex附带的96个示例文件，也可以测试这些样式的效果，以便在需要的时候选择使用。而且著录和标注可以分别使用不同的样式，著录是一种，而标注则是另一种，实际使用的例子
可以参考\href{https://github.com/sjtug/SJTUThesis/issues/300}{参考文献的顺序}。


\subsubsection{常用样式}

除标准样式外，在texlive安装目录中或者ctan上面可以找到更多的常用样式，比如符合国外的APA，MLA，国内的GB/T 7714-2015等标准的样式，也有一些针对某些期刊的文献样式，比如nature，science，nejm等等，也有一些是作者自己兴趣所做形成了自己喜欢的风格，比如:biblatex-caspervector样式包。用户可以测试各样式包，并按需使用，进一步也可以参考其代码，修改自己需要的样式。表\ref{tab:styles:blx}列出了这些常用的样式。

% Table generated by Excel2LaTeX from sheet 'Sheet1'
\begin{table}[!htb]
\centering
\caption{常用的biblatex样式}\label{tab:styles:blx}
\footnotesize
\begin{tabular}{p{2cm}p{3cm}p{3cm}p{6cm}}
   \hline
    样式名   & 对应的bibtex样式 & 作者介绍  & 样式说明 \\ \hline
    trad-plain & plain & MarcoDaniel and MoritzWemheuer，后者是biblatex维护者之一 & 将引文按字母顺序排序,比较次序为作者姓氏、出版年份和题名,如果不能顺序,将以在正文中的引用顺序为准。 \\
    trad-unsrt & unsrt & MarcoDaniel and MoritzWemheuer & 按照在正文中引用文献的先后顺序排列文献,其排版格式与trad-plain基本相同 \\
    trad-alpha & alpha & MarcoDaniel and MoritzWemheuer & 用文献的作者姓氏前三个字母加出版年份的后两位数作为文献序号,如果出现相同的序号,则会根据排序结果在序号后追加字母以示区别，排序方法和排版格式与trad-plain相同 \\
    trad-abbrv & abbrv & MarcoDaniel and MoritzWemheuer & 将文献中作者名和月份名的拼写改为缩写, 显得文献信息紧凑简洁, 其排序方法和排版格式与trad-plain相同 \\
    ieee  & IEEEtran & Joseph Wright，biblatex 维护者之一 & 国际电气电子工程师协会IEEE期刊文献格式 \\
    apa   & apalike & Philip Kime，biblatex 作者之一 & American Psychological Association 的文献格式 \\
    Chicago & Chicago & David Fussner & for the Chicago Manual of Style \\
    iso-numeric &       & Michal Hoftich & ISO690 international standard numeric system \\
    iso-iso-authoryear &       & Michal Hoftich & ISO690 international standard nameanddate system,so-called Harvard style \\
    gb7714-2015 & gbt7714-unsrt.bst by zepinglee & hushidong & 中文文献著录标准 GB/T 7714-2015 顺序编码制 \\
    gb7714-2015ay & gbt7714-plain.bst by zepinglee & hushidong & 中文文献著录标准 GB/T 7714-2015 著者年份制 \\
    caspervector &       & Casper vector & 一种中文文献格式 \\
    nature &       & Joseph Wright & for Nature \\
    science &       & Joseph Wright & for Science \\
    chem-acs &       & Joseph Wright & covers most American Chemistry Society journals \\
    chem-angew &       & Joseph Wright & covers Angewandte Chemie Chemistry–A European Journal. \\
    chem-biochem &       & Joseph Wright & covers Biochemistry and asmallnumber of other American Chemistry Society journals \\
    chem-rsc &       & Joseph Wright & covers all Royal Society of Chemistry journals \\
    phys  &       & Joseph Wright & for AIP and APS \\
    nejm  &       & MarcoDaniel & for New England Journal of Medicine \\
    mla   &       & James Clawson & for Modern Language Association \\
    authortitle-dw &       & Dominik Waßenhoven & for Humanities \\
    footnote-dw &       & Dominik Waßenhoven & for Humanities \\ \hline
    \end{tabular}
\end{table}%



\subsubsection{gb7714-2015}
目前符合GB/T 7714-2015标准的 biblatex 样式，是本文作者制作的 gb7714-2015 样式包，分顺序制和作者年制两类。其加载方式见例\ref{code:pkg:load}。

该样式包，实现了GB/T 7714-2015标准的完整要求，包括两种编制方式下的各类型参考文献著录格式和标注格式等基本内容，还包括:自动判断文献类型和载体、自动并判断区分文献语言、双语对照文献，带页码的标注格式，作者年制下文献的自动排序和仅有年的标注格式，两种编码制方式下责任者缺省不同处理，其他信息缺省时的自动处理，一些信息如页码卷期自动解析等功能。

该样式包增加了标签的对齐方式(gbalign选项)、出版项缺省时的处理(gbpub选项)、作者缺省时的处理(gbnoauthor选项)、作者姓名格式的调整(gbnamefmt选项)、文献类型和载体标识的输出控制(gbtype选项)、析出文献标识符\texttt{//}控制(gbpunctin选项)、GBK编码文档兼容性(gbcodegbk选项)、域的默认格式还原(gbfieldstd选项)、标题的超链接控制(gbtitlelink选项)等。能通过标注和著录分别采用著者-出版年制（即作者年制）、顺序编码制样式实现特殊的参考文献格式，并尽最大可能利用biblatex的选项来实现一些特殊需求，比如文献表中作者数量大于3、标注中仅给出第一作者的姓、参考文献表按拼音或笔画排序等等。

该样式包可与biblatex v2.8 (contained in texlive2014) 以上所有版本配合使用(注意 ctex 2.9.4 的用户需升级 biblatex)。兼容传统的参考文献条目类型，比如www/electronic/conference/mastersthsis/phdthsis/techreport/standard，并根据国标要求增加了newspaper(报纸析出的文献)、database(数据库)、dataset(数据集)、 software(软件)、map(舆图)、archive(档案)等类型。兼容适用于不同样式的bib数据源，可与gbt7714宏包的bst样式使用的bib文件无缝衔接。

关于参考文献数据录入准备、条目类型的域构成、样式包使用说明等更多的内容详见\cite{胡振震2016}。在使用需要注意一种情况，即再一部作品中，同时存在上标标注和非上标标注，在标准样式下有supercite命令提供上标模式，而cite和parencite命令提供非上标模式。而在gb7714-2015样式中，supercite和cite命令提供上标模式，而parencite命令提供非上标模式。

关于该样式包的安装和升级，在2017年以后tex发行版本中，biblatex-gb7714-2015样式宏包不再需要安装，直接使用，因为texlive和miktex均已收录。而老版本的texlive 比如texlive 2016及以下版本下可以离线方式安装，使用如下步骤:

(a) 在ctan上面下载biblatex-gb7714-2015宏包，下载地址:https://www.ctan.org/pkg/biblatex-gb7714-2015

(b) 解压压缩包，放到:texlive的texmf-dist/tex/latex或者texmf-local/tex/latex或者它们的子目录下面。(参考:文献\parencite{Berry2016--}的3.4.6节)

(c) 运行texhash或者mktexlsr命令，刷新文件名数据库。

因为texlive每年更新一次，老的版本就会冻结，一般情况下，老版本texlive中宏包时无法通过tlmgr升级到最新的版本的。因此通常的方式是下载新的宏包用离线下载的方式覆盖安装。但一般情况下不需要如此处理。如果使用最新的发行版，那么可以使用tlmgr更新宏包，步骤如下:

(a) 打开tlmgr-gui，在选项通用里面设置国内的ctan镜像源，比如\url{http://mirrors.ustc.edu.cn/CTAN/systems/texlive/tlnet}

(b) 点击，加载缺省软件包仓库。加载完成后可能要求升级tlmgr，那么先升级tlmgr。

(c) 在完成加载后，在匹配文本框填入biblatex-gb7714-2015，搜索安装即可。

\subsubsection{标注命令}

传统方法中类似natbib，mcite这样的宏包提供了很多有特色的标注命令。比如:
\begin{codetex}{natbib和mciteplus等宏包提供的标注名}{eg:cite:natbib}
\citep{jon90} fora parenthetical citation(Jones et al.,1990),
\citet{jon90} fora textual one, as Jones et al.(1990).
\citealt{jon90} Jonesetal.1990
\citealt*{jon90} Jones,Baker,andWilliams1990
\citealp{jon90} Jones et al.,1990
\citealp*{jon90} Jones,Baker,and Williams,1990
\citealp{jon90,jam91}  Jones et al.,1990;James et al.,1991
\citealp[pg.~32]{jon90}  Jones et al.,1990,pg.32
\citenum{jon90}  11
\citetext{priv.\comm.} (priv.comm.)

\citeauthor{jon90} ) Jonesetal.
\citeauthor*{jon90} ) Jones,Baker,andWilliams
\citeyear{jon90} ) 1990
\citeyearpar{jon90} ) (1990)

\cite{Glashow,*Salam,*Weinberg,Smith,*Jones}%multiplegroupsOK
\cite{Glashow,*Salam,*Weinberg}\cite{Glashow}%headcanberecitedanytime
\cite{Glashow,*Salam,*Weinberg}\cite{Glashow,*Salam,*Weinberg}%restatepreviousdefinition
\cite{Glashow,*Salam,*Weinberg}\cite{Glashow,*Weinberg}%restatepartofpreviousdefinition
\cite[page580ofGlashow]{Glashow,*Salam}%optionalargumentissupported
\nocite{*}%BibTeXwildcardOK,butusewithcaution
\end{codetex}

biblatex通过相应的处理模块，给出功能相同语法相同的命令。

此外，biblatex还提供更多标注命令，以及强大的标注命令定制功能，biblatex-gb7714-2015中的标注命令如例\ref{eg:cite:cmds}所示：

\begin{codetex}{常见的标注命令}{eg:cite:cmds}
1. 不带页码的引用(上标，方括号包围):
\cite{Peebles2001-100-100}

2. 不带页码的引用(非上标，方括号包围):
\parencite{Miroslav2004--}

3. 带页码的引用:
\cite[见][49页]{蔡敏2006--}  \parencite[见][49页]{Miroslav2004--}
\pagescite{Peebles2001-100-100}  \pagescite[][201-301]{Peebles2001-100-100}

4. 顺序编码制中同时输出作者和顺序编码标签，比如：
（一）直接的方法：见\citeauthor{refb}\cite{refb},\citeauthor{refc}\cite{refc}
（二）定义新的标注命令：见\authornumcite{refb,refc}
（三）用textcite但没有上标：见\textcite{refb,refc}

5. 作者年制文中已有作者还需要年份和页码的情况，使用命令yearpagescite，比如:
见赵耀东\yearpagescite[][205]{赵耀东1998--}和Simon\yearpagescite[][15]{Simon2001--}

6. 作者年制文中已有作者只需要年份的情况，使用命令yearcite和手动方式，比如:
见赵耀东\yearcite{赵耀东1998--}
见赵耀东(\cite*{赵耀东1998--})
见赵耀东(\citeyear{赵耀东1998--})

7. 在页脚中引用和打印文献表:
\footnote{在脚注中引用\footcite{赵学功2001--}}  \footfullcite{赵学功2001--}
\end{codetex}


\subsubsection{参考文献文境}

参考文献文境是biblatex 高度可定制性可扩展性的体现。biblatex 认为文献的引用和打印都是在一个文境中的，因此在不同的文境中就可以有不同的设置，这些设置包括：
排序模板、构建姓名排序关键字的模板、使用字母或数值标签的标注格式的前缀字符串、计算姓名唯一性信息的模板、构造姓名的字母顺序标签的模板。因此要在一个文档中使用不同的这些设置，那么可以利用参考文境文境。文境会用于设置影响参考表打印的选项；设置的选项还可以影响标注命令输出的数据。biblatex手册中给出了几个典型的应用场景，包括：(1)打印多个文献表，不同的文献表使用不同的排序。(2)打印多个文献表，不同的文献表使用不同的排序模板，进而导致排序使用的数据也是不同的。(3)打印多个文献表，不同的文献表使用不同的排序，不同的文献表使用不同的标签。

另外一个应用场景是第\ref{sec:sort:bibandcite}节提到的示例，标注和文献表使用不同的排序。比如要求标注排序使用ynt，而文献表排序使用nyt。

需要注意：默认情况下，用于标注的数据来自于打印该条目的最后一个参考文献表所在的著录文境。对于某些没有在文献表中打印条目但又以某种方式给出的标注命令，它们默认从文档开始时建立的全局文境获取数据。要覆盖这一行为，可以手动将标注命令放在 refcontext 环境内，但是这样容易出错并且很繁琐。而 assignrefcontext 这些命令可以用来设置一个由 keywords、categories 或 entrykeys 构成的逗号分隔列表，使带有这些指定关键字、或属于任何指定类别 、或指定引用关键字的条目可以从 refcontext key/values 指出的特定文境获取数据，这些 refcontext key/values 选项会被解析为对应的 refcontext 选项。



\subsection{参考文献标题格式}

期刊文章经常需要设置某种格式的参考文献标题，包括字号，大小，段落格式等。在书籍等写作中有时还需要将参考文献加入目录中，以便实现超链接。
\subsubsection{加入目录链接}

加入目录的命令是addcontentsline，在printbibliography命令前使用该命令即可将参考文献加入目录中，同时为了能够超链接正确可以加入hyperref宏包提供的phantomsection命令。例\ref{bib:inserttoc}给出了代码。
\begin{codetex}{手动加入目录链接}{bib:inserttoc}
\addcontentsline{toc}{chapter}{参考文献}
\phantomsection
\printbibliography[heading=bibliography,title=本章参考文献]
\end{codetex}

除了上述手动添加的方式外，还可以在printbibliography命令使用biblatex提供的选项来实现，比如heading=bibintoc，该选项与heading=bibliography是类似的，只是增加了在目录中加入链接的功能，例\ref{bib:inserttoc:bibintoc}给出了代码。
\begin{codetex}{使用bibintoc加入目录链接}{bib:inserttoc:bibintoc}
\printbibliography[heading=bibintoc,title=本章参考文献]
\end{codetex}

\subsubsection{重定义heading}

默认情况下，biblatex参考文献标题的格式主要依赖于\LaTeX 文档的章节的标题格式。当printbibliography中使用heading选项的参数是bibliography和bibintoc时，参考文献标题的格式与当前文档类的主划分单元的标题格式一致，比如book和report类中与chapter一致，而在article类中与section一致。heading选项的参数是subbibliography和subbibintoc时，则与主单元的下一层级的标题格式一致，即book和report类中与section一致，而在article类中与subsection一致。因此设置参考文献标题的格式最简单方式是设置文档的各级标题格式然后选择heading选项的参数(注意当heading选项不给出时，其默认参数为bibliography)。

事实上利用defbibheading命令重定义bibliography等heading的相关信息可以改变默认的标题对应方式，比如可以将bibliography与subsubsection层级标题格式对应起来，例\ref{bib:def:headsec}给出了代码。其中还使用了phantomsection和addcontentsline命令可以完成上一小节需要的加入目录链接功能。其中还使用了centering使标题居中，这预示了一种标题格式修改方式，甚至可以不使用文档类的标题格式而直接自定义标题。

\begin{codetex}{biblatex对于目录的影响}{bib:def:headsec}
\usepackage[backend=biber,style=gb7714-2015ay]{biblatex}
\defbibheading{bibliography}[\bibname]{%
\phantomsection%解决链接指引出错的问题，相当于加入了一个引导点
\addcontentsline{toc}{subsubsection}{#1}
	\centering\subsubsection*{#1}}%
\end{codetex}

需要注意，如果要使用titleps作为页眉页脚的设置宏包，那么需要利用defbibheading重设一下heading选项参数，因为默认情况下heading的参数比如bibliography中带有markboth命令，该命令与titleps共用时会导致页眉页脚一些出现问题。例\ref{bib:def:heading}给出了代码。而使用文档类默认的页眉页脚或者利用fancyhdr设置页眉页脚，则不需要修改。为了方便移植应用，这里给出三种设置页眉页脚的代码，例\ref{head:class:ctex}是使用文档类提供和ctex修改的页眉页脚；例\ref{head:fancyhdr}是使用fancyhdr设置的页眉页脚；例\ref{head:titleps}是使用titleps设置的页眉页脚。

\begin{codetex}{重设heading选项参数}{bib:def:heading}
\defbibheading{bibliography}[\bibname]{%
	\chapter*{#1}}%
%	\markboth{#1}{#1}}
%重定义命令中去掉了markboth那一句命令。
\end{codetex}

\begin{codetex}{文档类提供ctex修改的页眉页脚举例}{head:class:ctex}
%file:egheadclass.tex
\documentclass{book}
\usepackage{ctex}
\usepackage[paperwidth=12cm,paperheight=6cm,top=1.5cm, bottom=1.5cm, left=1cm,right=1cm]{geometry}
\usepackage{titlesec}
\titleformat{\chapter}{\zihao{4}\heiti}{\thechapter}{1em}{}
\titlespacing*{\chapter}{0pt}{0.0\baselineskip}{0.5\baselineskip}[0pt]
\titleformat{\section}{\zihao{5}\heiti}{\thesection}{1em}{}
\titlespacing*{\section}{0pt}{0.5\baselineskip}{0.5\baselineskip}[0pt]
\usepackage[backend=biber,style=nature]{biblatex}
\addbibresource[location=local]{example.bib}

\renewcommand{\bibfont}{\zihao{-6}\songti}
\setlength{\bibitemsep}{2pt}
\usepackage{hyperref}
\begin{document}
\tableofcontents
\begin{refsection}
\chapter{序章}
\section{序节}
序章内容\cite{GPS1988--}
\defbibentryset{bilangyi2013}{易仕和2013--,Yi2013--}
专著，双语文献引用\cite{bilangyi2013}

\phantomsection
\addcontentsline{toc}{chapter}{参考文献}
\printbibliography[heading=bibliography,title=本章参考文献]
\end{refsection}

\begin{refsection}
\chapter{正文章一}
\section{正文节一}
正文内容一\cite{杨洪升2013-56-75}

\phantomsection
\addcontentsline{toc}{section}{参考文献}
\printbibliography[heading=subbibliography,title=本章参考文献]
\end{refsection}

\begin{refsection}
\chapter{正文章二}
\section{正文节二}

正文内容二\cite{马克思2013-302-302}
\printbibliography[heading=subbibliography,title=本章参考文献]
\end{refsection}
\end{document}
\end{codetex}

\begin{codetex}{利用fancyhdr生成页眉页脚举例}{head:fancyhdr}
%file:egheadfancy.tex
\documentclass{book}
\usepackage{ctex}
\usepackage[paperwidth=12cm,paperheight=6cm,top=1.5cm, bottom=1.5cm, left=1cm,right=1cm]{geometry}
\usepackage{titlesec}
\titleformat{\chapter}{\zihao{4}\heiti}{\thechapter}{1em}{}
\titlespacing*{\chapter}{0pt}{0.0\baselineskip}{0.5\baselineskip}[0pt]
\titleformat{\section}{\zihao{5}\heiti}{\thesection}{1em}{}
\titlespacing*{\section}{0pt}{0.5\baselineskip}{0.5\baselineskip}[0pt]
\usepackage[backend=biber,style=nature]{biblatex}
\addbibresource[location=local]{example.bib}

\renewcommand{\bibfont}{\zihao{-6}\songti}
\setlength{\bibitemsep}{2pt}
\usepackage{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}
\renewcommand{\chaptermark}[1]{%
\markboth{#1}{}}
\renewcommand{\sectionmark}[1]{%
\markright{\thesection\ #1}}
\fancyhf{} % delete current header and footer
\fancyhead[LE,RO]{\bfseries\thepage}
\fancyhead[LO]{\bfseries\rightmark}
\fancyhead[RE]{\bfseries\leftmark}
\renewcommand{\headrulewidth}{0.5pt}
\renewcommand{\footrulewidth}{0pt}
\addtolength{\headheight}{0.5pt} % space for the rule
\fancypagestyle{plain}{%
\fancyhead{} % get rid of headers on plain pages
\renewcommand{\headrulewidth}{0pt} % and the line
}

\begin{document}
\tableofcontents
\begin{refsection}
\chapter{序章}
\section{序节}
序章内容\cite{GPS1988--}
\defbibentryset{bilangyi2013}{易仕和2013--,Yi2013--}
专著，双语文献引用\cite{bilangyi2013}

\phantomsection
\addcontentsline{toc}{chapter}{参考文献}
\printbibliography[heading=bibliography,title=本章参考文献]
\end{refsection}

\begin{refsection}
\chapter{正文章一}
\section{正文节一}
正文内容一\cite{杨洪升2013-56-75}

\phantomsection
\addcontentsline{toc}{section}{参考文献}
\printbibliography[heading=subbibliography,title=本章参考文献]
\end{refsection}

\begin{refsection}
\chapter{正文章二}
\section{正文节二}
正文内容二\cite{马克思2013-302-302}
\printbibliography[heading=subbibliography,title=本章参考文献]
\end{refsection}
\end{document}
\end{codetex}

\begin{codetex}{利用titleps生成页眉页脚举例}{head:titleps}
%file:egheadtitleps.tex
\documentclass{book}
\usepackage{ctex}
\usepackage[paperwidth=12cm,paperheight=6cm,top=1.5cm, bottom=1.5cm, left=1cm,right=1cm]{geometry}
\usepackage[pagestyles]{titlesec}
\titleformat{\chapter}{\zihao{4}\heiti}{\thechapter}{1em}{}
\titlespacing*{\chapter}{0pt}{-1.0\baselineskip}{0.5\baselineskip}[0pt]
\titleformat{\section}{\zihao{5}\heiti}{\thesection}{1em}{}
\titlespacing*{\section}{0pt}{0.5\baselineskip}{0.5\baselineskip}[0pt]
\usepackage[backend=biber,style=nature]{biblatex}
\addbibresource[location=local]{example.bib}

\renewcommand{\bibfont}{\zihao{-6}\songti}
\setlength{\bibitemsep}{2pt}
\defbibheading{bibliography}[\bibname]{%
\phantomsection%
\addcontentsline{toc}{chapter}{#1}%
\chapter*{#1}}%
\defbibheading{subbibliography}[\bibname]{%
\phantomsection%
\addcontentsline{toc}{section}{#1}%
\section*{#1}}%
\usepackage{hyperref}

\newpagestyle{main}{%偶数页
\sethead[\small$\cdot$~\thepage~$\cdot$][]
[\small\,\thesection\quad\sectiontitle]%奇数页
{\small\,\thechapter\quad\chaptertitle}{}{\small$\cdot$~\thepage~$\cdot$}
\setfoot{}{}{}\headrule\footrule}
%注意\sectiontitle应该是titlesec宏包定义的命令
\renewcommand\headrule{\setheadrule{1pt}}
\renewcommand\footrule{\setfootrule{0pt}}

\newpagestyle{premain}{
\sethead[\small$\cdot$~\thepage~$\cdot$][][\small\,目录]
{\small\,\leftmark}{}{$\cdot$~\thepage~$\cdot$}
\setfoot{}{}{}\headrule\footrule}

\newpagestyle{pgref}{%
	\sethead[\small\,~\thepage~]% 偶数页左
	[]% 偶数页中
	[\small\,参考文献]% 偶数页右
	{\small\,\thechapter\quad\chaptertitle\hfil}% 奇数页左
	{}% 奇数页中
	{\small\,~\thepage~}% 奇数页右
	\setfoot{}{}{}%
	\headrule%
}%

\begin{document}
\pagestyle{premain}
\tableofcontents
\cleardoublepage

\begin{refsection}
\pagestyle{main}
\chapter{序章}
\section{序节}
序章内容\cite{GPS1988--}
\defbibentryset{bilangyi2013}{易仕和2013--,Yi2013--}
专著，双语文献引用\cite{bilangyi2013}
%\newpage
%\vfil\hspace{1pt}
%\newpage
\pagestyle{pgref}
\printbibliography[heading=bibliography,title=本章参考文献]
\cleardoublepage%页眉页脚分割正确需要该命令
\end{refsection}

\begin{refsection}
\pagestyle{main}
\chapter{正文章一}
\section{正文节一}
正文内容一\cite{杨洪升2013-56-75}
%\newpage
%\vfil\hspace{1pt}
%\newpage
\pagestyle{pgref}
\printbibliography[heading=subbibliography,title=本章参考文献]
\cleardoublepage
\end{refsection}

\begin{refsection}
\pagestyle{main}
\chapter{正文章二}
\section{正文节二}
正文内容二\cite{马克思2013-302-302}
%\newpage
%\vfil\hspace{1pt}
%\newpage
\pagestyle{pgref}
\printbibliography[heading=subbibliography,title=本章参考文献]
\cleardoublepage
\end{refsection}
\end{document}
\end{codetex}

\subsubsection{利用titlesec}

既然参考文献的标题可以使用文档类的标题格式，且titlesec的标题样式命令具有局部性，那么完全可以利用titlesec宏包定义一个需要的标题格式，在参考文献表中使用，使用完以后再恢复原来的设置。(注意: 当使用titlesec宏包重定义section等标题样式后，在defbibheading命令中使用centering可能无效)。例\ref{sec:md:titlesec}给出了测试代码，其结果如图\ref{bib:sec:md}所示。

\begin{codetex}{利用titlesec局部修改参考文献标题格式}{sec:md:titlesec}
%file:egsectitle.tex
\documentclass{book}
\usepackage{ctex}
\usepackage[paperwidth=12cm,paperheight=7cm,top=1.5cm, bottom=1.5cm, left=1cm,right=1cm]{geometry}
%注意页面高度太小的话，可能会使[openright]失效，原因待研
%这里设置paperheight=6或者5都会使第一章开启页不在奇数页
\usepackage{xcolor}
\usepackage[pagestyles]{titlesec}
\usepackage{titletoc}
\titleformat{\chapter}{\zihao{4}\heiti}{\thechapter}{1em}{}
\titlespacing*{\chapter}{0pt}{0.0\baselineskip}{0.5\baselineskip}[0pt]
\titleformat{\section}{\zihao{5}\heiti}{\thesection}{1em}{}
\titlespacing*{\section}{0pt}{0.5\baselineskip}{0.5\baselineskip}[0pt]
\usepackage[backend=biber,style=gb7714-2015]{biblatex}
\addbibresource[location=local]{example.bib}
\defbibheading{subbibliography}[\bibname]{%
\section{#1}}%
\renewcommand{\bibfont}{\zihao{-6}\songti}
\setlength{\bibitemsep}{2pt}
\usepackage{hyperref}

\begin{document}
\tableofcontents

\begin{refsection}
\chapter{序章}
\titleformat{\section}[frame]{\normalfont}{\filright\footnotesize\enspace SECTION \thesection\enspace}
{8pt}{\bfseries\filcenter}
\section{序节}
序章内容\cite{GPS1988--}
\printbibliography[heading=subbibliography,title=本章参考文献]
\end{refsection}

\begin{refsection}
\chapter{正文章一}
\section{正文节一}
正文内容一\cite{杨洪升2013-56-75}
\printbibliography[heading=subbibliography,title=本章参考文献]
\end{refsection}
\end{document}
\end{codetex}

\begin{figure}[!htb]
  \centering
  \fbox{\includegraphics[width=\figwd\textwidth,page=4]{egsectitle.pdf}}
  \caption{利用titlesec局部修改参考文献标题格式}\label{bib:sec:md}
\end{figure}


\subsection{参考文献内容格式}\label{sec:bib:content:md}

参考文献内容的字体、字号、间距等格式可以重定义biblatex宏包提供的命令来实现。

\subsubsection{一般设置方法}

字体字号由钩子命令bibfont设置，垂直间距由bibitemsep、bibnamesep、bibinitsep三个尺寸进行设置，bibitemsep表示每一条参考文献之间的间隔，bibnamesep表示当本条文献与前一条文献的责任者不同时设置的间隔，bibinitsep表示本条文献与前一条文献的首字母不同时设置的间隔(注意:当设置排序sorting=none的时候，bibinitsep的作用有所变化)，一般情况下使用bibitemsep，bibnamesep已然足够，需要注意这三个尺寸遵守addvspace的规则，同时存在时取最大的那个尺寸作为间隔。
设置的方式如例\ref{bib:font:set}所示:

\begin{codetex}{参考文献表内容的格式}{bib:font:set}
%参考文献文本字体为默认字体，字号为小五，利用ctex设置
%如果不是利用ctex宏包，可以利用其它字号设置命令
\renewcommand{\bibfont}{\zihao{6}}
%设置各条参考文献之间的间距为0pt
\setlength{\bibitemsep}{0pt}
%\setlength{\bibnamesep}{1ex}
%\setlength{\bibinitsep}{2ex}
\end{codetex}

如果还对文献表中的文献信息有更多字体、颜色、字号方面的格式设置需求，可以进一步利用域格式
比如\verb|\DeclareFieldFormat{booktitle}{\color{blue}\ttfamily#1}|进行设置，url和doi字体也可以利用urlstyle、UrlFont等命令设置，
如例\ref{bib:font:setmore}所示。

\begin{codetex}{参考文献表内容的字体颜色格式}{bib:font:setmore}
详见：egfontinbiblio.tex
\end{codetex}

见\href{run:./exampleandimage/egfontinbiblio.tex}{egfontinbiblio.tex}

另外，biblatex-gb7714-2015样式包还增加了字体控制命令bibauthorfont，bibtitlefont，bibpubfont，用于控制文献表中作者、标题、出版项的字体和颜色。还注意在beamer类中，因为beamer对biblatex做了patch，因此也可以使用beamer自身的方法进行字体和颜色控制，当然使用这三个命令也没有问题。



\subsubsection{段落格式和局部字体修改}\label{sec:env:udf}

参考文献表段落格式是由biblatex或者样式包提供的参考文献表环境打印和控制的，通常是由list环境自定义而来。因此要设置参考文献表内容的段落格式，需要从修改参考文献表环境 defbibenvironment\{bibliography\} 的重定义入手(主要是修改list环境的参数)，当然通常情况这些是不需要去做的，因为所选的样式包通常已经设置。

如果有特殊的需求也可以自定义一个参考文献表环境来控制其格式。
如果仍然使用list通用环境作为基础环境来定义的话，其段落格式的参数设置可以
参考文献\pagescite[][74-80]{Kopka2004--}\pagescite[][265-268]{Braams2015--}。
(注意到其实latex中的很多环境比如center，quote等都是由通用list环境所定义的。)

同时，因为bibfont等命令使用具有局部性，所以可以在文档中多次定义，用于打印不同格式效果的文献表。例\ref{bib:fontset:eg}给出一个完成的测试代码，其中打印了4个参考文献表，分别用了不同的字体。同时设置了bibitemsep、bibnamesep、bibinitsep三个尺寸控制各条文献的垂直间距。并且自定义了一个参考文献表环境marginref，并没有使用list环境，而是简单的编组后打印环境，可以看到其中各条文献的缩进效果。

\begin{codetex}{参考文献表内容格式修改举例}{bib:fontset:eg}
%file:egbibfont.tex
\end{codetex}
见\href{run:./exampleandimage/egbibfont.tex}{egbibfont.tex}

第一个文献表如图\ref{bib:font:normal}所示，使用的是默认字体即宋体。
第二个文献表如图\ref{bib:font:fs}所示，使用字体是Arial和仿宋。
第三个文献表如图\ref{bib:font:tt}所示，使用的是默认字体的等宽字体。
第四个文献表如图\ref{bib:font:kt}所示，使用的是Courier New和楷书字体，同时文献表环境是自定义的。(注意:因为linux下没有Arial和Courier New字体，所以用texlive自带的字体替换，linux下使用texlive自带的字体需要特殊设置，
详见\pagescite[][15-16]{Berry2016--})。

\begin{figure}[!htb]
  \centering
  \fbox{\includegraphics*[viewport=0cm 2cm 15cm 8cm,clip=true,scale=0.8,page=1]{egbibfont.pdf}}
  \caption{参考文献表格式默认字体字号六}\label{bib:font:normal}
\end{figure}

\begin{figure}[!htb]
  \centering
  \fbox{\includegraphics*[viewport=0cm 4.5cm 15cm 8cm,clip=true,scale=0.8,page=2]{egbibfont.pdf}}
  \caption{参考文献表格式仿宋字体字号六}\label{bib:font:fs}
\end{figure}

\begin{figure}[!htb]
  \centering
  \fbox{\includegraphics*[viewport=0cm 3cm 15cm 8cm,clip=true,scale=0.8,page=3]{egbibfont.pdf}}
  \caption{参考文献表格式等宽字体字号六}\label{bib:font:tt}
\end{figure}

\begin{figure}[!htb]
  \centering
  \fbox{\includegraphics*[viewport=0cm 4.5cm 15cm 8cm,clip=true,scale=0.8,page=4]{egbibfont.pdf}}
  \caption{参考文献表格式楷书字体字号六}\label{bib:font:kt}
\end{figure}

\subsubsection{文献中的特殊字符}
\newcommand{\ftcmu}{\fontspec{CMU Serif}\selectfont}

一些参考文献中可能存在一些特殊的字符，比如TEX相关的命令，数学相关的字符等。这些字符通常用tex命令输入即可。然而有的时候参考文献的输出因为字体设置的原因导致特殊字符显示异常。比如\verb|\textregistered{}|这个注册符号，在不同的字体设置情况下，正文中和文献表内的显示存在差异，比如
\href{run:./exampleandimage/test-registered.tex}{test-registered.tex}文件中注册符显示正常，而更换字体的文件
\href{run:./exampleandimage/test-registered-diff.tex}{test-registered-diff.tex}
中参考文献内的注册符与正文中的不一致。这是由于biber在处理文献信息的时候，默认情况下，首先会将一些设定的tex命令转换为utf-8字符便于比较和排序(常见的转换见recode\_data.xml文件)，因此在输出的时候如果设定的字体没有对应的utf-8字符，那么就会显示异常。这个问题本质上是字体的问题，但如果字体不能更换，就需要利用biber来解决。biber可以使用选项对输入和输出控制，如果输入时biber不做转换，或者输出时biber把utf-8字符转换回tex命令，那么都能解决该问题。其中输入选项
\verb|--decodecharsset=null|表示需要转换的字符集为空，即不做转换。而输出选项
\verb|--output-safechars|则能保证biber输出时将特殊字符转换回tex命令。更多细节详见biber文档。


特殊字符除了用tex命令输入外，有时也希望直接输入特殊字符本身，比如想在文献中直接输入希腊字母{\ftcmu αβ}，而不是用数学环境中的命令\verb|\alpha\beta|表示。但最后输出的时候并没有正确的输出。这个问题本质上仍然是字体设置问题，一般情况下文献表中的内容也采用与文档正文一致的字体，因此要直接显示类似希腊字母这样的特殊字符，使用xelatex编译时，就是需要有合适的字体支持，比如 CMU Serif 字体就支持 unicode 字符集。此时，只要设置全文档的英文主字体为 CMU Serif，那么就可以实现文献表总特殊字符的显示。

但有时正文文档使用的英文字体是不支持特殊字符的，那么可以在局部环境中使用支持特殊字符的字体，这利用前一节介绍过的 bibfont 的字体设置来实现。

\begin{codetex}{文献中的特殊字符直接显示方法}{bib:specialchar:support}
% 方法一：设置文档英文主字体，比如：
\usepackage{fontspec}
\setmainfont{CMU Serif}

% 方法二：局部利用其它支持的字体，比如：
\newcommand{\ftcmu}{\fontspec{CMU Serif}\selectfont}
\renewcommand{\bibfont}{\ftcmu}%设置英文字体不影响中文字体
\printbibliography
\end{codetex}

见\href{run:./exampleandimage/egfontgreak.tex}{egfontgreak.tex}

关于查找支持 unicode 字符的字体可以利用 fc-list 命令列出所有系统中的字体，然后查找字符串 unicode，一般带有该字符串的字体都是支持的，当然也可以一个一个字体的试，或者用字体查看软件来看字体文件的内容来确定。

\subsubsection{自定义环境举例}

如第\ref{sec:env:udf}节所述，可以利用defbibenvironment命令来自定义参考文献环境，其代码格式为如例\ref{bib:bibenvironment:eg}所示。其中还给出了顺序制样式的基本环境。对list的水平参数进行设置，以达到参考文献内容缩进对齐的效果。其中默认情况下，标签是右对齐的。如果要修改对齐方式为左对齐，可以有两种方式，一是设置域格式labelnumberwidth，二是进一步重设makelabel命令，如例\ref{bib:alignleft:eg}所示，两种方式选其一即可。

然而我们看GB/T 7714 2015 标准可以发现，其中顺序制的参考文献表中标签样式不是全部文献内容对齐，而是以当前参考文献项自身为基准进行对齐，这种方式如果通过list环境来实现修改起来会比较麻烦，因为其leftmargin需要根据每一项重设，熟悉list环境源码的朋友可以尝试一下。当然如果不使用list环境，我们可以利用hangindent或parshape来实现段落的格式。例\ref{bib:aligngbt:eg}给出了本文作者的一种实现方式，其中需要重定义\verb|\blx@bibitem|命令。详细的内容可以参考:\href{run:./exampleandimage/egbibenv.tex}{tex源文件}，其结果如图\ref{bib:env:gb}所示，注意其中参考文献条目的顺序编码序号是用一个新的计数器处理的，事实上biblatex有提供相应的信息，利用该信息的一种实现可以参考biblatex-gb7714-2015样式包的gb7714-2015.bbx文件。

\begin{codetex}{自定义参考文献表环境举例}{bib:bibenvironment:eg}
%defbibenvironment命令格式为:
\defbibenvironment{环境名}{环境开始代码}{环境结束代码}{各项的代码}

%使用list环境的defbibenvironment命令格式样例:
\defbibenvironment{bibliography}
{\list
{\printfield[labelnumberwidth]{labelnumber}}%标签，由域labelnumber信息的提供
{\setlength{\labelwidth}{\labelnumberwidth}%标签宽度设置为labelnumberwidth
\setlength{\leftmargin}{\labelwidth}%
\setlength{\labelsep}{\biblabelsep}%标签与内容间距设置为\biblabelsep
\addtolength{\leftmargin}{\labelsep}%缩进宽度设置为\labelwidth+\labelsep
\setlength{\itemsep}{\bibitemsep}%垂直间距
\setlength{\parsep}{\bibparsep}}%
\renewcommand*{\makelabel}[1]{\hss##1}}
{\endlist}
{\item}
\end{codetex}

\begin{codetex}{基于list的参考文献表标签的左对齐}{bib:alignleft:eg}
%方式一
\DeclareFieldFormat{labelnumberwidth}{\mkbibbrackets{#1}\hfill}
%方式二
\renewcommand*{\makelabel}[1]{\hss##1\hfill}
\end{codetex}

\begin{codetex}{以当前条目为基准对齐的参考文献表环境}{bib:aligngbt:eg}
%file:egbibenv.tex
\makeatletter
\def\blx@bibitem#1{%
  \blx@ifdata{#1}
    {\begingroup
     \blx@getdata{#1}%
     \blx@bibcheck
     \iftoggle{blx@skipentry}{}{%
       \blx@setdefaultrefcontext{#1}%
       \global\let\blx@noitem\@empty
       \blx@setoptions@type\abx@field@entrytype
       \blx@setoptions@entry
       \blx@thelabelnumber
       \addtocounter{instcount}\@ne
       \blx@initsep
       \blx@namesep
       \csuse{blx@item@\blx@theenv}\relax
%       \blx@initsep   %移动到上面去，恢复bibnamesep等机制的作用
%       \blx@namesep
       \csuse{blx@hook@bibitem}%
       \blx@execute
       \blx@initunit
       \blx@anchor
       \blx@beglangbib
       \bibsentence
       \blx@pagetracker
       \blx@driver\abx@field@entrytype
       \blx@postpunct
       \blx@endlangbib}%
     \par\endgroup}%这里增加了一个\par
    {}}
\makeatother
\newcommand{\itemcmd}{%
\stepcounter{bibentrynumber}
\settowidth{\lengthid}{[\arabic{bibentrynumber}]}
\addtolength{\lengthid}{\biblabelsep}
\setlength{\lengthlw}{\textwidth}
\addtolength{\lengthlw}{-\lengthid}
\addvspace{\bibitemsep}%恢复\bibitemsep的作用
%\parshape 2 0em \textwidth \lengthid \lengthlw
\hangindent\lengthid
[\arabic{bibentrynumber}]\hspace{\biblabelsep}}
\newcounter{bibentrynumber}
\newlength{\lengthid}
\newlength{\lengthlw}
\defbibenvironment{envtest}
{\begingroup\setlength{\parindent}{0em}\setcounter{bibentrynumber}{0}}
{\endgroup}
{\itemcmd}%\newline\itemcmd
\end{codetex}

\begin{figure}[!htb]
  \centering
  \fbox{\includegraphics*[viewport=0cm 2cm 15cm 15cm,clip=true,scale=0.8,page=2]{egbibenv.pdf}}
  \caption{以当前条目为基准对齐的参考文献表环境}\label{bib:env:gb}
\end{figure}

\subsubsection{参考文献表行溢出问题}

参考文献表中各条参考文献有可能长度大于文本宽度，因此会涉及到断行的问题。一般情况下，断行不会出现问题。但有的时候，特别是在biblatex-gb7714-2015 1.0g版以前，诸如inbook等类型标题标识符后的//后没有空格导致其后紧跟的单词无法断行，进而导致行的溢出。这种情况下，可以采用设置更大的tolerance值来解决，或者可以利用命令 hyphenation 指定断行点。这些设置可以与文献表打印命令放在一个编组内，如例\ref{bib:biblist:outbox}所示。

当因为url网址过长及断行不当导致溢出时，可以通过设置三个阀值来让其在数字，大写字母，小写字母后面断行，如例\ref{bib:url:outbox}所示。有时尽管url没有导致行溢出，但也设置url断行阀值，这也是为了让url内容更紧凑避免有些地方出现较大空格导致不美观。

当然biblatex还提供了一些阀值来增加断行的灵活性，比如abbrvpenalty、highnamepenalty、lownamepenalty等，但一般不需要使用。

\begin{codetex}{参考文献表行溢出问题解决}{bib:biblist:outbox}
{
%\hyphenation{Proce-edings}
\hyphenpenalty=5000 %断词阈值，值越大越不容易出现断词
\tolerance=500 %丑度，10000为最大无溢出盒子，参考the texbook 第6章
 \hbadness=100  %如果丑度超过hbadness这一阀值，那么就会发出警告
\printbibliography[heading=subbibintoc,title=【参考文献】]
}
\end{codetex}

\begin{codetex}{参考文献表url导致行溢出问题解决}{bib:url:outbox}
{
\setcounter{biburlnumpenalty}{100}
\setcounter{biburlucpenalty}{100}
\setcounter{biburllcpenalty}{100}
}
\end{codetex}

\subsection{专题：参考文献格式的修改}

由于biblatex提供了参考文献数据的完全访问能力，所以定义任何需要的样式都是可能的。因此用户一定可以选择合适的样式或者定制合适的样式来满足自身需要。当前对参考文献格式有一些特殊的需求，且现成的类似的样式还无法满足要求时，往往就需要进行定制，比如\parencite{olqa2016--}提出的问题。

在latex传统方法中，当文献量较小时，这种临时定制采用 thebibliography 环境是比较方便的，因为 thebibliography 环境显式的将其中的内容插入，因此需要什么样的格式，那么就在 bibitem 中输入指定格式的条目内容即可。但该环境存在一个问题即: 无论引用与否环境中的参考文献都会全部打印。该环境也可以用来生成多个参考文献表，当然文献量较大时采用这种手动输入方式毕竟是繁琐的。我们使用biblatex就是为了避免这种繁琐的操作。

因为 biblatex 标准样式和大量第三方样式的存在，定制往往是在这些样式基础上做的，一般不需要从零开始设计样式，而只要做一定修改和调整。biblatex提供了两种比较快速的方式，一是基于宏包选项的修改，二是基于一些简单内容的格式修改。如果这两种方式还不能满足要求，那么再考虑重新设计样式的问题。更复杂的样式设计问题详见第\label{seca:style:design}节。

\subsubsection{通过宏包选项改变样式}\label{sec:opt:def}
在给定样式基础上，可以使用宏包选项来定制一些需要的样式，比如作者输出数量、文献表排序、文献标注排序、文献数据项的输出等等，宏包选项的详细说明可以参见
\href{https://github.com/hushidong/biblatex-zh-cn/blob/master/biblatex-zh-cn.pdf}%
{biblatex 手册中文版}。

\paragraph{作者输出数量} 文献表和标注中的作者的数量可以通过宏包选项maxnames和minnames控制。两者也可以分开进行控制，分别利用maxbibnames，minbibnames和maxcitenames，mincitenames 进行控制。

\paragraph{文献表排序} 文献表排序可以使用sorting选项进行排序，有些样式中已经给出了sorting选项，如果用户想要另外的排序方式，那么可以自己选择合适sorting选项在biblatex宏包加载时给出。

\paragraph{标注排序} 当一个引用命令中有多个参考文献引用关键字时，可以利用sortcites选项来控制是否自动排序。当sortcites=false时不进行排序，按给出的顺序排列。当sortcites=true时，则按文献表的顺序排列。如果希望标注排序排序与文献表的排序不同，可以利用新文境 newrefcontext 来实现。比如: 希望文献表按nyt排，而标注用ynt排，可以采用如下方式:宏包加载时使用
\lstinline!\usepackage[backend=biber,style=gb7714-2015ay,sortcite,sorting=ynt]{biblatex}!，然后在文献打印前加
\lstinline!\newrefcontext[sorting=nyt]!

\paragraph{文献数据项的输出} 如果要取消url，doi，isbn等信息项的输出，可以设置相应的选项为false。

\paragraph{标注后面的标点控制} 在英文有时因为习惯问题会有标点的问题，比如句尾出现脚注的标签，需要把它放到句点后面。有时可能也需要把标注标签放到句点后面。这时需要用autopunct选项来扫描标注后面的标点。下面的例子给出了在句尾的脚注文献与标点的处理。

\begin{codetex}{autopunct选项与脚注之后句点处理}{eg:autopunct}
见文件：testautopunct.tex
\end{codetex}


\subsubsection{样式的临时定制}\label{sec:style:def}

biblatex可以实现简单快速的格式修改。biblatex 使用手册的Bibliography Style Files 一节给出了样式文件定义的一般模式和方法。依据该模式是容易实现样式快速定制的，因为在一般情况下定制/修改样式文件，其实并不需要处理太多的内容。

总结一下，简单的样式修改通常会包括:

\begin{enumerate}
  \item 加载定制所需的基础样式比如标准样式或其它样式；
  \item 设置宏包选项；
  \item 设置单元或块的标点；
  \item 设置域格式；
  \item 设置驱动格式；
\end{enumerate}

当然对于一些复杂的参考文献样式(比如gb7714-2015)还需要处理更多的内容,包括:
\begin{enumerate}
  \item 增加和应用需要的判断和功能函数；
  \item 增加一些域格式,增加修改应用本地化字符等；
  \item 动态数据处理；
  \item 增加宏包选项；
  \item 等等。
\end{enumerate}

而标注样式的定制则更为简单，主要处理内容包括:
\begin{enumerate}
  \item 加载定制所需的基础样式比如标准样式或其它样式；
  \item 设置宏包选项；
  \item 定义或重定义引用命令；
\end{enumerate}

这里以前述提到的ctex论坛上的提问为例进行讨论。该问题中参考文献著录格式主要需要修改的内容是分块、分块的标点、分块内容的格式。其中: 作者是一个块作为一行，标题是一个块作为一行，其它是一个块作为一行，那么把块标点设置为换行，就可以实现多行。同时各块的内容的字体不同，作者是粗体，标题是等宽，其它是斜体，那么把对应的块所构成域的格式改成需要的格式即可。这里给出该问题的一个简单解答，如图\ref{bib:style}所示。采用的样式文件代码如例\ref{bib:style:customize}所示，其中为了简化修改，把一些条目设置成了相同的格式。

\begin{figure}[!htb]
  \centering
  \fbox{\includegraphics*[scale=0.8,page=1]{egstylecustomize.pdf}}%viewport=0cm 1cm 20cm 19cm,clip=true,
  \caption{参考文献样式快速定制}\label{bib:style}
\end{figure}

\begin{codetex}{参考文献样式定制举例}{bib:style:customize}
\ProvidesFile{studf.bbx}[2016/12/07 v1.0e biblatex bibliography style]
略，详见源文件。
\end{codetex}
源代码见\href{run:./exampleandimage/studf.bbx}{studf.bbx}，
测试文件见\href{run:./exampleandimage/egstylecustomize.tex}{egstylecustomize.tex}。

如果对于中文参考文献需要一些特殊的处置，那么可以基于gb7714-2015进行修改，如例\ref{style:customize:gb}给出的代码。
其结果如图\ref{bib:style:gba}所示。 %，\ref{bib:style:gbb}
\begin{figure}[!htb]
  \centering
  \fbox{\includegraphics[scale=0.8,page=1]{egstylecustomizegb.pdf}}
  \caption{国标风格的参考文献样式快速定制A}\label{bib:style:gba}
\end{figure}

%\begin{figure}[!htb]
%  \centering
%  \fbox{\includegraphics[scale=0.8,page=2]{egstylecustomizegb.pdf}}
%  \caption{国标风格的参考文献样式快速定制B}\label{bib:style:gbb}
%\end{figure}

\begin{codetex}{参考文献样式定制举例-国标样式}{style:customize:gb}
\ProvidesFile{gbudf.bbx}[2016/12/07 v1.0e biblatex bibliography style]
略，详见源文件。
\end{codetex}

源代码见\href{run:./exampleandimage/gbudf.bbx}{gbudf.bbx}，
测试文件见
\href{run:./exampleandimage/egstylecustomizegb.tex}{egstylecustomizegb.tex}。

样式修改或定制中，是针对不同的内容，比如标点、标签、域格式、域顺序等等。不同的内容需要采用不同的方法，下面介绍一些常见内容的处理方法：

\subsubsection{分隔符/定界符环境}
分隔符/定界符其实就是常说的标点。分隔符 (定界符) 通常是全局定义的。也就是说，无论在哪里使用，打印的分隔符都是相同的。然而，如果想要在不同环境下中打印不同的符号，这些全局的分隔符就不可取了。 biblatex 在利用 newcommand 定义分隔符的常规方式基础上，还提供了更为智能的分隔符环境(context，可以是“标注文本内部”或者“参考文献项”等环境)，用以定义局部使用的分隔符。

biblatex使用DeclareDelimFormat命令定义不同分隔符环境中的分隔符，利用printdelim环境在不同的环境中打印不同的分隔符。biblatex 在不同位置自动创建了若干个默认的 context：包括：(1) none 文档开始处。(2) bib 以 printbibliography 开始的参考文献内部或者 usedriver 内部。(3) biblist 以 printbiblist 开始的参考文献列表内部。(4) ‘citecommand’ 使用 DeclareCiteCommand 定义的 citecommand 引用命令内部。也可以使用delimcontext命令手动设置分隔符文境。


\subsubsection{标签的格式和装饰}%封套/包围符号

标签的格式控制主要是通过域格式实现，比如：
\begin{codetex}{标签的格式控制}{eg:label:fmt}
\DeclareFieldFormat{labelnumberwidth}{\mkbibparens{#1}}
\DeclareFieldFormat{labelformat}{\mkbibbrackets{#1}}
\DeclareFieldFormat{labelnumber}{\mkbibitalic{#1}}
\end{codetex}

此外，还有labelalpha，extraalpha 等其它域的格式可以调整，更多的可以参考biblatex宏包的源代码。

标签的包围符号，一般是[]，但也可以其它的，有时可以全局的做修改，比如：
\begin{codetex}{标签的包围符号全局修改}{eg:label:wrappera}
\renewcommand*\bibleftbracket{(}
\renewcommand*\bibrightbracket{)\midsentence}
\end{codetex}

也可以用另一种方式做局部修改，比如在引用的地方修改，比如：
\begin{codetex}{标签的包围符号局部修改}{eg:label:wrapperb}
%利用()
\newrobustcmd*{\parentexttrack}[1]{%
  \begingroup
  \blx@blxinit
  \blx@setsfcodes
  \blx@bibopenparen#1\blx@bibcloseparen%
  \endgroup}

\AtEveryCite{%
  \let\parentext=\parentexttrack%
  \let\bibopenparen=\bibopenbracket
  \let\bibcloseparen=\bibclosebracket}

%利用[]
\newrobustcmd*{\parentexttrack}[1]{%
  \begingroup
  \blx@blxinit
  \blx@setsfcodes
  \blx@bibopenbracket#1\blx@bibclosebracket%
  \endgroup}

\AtEveryCite{%
  \let\parentext=\parentexttrack%
  \let\bibopenbracket=\bibopenparen%
  \let\bibclosebracket=\bibcloseparen}
\end{codetex}

\subsubsection{label类的域及其应用}%封套/包围符号

无论是在文献著录表中还是在引用标注中，常存在一个称为标签的东西。
比如顺序编码制的文献表中每一个条目前的数字标签，如[1]；
又比如作者年制的引用标注标签中作者名和年份，如(author 2001)。
这些都与biblatex中一种类型的域相关，就是label类型的域。

首先我们看两个label类的域：shorthand 和label。shorthand 域在标注样式中，用于替代常规标签的特殊标签。如果有定义，那么它会覆盖默认的标签。而label 域在标注样式中，如果生成常规标签的所需数据均缺失，那么该域的内容可用来代替常规标签。例如，当作者年制标注样式要生成某个条目的标签，但该条目的作者或年份缺失，那么会使用后备的label。shorthand 和 label 正好相反，label 只是作为后备而使用。基于这一认知，如果我们需要生成指定内容的标注标签，那么可以在bib文件中使用这两个域，当然这是作者年制的情形，对于顺序编码制生成的数字标签，并不会应用这两个域。

在顺序字母(alpha)制的标注样式中，标签默认由labelname列表抽取的首字母加上出版年的最后两个数字构成。而label域可用来重设它的非数字部分 (non-numericportion)。如果定义了label 域，biblatex 将使用它的值加上出版年的后两个数字生成labelalpha。而shorthand域也可用于重设整个标签。如果定义了该域，labelalpha就是shorthand域，而不是一个自动生成的标签。

当然上述逻辑并不是绝对的，这只是默认的样式设定的逻辑，对于顺序字母(alpha)制的标注标签，用户也可以通过\verb|\DeclareLabelalphaTemplate|命令修改前述逻辑。
而作者年制等\verb|\DeclareLabelname| 、\verb|\DeclareLabeldate|、\verb|\DeclareExtradate|、\verb|\DeclareLabeltitle| 等进行调整。

shortauthor、shorteditor、shortjournal、shortseries、shortitle等label类的域，也有一些类似的性质。当给出shortauthor、shorteditor时，默认的标注样式会在所有标注里使用短名称，比如：shortauthor而在参考文献表中打印全名，比如author。

而顺序编码标签使用的labelnumber域，是由biblatex自动赋值的。

在文献表中，处在不同分节的文献可以在标签前加上前缀(labelprefix)来区分。


\subsection{专题：筛选、缩略信息、排序、索引}

\subsubsection{文献分类筛选的不同方法}
除了前述的分章节打印外参考文献可以分类筛选打印，主要基于printbibliography命令的选项来实现。主要包括:
\begin{itemize}
  \item type
  \item nottype
  \item keyword
  \item notkeyword
  \item category
  \item notcategory
  \item filter
  \item check
\end{itemize}
其中category，filter，check是需要手动定义的。

type，nottype 分别表示打印是和不是某种条目类型的文献，keyword，notkeyword 分别表示打印 keywords 域中包含或不包含某一个关键词的文献，category，notcategory分别表示是或不是某一设定的 category 的文献，filter 表示属于某一设定筛选器的文献。使用时注意，category 必须要在导言区定义。check则是更底层的命令，常用在自定义的文献表中。

\subsubsection{筛选打印示例}

例\ref{eg:bib:filter}给出了这些选项的测试，分别利用type 和 keyword 区分了图书等文献，定义了 collections 和 standard 两个筛选器用于打印论文集会议录和标准文献，定义了名为 reportandthesis 的 category 用于打印学位论文和报告。
结果如图\ref{fig:eg:bibfilter}所示。
测试文档见：\href{run:exampleandimage/egbibfilter.tex}{egbibfilter.tex}

\begin{codetex}{分类筛选打印参考文献表}{eg:bib:filter}
%file:egbibfilter
\DeclareBibliographyCategory{reportandthesis}
\addtocategory{reportandthesis}{汤万金2013-09-30--,Calkin2011-8-9,吴云芳2003--,CALMS1965--}

\printbibliography[type=book,notkeyword=standard,title=【普通图书】]

\defbibfilter{collections}{%
type=collection
or type=proceedings
or type=incollection
or type=inproceedings
}
\printbibliography[filter=collections,title=【论文集、会议录】]

\defbibfilter{standard}{%
( type=book or type=inbook )
and keyword=standard
}
\printbibliography[filter=standard,title=【标准文献】]
\printbibliography[type=inbook,notkeyword=standard,title=【专著中析出的文献】]
\printbibliography[type=article,notkeyword=news,title=【期刊中析出的文献】]
\printbibliography[type=article,keyword=news,title=【报纸析出的文献】]
\printbibliography[category=reportandthesis,title=【报告和学位论文】]
\printbibliography[notcategory=reportandthesis,title=【非报告和学位论文】]
\end{codetex}

\begin{figure}[!htb]
  \centering
  \fbox{\includegraphics[width=0.8\textwidth,page=1]{egbibfilter.pdf}}
  \caption{文献表筛选打印}\label{fig:eg:bibfilter}
\end{figure}

例\ref{eg:bib:cgck}则展示了 category 和 check 筛选，见测试文件：
\href{run:exampleandimage/testfilterCategory.tex}{testfilterCategory.tex}，
\href{run:exampleandimage/testfilterCheck.tex}{testfilterCheck.tex}。

\begin{codetex}{category和check筛选}{eg:bib:cgck}
%category
\DeclareBibliographyCategory{kindsofnameformats}
\addtocategory{kindsofnameformats}{zhang2009china,xu2012role,wang2006another,
calvo2006phoenix,bernanke1989agency,adam2011house,fazzari1993working}

\printbibliography[category=kindsofnameformats,title=五种不同的姓名格式]
\printbibliography[notcategory=kindsofnameformats,title=某种期刊的姓名格式]

%check
\defbibcheck{uppercase}{%
\iffieldundef{nameformat}{}{\skipentry}}

\defbibcheck{lowercase}{%
\iffieldequalstr{nameformat}{lowercase}{}{\skipentry}}

\defbibcheck{givenahead}{%
\iffieldequalstr{nameformat}{givenahead}{}{\skipentry}}

\defbibcheck{familyahead}{%
\iffieldequalstr{nameformat}{familyahead}{}{\skipentry}}

\defbibcheck{pinyin}{%
\iffieldequalstr{nameformat}{pinyin}{}{\skipentry}}

\printbibliography[check=uppercase,title=国标风格-全大写]
\printbibliography[check=lowercase,title=国标风格-大小写不变]
\printbibliography[check=pinyin,title=中文常见风格-拼音]
\printbibliography[check=givenahead,title=biblatex标准风格-名在前]
\printbibliography[check=familyahead,title=biblatex标准风格-姓在前]
\end{codetex}

\subsubsection{筛选的多个文献表的顺序编码标签}

biblatex与标准的 LaTeX 不同，默认情况下，biblatex宏包生成的顺序编码标签在文档正文开始处就分配给文献表的全体文献。因此当有多个筛选文献表时可能会出现文献表中的顺序编码不连续的情况，这可以利用宏包的defernumbers选项解决。

但如果defernumbers选项被激活，各文献的顺序编码标签会在任意文献表中被打印时才会做第一次分配。

该选项需要在后端将数据导出到 bbl文件后再运行两次 LaTeX （除由分页变化等要求的编译外）。需注意的一个要点是，如果你在文档中改变了该选项值（或者那些依赖于本选项的选项值，例如与 printbibliography 宏相关的选项，，那么很可能需要删除当前的辅助文件然后重新运行 \LaTeX 来获得正确的顺序编码。需要记住 defernumbers 选项只与顺序编码标签有关，而与文献表中文献的排序无关。主要用于解决做文献筛选后顺序编码不连续的问题。如例\ref{eg:print:defernumber}所示：

\begin{codetex}{多个筛选文献表的顺序编码}{eg:print:defernumber}
略，详见testdefernumber.tex文档
\end{codetex}

文档为：
\href{run:exampleandimage/testdefernumber.tex}{testdefernumber.tex}


\subsubsection{文献缩略信息打印}

参考文献处理中有不同的缩略信息可以打印，比如整篇文献的缩略词或者说是代替常规标签的缩略标签(shorthand)，集体作者的缩写形式(shortauthor/shorteditor)，期刊名的缩写形式或其首字母缩略语(shortjournal)，series的缩写形式或其首字母缩略语(shortseries)，标题的缩略形式(shortitle)等。

这些信息可以通过printshorthands，printbiblist来输出。printshorthands一般用于存在shorthands域的情况。而printbiblist用于自定义输出信息的情况，可以使用short相关域也可以不使用。

例\ref{eg:print:biblist}给出了输出booktitle域信息的示例。其中要使用printbiblist输出自定义信息，必须要定义对应的驱动。而相应的过滤器，著录环境，排序格式，标题格式等可以定义或不定义。结果如图\ref{fig:eg:biblist}所示。

\begin{codetex}{论文集信息打印}{eg:print:biblist}
%见文件：egtestshort.tex
\end{codetex}

\begin{figure}[!htb]
  \centering
  \fbox{\includegraphics[width=0.7\textwidth,page=1]{egtestshort.pdf}}
  \caption{论文集信息打印}\label{fig:eg:biblist}
\end{figure}

例\ref{eg:print:biblista}给出了使用默认的short系列域的方式，主要输出title和journal域的信息。结果如图\ref{fig:eg:biblista}所示。

\begin{codetex}{标题和期刊信息打印}{eg:print:biblista}
%见文件：egtestshorta.tex
\end{codetex}

\begin{figure}[!htb]
  \centering
  \fbox{\includegraphics[width=0.7\textwidth,page=1]{egtestshorta.pdf}}
  \caption{标题和期刊信息打印}\label{fig:eg:biblista}
\end{figure}

例\ref{eg:print:biblistb}给出了在一个表中同时输出shorthand和shortseries的方式，主要输出title和journal域的信息。结果如图\ref{fig:eg:biblistb}所示。

\begin{codetex}{不同缩略信息在一个表中打印}{eg:print:biblistb}
%见文件：egtestshortb.tex
\end{codetex}

\begin{figure}[!htb]
  \centering
  \fbox{\includegraphics[width=0.7\textwidth,page=1]{egtestshortb.pdf}}
  \caption{不同缩略信息在一个表中打印}\label{fig:eg:biblistb}
\end{figure}

\subsubsection{在标注和文献表中使用缩略信息}

上一小节，讨论的时把缩略信息作为一个单独的部分来输出以强调这些内容。但有的时候可能需要在文献表或标注中使用缩略信息，而这又是另一个概念了。

latex中的参考文献信息由bib文件提供，因此除非管理bib文件的软件有增加缩略信息域的功能，否则就需要手动的在bib文件中输入，比如有 title=\{world health oganization\}，那么要使用缩略信息，就要输入，shorttitle=\{WHO\}。

如果我们要在文献表中使用缩略信息，有两种主要的方法：

一是重定义使用相应信息的宏，比如\verb|\renewbibmacro*{journal}|，可以将其中的journaltitle域替换为shortjournal域。

二是使用域信息的存储和恢复，比如：
\begin{codetex}{域信息替换方法}{eg:field:save}
\savefield{shortjournal}{\temptitle}%
\restorefield{journaltitle}{\temptitle}%
\end{codetex}

如果要在不同的位置比如在标注中，或者在文献表中使用，那么利用biblatex的局部编组特性，可以利用钩子AtEveryCitekey等方式来实现。看下面一个具体的例子，结果如图\ref{fig:eg:biblistc}所示。

\begin{codetex}{在标注和著录表中使用缩略信息}{eg:print:biblistc}
%见文件：egtestshortc.tex
\end{codetex}

\begin{figure}[!htb]
  \centering
  \fbox{\includegraphics[width=0.7\textwidth,page=1]{egtestshortc.pdf}}
  \caption{不同缩略信息在一个表中打印}\label{fig:eg:biblistc}
\end{figure}

\subsubsection{文献信息的动态/静态替换}\label{sec:info:replace}

上一节使用缩略信息的方法中，我们首先要给出缩略信息，使用和输入这一信息，还有一些方便的工具和方法，比如使用信息的动态/静态修改/替换。

信息(除了域信息也包括条目信息)的处理包括替换方法，除了前一节介绍的savefield/restorefield外还包括：crossref、xref、xdata、\verb|@string|、sourcemap等，共6种方法。下面进行一一介绍：

crossref 域用于指定要继承的父对象，当比如在一个 inbook 条目中给出一个 crossref 域指定一个book条目，那么该 inbook 条目就会从该 book 条目继承bookauthor，booktitle信息。而 xref 域用于指定条目的父子关系，当指定父对象的次数超过一定的阀值时，父条目会被加入到文献表中，这是一种条目处理方式。当然crossref 域指定的父对象也有根据阀值加入文献表的特性。使用方法可以参考手册第2.4.1节，继承的规则和机制也可以自定义，参考手册第4.5.11节。

xdata 是一种条目类型，作为数据容器用，该类型定义的条目的可以被继承。利用 xdata 类型定义一个条目，其中包含要被继承的信息，然后在需要这些信息的条目中加入域 xdata，指定需要的xdata条目的关键词，就可以将信息继承过来。而且条目中的xdata 域支持分隔值列表，因此可以从多个条目继承信息。具体方法参考手册第3.13.6节。

\verb|@string|方法是与 xdata 域有点类似的方法。%，它是传统的bibtex的方法。
在bib文件中定义一个\verb|@string|，其内容包括一个字符串标签和字符串内容。
在其它文献条目中可以把域指定为该字符串标签，用来继承该字符串内容。例\ref{eg:data:string}给出了一个例子。更多的内容详见Paul Stanley的教程
\href{https://github.com/hushidong/biblatex-tutorial-cn}{（pdf文档）}。

\begin{codetex}{string方法继承数据}{eg:data:string}
@string{NYULSQ="NYUniversityLegalStudiesQ"}
@Article{art1,
title = {article title},
journaltitle= NYULSQ,
date = {1971},
number = {36},
pages = {8--9},
}
\end{codetex}

最后一个是最重要，最常用，最强大的sourcemap，即biber的动态数据修改。biblatex 提供了4个层次的数据动态修改，常用的是用户层、样式层、驱动层这三层的sourcemap。sourcemap主要包括如下功能及其组合：

\begin{itemize}
  \item 将数据源条目类型映射为其它类型
  \item 将数据源域映射为其它域
  \item 给条目添加新域
  \item 从条目移除域
  \item 用标准的Perl正则表达式匹配和替换，修改域的内容。
  \item 将上述操作限制在来自特定数据源的条目
  \item 将上述操作限制在某些条目类型。
  \item 将上述操作限制在某一特定的参考文献节。
\end{itemize}

根据这些功能描述，就可以知道对于bib文件中域的信息处理，对于sourcemap来说只是很自然的一件事情。例\ref{eg:data:map}给出了将期刊名用其缩略信息来代替的三种操作方式。其中第一种和第二种本质是一样的，就是将journaltitle设置为shortjournal的内容，只是写法不同。第三种操作，则做了匹配和替换，当匹配特定的目标时，才做替换。关于sourcemap的更多内容详见biblatex手册，第4.5.3节。

\begin{codetex}{sourcemap处理域信息}{eg:data:map}
\DeclareSourcemap{
  \maps[datatype=bibtex]{
    \map[overwrite]{ % Notice the overwrite: replace one field with another
      \step[fieldsource=shortjournal,fieldtarget=journaltitle]
    }
  }
}

\DeclareSourcemap{%
  \maps[datatype=bibtex]{
    % Journal abbreviations
    \map[overwrite]{
      \step[fieldsource=shortjournal]
      \step[fieldset=journaltitle,origfieldval]
    }
  }
}

\DeclareSourcemap{%
  \maps[datatype=bibtex]{
    % Journal abbreviations
    \map{
      \step[fieldsource=journaltitle, match={Physics Letters A},
      replace={Phys. Lett. A}]%
    }
  }
}
\end{codetex}

\subsubsection{文献表和标注的排序}\label{sec:sort:bibandcite}

排序涉及到两个方面的内容，一是文献表中的排序，二是标注的排序。其中标注的排序通常是在同一位置标注多个标签时，这种情况往往是多个引用关键字（词）传递给一个标注（引用）命令。一般情况下标注是不进行排序的，而是以引用时给出的顺序进行排序，当需要进行标签排序时需要启用sortcites选项，这时biblatex会按照当前文献表中的顺序对标注标签进行排序。

而文献表中的文献排序由sorting选项控制，常见的值包括：

\begin{description}
\item[nty] %Sort by name, title, year.
按照姓名、标题、年份排序。
\item[nyt] %Sort by name, year, title.
按照姓名、年份、标题排序。
\item[nyvt] %Sort by name, year, volume, title.
按照姓名、年份、卷数、标题排序。
\item[anyt] %Sort by alphabetic label, name, year, title.
按照字母标签、姓名、年份、标题排序。
\item[anyvt] %Sort by alphabetic label, name, year, volume, title.
按照字母标签、姓名、年份、卷数、标题排序。
\item[ynt] %Sort by year, name, title.
按照年份、姓名、标题排序。
\item[ydnt] %Sort by year (descending), name, title.
按照年份（降序）、姓名、标题排序。
\item[none] %Do not sort at all. All entries are processed in citation order.
不进行排序。所有的条目按照引用顺序处理。
\item[debug] %Sort by entry key. This is intended for debugging only.
按照条目键值排列。该选项只用于程序调试。
\item[name] %Use \prm{name}, as defined with \cmd{DeclareSortingTemplate} (\secref{aut:ctm:srt})
使用由 \verb|DeclareSortingTemplate|定义的排序模板名 name。
\end{description}
注意：除非另加说明，文献条目总是按升序排列。

通常情况下，在选择使用某种样式时，文献表的排序方式就已经设定。当需要调整排序时，就需要在加载biblatex宏包时显式地给出sorting选项，并可根据需要选择上述给出的选项值。

另外，因为biber能充分利用perl的一些模块的功能，所以biblatex还能根据Unicode::Collation::locale模块提供不同语言的排序的本地化调整方案。对于中文，默认的排序规则是按照中文字符的unicode编码进行排序，但可以通过设置选项来进行调整，对于中文有如下调整方案：zh，zh\_\_pinyin，zh\_\_big5han，zh\_\_gb2312han，zh\_\_stroke，zh\_\_zhuyin。

一般的，biblatex利用sortlocale选项将调整方案名传递给biber，biber利用 Unicode::Collation::locale 模块提供对应的排序。因此biblatex可以设置选项为：
  \begin{itemize}
    \item \verb|sortlocale=auto| 或者不设置该选项，为默认的unicode编码顺序
    \item \verb|sortlocale=zh|，为unicode编码顺序
    \item \verb|sortlocale=zh__pinyin|，为拼音顺序
    \item \verb|sortlocale=zh__big5han|，为big5 编码顺序
    \item \verb|sortlocale=zh__gb2312han|，为GB-2312 顺序
    \item \verb|sortlocale=zh__stroke|，为笔划数顺序
    \item \verb|sortlocale=zh__zhuyin|，为注音顺序
  \end{itemize}
中文排序本地化调整的测试文档见
\href{run:exampleandimage/testlocale.tex}{testlocale.tex}

当然这种调整可以直接利用在biber编译时设置相应的选项来实现，比如需要按拼音或字顺进行排序时，可使用biber选项，此时biblatex不需要设置sortlocale选项。

\begin{codetex}{中文文献排序时的biber选项}{eg:sort:bibercmd}
%按拼音排序，biber命令
biber -l zh__pinyin jobname
%按笔画排序，biber命令
biber -l zh__stroke jobname
\end{codetex}

一个简单的中文作者排序示例见\href{https://github.com/hushidong/biblatex-gb7714-2015/wiki}{(八)如何对文献表中的参考文献进行排序？}

有的时候，可能希望标注标签的排序和文献表中的顺序不同，操作方法，可以参考
\href{https://github.com/hushidong/biblatex-gb7714-2015/issues/30}{citation的顺序和bibliography的顺序如何不关联}。其中使用了biblatex宏包提供参考文献文境的概念，即不同的文境下可以使用不同的排序方式。

\subsubsection{排序模板和排序的手动调整}

前述的排序选项nyt等等，都是DeclareSortingTemplate定义的排序模板。在排序模板的定义过程中 biblatex 通常是这么考虑的：

首先要考虑的事项总是条目的 presort 域。如果该域没有定义，biblatex 会使用缺省值“mm”作为预排序字符串。

其次考虑的是 sortkey 域。如果该域有定义，它将作为主要的排序关键字。此时除了 presort 域，将不考虑其它信息。如果 sortkey 域没有定义，排序将使用姓名信息。本宏包将依次尝试使用 sortname 、author 、 editor 和 translator 等域。考虑哪些域也取决于 useauthor 、 useeditor 和 usetranslator 选项的设置。如果这三个选项都没有启用，那么 sortname 也将被忽略。请注意，所有的名称域都与 maxnames 和 minnames 有关。

如果没有名称域是合适的，或者由于它们没有定义、或者由于 use<name> 域都未启用，那么 biblatex 将采用 sorttitle 和 title 作为最后的备选。

余下考虑的诸项依次是： sortyear 域（如果给出的话），否则考虑 year 域的前四个数字； sorttitle 域（如果给出的话），否则考虑 title 域； volume 域。

上面的这些说明并不全面，只是biblatex在定义类似nty排序模板时的考虑，定义其它模板可能还有其它考虑，比如 labelalpha，extraalpha等，但我们可以得出到一个结论就是biblatex通常选择排序内容的时候首先会考虑该部分内的sort相关的域。比如排序作者时首先考虑sortname，而不是author，排序标题时，首先考虑sorttitle，而不是title。因此我们如果需要对某种排序做调整，那么就可以手动的调整sort相关的域，即再bib文件中增加这些域并设置合适的信息用于排序。这些域包括：presort，sortkey，sortname，sorttitle，sortyear，sortdate等。
需要注意的是，因为对bibtex格式的兼容性，biblatex也支持域key，该域等价于biblatex中sortkey域，所以当文献信息中出现key域时，表示要对这些文献进行排序设定。

\subsubsection{文献信息索引}

当需要对参考文献的信息进行索引时，可以使用indexing选项。启用indexing后，biblatex的标准样式默认会将作者和题名加入到索引中去，如果需要增加一些信息的索引则需要对样式文件做修改。另外，要生成索引还需要使用索引相关的宏包，如makeidx。宏包加载如例\ref{eg:print:index}所示：

\begin{codetex}{文献信息索引}{eg:print:index}
见文件 testindexofbib.tex
\end{codetex}







\subsection{专题：多语言文献}

\subsubsection{多语言混合文献表}

一般情况中，在国内不太会超过两种语言混合的情况，比如中英文混合的情况。但有时可能也会存在多种语言，比如存在中/英/日/俄这种多语言环境。图\ref{fig:multi:lan}给出了这样一个示例，其中不同的语言使用了不同的本地化字符串。

\begin{figure}[!htb]
\centering
\parbox{0.8\linewidth}{
\includegraphics{egmultilan.pdf}
}
\caption{多语言混合文献表}\label{fig:multi:lan}
\end{figure}

使用xelatex编译时下，由于其原生支持unicode的特性，在tex文档内实现多语言混合比较容易实现，要正确显示关键在于合适的字体设置。一般情况下中/日/韩语利用ctex宏包可以解决。而西文如英/法/俄可以利用fontspec宏包选择合适的字体来解决。

对于参考文献来说还有一个更重要的问题是本地化字符串问题。中英文情况下，中文利用在英文本地化文件基础上新增本地化字符串加以解决。但其它语言需要自己的解决方案。

中文环境下的用户，可以使用language域来区分文献的语言类型，默认情况下该域不需要人工输入，可由biber根据文献信息自动判断，但也可以手动输入来人工指定。根据 biblatex 提供的多语言解决方案，还需要利用langid/langidopt域，以及babel/polyglossia宏包的支持。

解决方案做如下的考虑：
\begin{enumerate}
  \item 日韩语采用类似中文的方式处理，即通过在英语本地化文件基础上处理。因此langid通常设为english。对于日文通常作者这种信息都是用的汉字，因此用中文的字符串。韩语暂没有考虑它自身的字符串，而使用英文的字符串。当不存在除英文外的其它西语时，langid也不需要处理。注意：默认情况下 langid 都是自动处理的，用户无需过多关注。
  \item 如俄语/法语这样的西方语言，通过biblatex提供的方案解决。即：使用babel/polyglossia宏包和langid/langidopt域。这时如果存在中日韩语，那么相应文献也需要设置langid。因此，需要在tex文档内加入babel宏包以及需要使用的语言，需要使用本地化字符串的西语都要加入，否则无法自动切换。然后在加载biblatex宏包时使用 autolang=other 选项。
\end{enumerate}




\subsubsection{多语言对照的文献表}\label{sec:multilan:implement}

某些期刊对于参考文献表有双语文献对照的要求，具体要求见GB/T 7714-2015第6.1节。这一问题可以通过条目集类型(set)/或者条目关联(related)来解决，多语言对照的情况与双语言对照本质是一样的，因此下面主要讨论双语对照的文献表。


\paragraph{利用条目集类型满足双语文献要求}

设置条目集类型(set)有静态和动态两种方法:
动态方法使用更为方便，在写文档时候，直接利用defbibentryset设置双语文献的set，然后引用set的bibtex键。比如:
\begin{codetex}{设置set条目集用于双语文献动态方法}{eg:setforbilangentry}
\defbibentryset{bilangyi2013}{易仕和2013--,Yi2013--}
专著，双语文献引用\cite{bilangyi2013}
\end{codetex}

动态方法的使用更方便，直接在写文档时候，将双语文献设置成set，然后引用set的bibtex键。比如:

\begin{codetex}{设置set条目集用于双语文献动态方法}{eg:setforbilangentry}
%file:egbilang.tex
\documentclass{report}
\usepackage{ctex}
\usepackage{geometry}
\geometry{paperwidth=15cm,paperheight=9.5cm,top=0cm, bottom=1.5cm, left=1cm,right=1cm}
\usepackage{titlesec}
\titleformat{\chapter}{\zihao{5}\heiti}{\thechapter}{1em}{}
\titlespacing*{\chapter}{0pt}{0.0\baselineskip}{0.0\baselineskip}[0pt]
\titleformat{\section}{\zihao{-5}\heiti}{\thesection}{1em}{}
\titlespacing*{\section}{0pt}{0.0\baselineskip}{0.0\baselineskip}[0pt]
\usepackage[backend=biber,style=gb7714-2015]{biblatex}
\addbibresource[location=local]{example.bib}

\begin{document}
\chapter{序章}
序章内容\cite{GPS1988--}
\defbibentryset{bilangyi2013}{易仕和2013--,Yi2013--}
\defbibentryset{bilangzhang2007}{张敏莉2007-500-503,Zhang2007-500-503}
专著，双语文献引用\cite{bilangyi2013}\cite{bilangzhang2007}
\printbibliography[heading=subbibliography,title=参考文献]
\end{document}
\end{codetex}

得到的参考文献打印结果如图\ref{bib:eg:bilang}所示。

\begin{figure}[!htb]
  \centering
  \fbox{\includegraphics[width=\figwd\textwidth,page=1]{egbilang.pdf}}
  \caption{双语文献参考文献}\label{bib:eg:bilang}
\end{figure}

\bc{在biblatex v3.8及以上版本中，因为set条目类型除了子条目关键词信息外，并无其他信息，因此它的标注标签通常会是空的，这与biblatex版本升级有关，biblatex v3.7及之前版本没有这个问题，因为这些版本中 set 中带有第一个子条目的信息。目前该问题的解决方法是设置一个指定格式和内容中间无空格无英文逗号的关键字，用它来作为标签。}。比如:

\begin{codetex}{设置set条目集用于双语文献动态方法}{eg:setforbilangentry}
\defbibentryset{易仕和，等，2013}{易仕和2013--,Yi2013--}
专著，双语文献引用\cite{易仕和，等，2013}
\end{codetex}

\qd{注意到“易仕和，等，2013”中的逗号是中文全角逗号，这样使得“易仕和，等，2013”以一个整体字符串当作关键字，而不会被分开解析。但是这种解决方案中的中文全角逗号与其它标签的英文逗号的差异使得该问题并没有完美解决。这可以用静态方法手动添加标签来解决，对于biblatex v3.8及以上版本还可以利用后面介绍的关联(related)方法来解决。}

静态方法是在bib源文件中给出条目集(set)并使用biber后端进行解析，条目的域信息采用如下方法定义:
%当使用bibtex后端时，则需要进一步设置，具体参考biblatex宏包说明文档。
\begin{codetex}{设置set条目集用于双语文献静态方法}{eg:set:static}
@Set{set1,
entryset = {key1,key2,key3},
}
%如果要达到上例动态设置set一样的结果，在bib文件中静态设置set条目如下:
@Set{bilangyi2013,
entryset = {易仕和2013--,Yi2013--},
}
\end{codetex}

\qd{使用静态条目集时，如果仅采用上述这般简单设置，中文排序会出现问题，条目集会出现在文献表末尾，这是因为条目集没有设置language域用于排序，而通常的条目都会利用动态数据修改设置language域，在biber运行中因为要解析文献集，所以无法对language域进行处理。

但使用动态条目集方法没有这一问题，因为其解析过程直接会利用第一个子条目的排序信息。静态方法的这个问题可以在set条目中手动设置language域来修正。此外，对于v3.8以上版本的biblatex，无论动态方法还是静态方法，条目集不复制第一个子条目信息，因此引用时也无法生成标注标签，这就是前面介绍动态方法时讨论过的问题，该问题也可以通过在set条目中手动设置label域来解决。}

设置方法为:

\begin{codetex}{在bib文件中正确设置set条目集的静态方法}{eg:set:staticright}
%在bib文件中静态设置set条目如下，其中:
%手动设置userb域用于解决排序问题
%手动设置label域用于解决标注标签问题
@Set{bilangyi2013,
entryset = {易仕和2013--,Yi2013--},
label={易仕和, 等, 2013},
language={chinese}
}
\end{codetex}

\bc{还要注意：动态set条目集等价于使用nocite命令，因此只要定义了动态条目集的文献都会出现在文献表中，因此如果不引用相应的文献，那么就不应该对其定义动态条目集}。

\paragraph{利用条目关联满足双语文献要求}

除上述给出的条目集方案外，关联条目方法则是另一种可行方案，该方案的讨论可以见“Again about the \@ set label for authoryear style”\footnote{\url{https://github.com/plk/biblatex/issues/681}}。该方案同样也有静态和动态两种方法，静态就是修改bib文件内容，动态则是在tex源文档中做设置。

静态方法很简单，bib文件中条目设置如例\ref{eg:related:staticright}所示，它能解决双语同时显示的问题，也能解决排序和标注标签问题，唯一的问题在于修改了bib文件后当不需要双语文献时，它还需要改回来，这会带来不便，因此可以考虑下面的动态方法，但要注意动态方法需要利用多个DeclareStyleSourcemap，因此该方法只适用于biblatex v3.7及以上版本。

\begin{codetex}{在bib文件中正确设置关联条目的静态方法}{eg:related:staticright}
%在bib文件中静态设置条目如下，其中:
%易仕和2013--条目中增加了related域用于关联其对应的英文条目Yi2013--
@Book{易仕和2013--,
  Title                    = {超声速和高超声速喷管设计},
  Address                  = {北京},
  Author                   = {易仕和 and 赵玉新 and 何霖 and 张敏莉},
  Publisher                = {国防工业出版社},
  Year                     = {2013}
  related                  = {Yi2013--}
}
@Book{Yi2013--,
  Title                    = {Supersonic and hypersonic nozzle design},
  Address                  = {BeiJing},
  Author                   = {Yi, S H and Zhao, Y X and He, L and Zhang, M L},
  Publisher                = {National Defense Industry Press},
  Year                     = {2013}
}
\end{codetex}

动态方法利用动态数据修改自动添加related域，避免对bib文件做直接修改。本样式中对该过程进行了封装，定义一个新的命令defdoublelangentry，例如:
\begin{codetex}{设置关联条目的动态方法}{eg:related:dynamic}
\defdoublelangentry{易仕和2013--}{Yi2013--}
\end{codetex}


使用该命令后，可以引用主条目“易仕和2013--”生成双语文献。但要注意由于DeclareStyleSourcemap命令只能在导言区中使用，因此defdoublelangentry命令也只能出现在导言区中，这也是相比条目集动态方法的唯一遗憾。

双语对照文献的两种动态方法基于set和related的方法测试，参见:
\href{https://github.com/hushidong/biblatex-gb7714-2015/blob/master/biblatex-gb7714-2015.pdf}%
{biblatex-gb7714-2015宏包手册}。




\subsubsection{关联与条目集的差异}

在biblatex中不同的文献之间产生一定的联系的方式共有三种，分别是交叉引用、关联、集合。其中交叉引用使用crossref，详见\ref{sec:info:replace}节，这是传统的bibtex使用的方式，主要用于数据的继承。而关联(related)和条目集合(set)是则是两种不同条目信息集合输出的方式。

关联主要是要体现出不同条目之间的关系，比如“再版”，“原版”，“重印”，“多卷”，“摘录于”等等。biblatex 通过使用条目域 related 、 relatedtype 和 relatedstring
来实现这种一般性的机制，通过related域来关联不同的条目，通过relatedtype制定关联条目间的关系的本地化字符串名，比如：reprintof等。而relatedstring 域可以用于覆盖那些通过 relatedtype 确定的本地化字符串，此时 relatedtype 域给出的信息用于确定该字符串的格式。biblatex 关联条目的例子详见biblatex附带的90-related-entries-biber.pdf 。biblatex 还提供 relatedoptions 域用于设置一些选项，选择值有dataonly，skiplab，skipbib，skipbiblist等，设置该选项的目标主要是为了使用默认dataonly选项所没有的功能，该域一般情况下不常用，使用时遇到问题可以在github咨询biblatex的开发和维护者。


而条目集是用单个引用并在参考文献中作为一项列出的一组条目，主要的概念是多个条目集合为一个分组并输出。它在条目输出上与关联是类似的，差别在于条目间没有更明确的关系存在。如前所述，条目集可以有两种手动构成方式，一种静态，一种动态。除此之外还有一种更方便的使用方式就是利用mcite命令，该命令会自动构造动态条目集。mcite类的命令指示对cite等命令的封装，因此可以有mcite，Mcite，mparencite，Mparencite，mfootcite，mfootcitetext，mtextcite，Mtextcite
，msupercite等命令。其原理如例所示：

\begin{codetex}{设置set动态条目集的mcite方法}{eg:set:mcite}
\mcite*[pre][post]{setA,*keyA1,*keyA2,*keyA3}

%等价于执行

\defbibentryset{setA}{keyA1,keyA2,keyA3}%
\cite*[pre][post]{setA}
\end{codetex}

当然要注意，要使用mcite类命令，要在加载biblatex时启用mcite模块选项。

需要注意的是条目集在有标签的文献样式中使用更为合适，比如numeric，alpha类样式，而在以文献信息本身作为文献不同区分的样式中并不常用，当然这是西方用户的习惯。中文环境内因为很多时候有双语对照的需求，那么再不适合也要用。当然对于多语言对照的情况，在使用较新版本的biblatex时，更推荐使用关联的方法。


\subsection{专题：脚注题注等环境中的引用和文献表}

文献不仅可以在正文中引用，也可以在脚注，题注，小页环境中引用，下面分别进行说明:

\subsubsection{脚注中的引用}

要在脚注中的引用文献，直接在footnote脚注的内容中添加cite等引用命令即可，比如:

\begin{codetex}{脚注中引用参考文献}{cite:infoot}
%file:egciteinfoot.tex
\documentclass{report}
\usepackage{ctex}
\usepackage{geometry}
\geometry{paperwidth=12cm,paperheight=8cm,top=0cm, bottom=1.5cm, left=1cm,right=1cm}
\usepackage{hyperref}
\usepackage{titlesec}
\titleformat{\chapter}{\zihao{5}\heiti}{\thechapter}{1em}{}
\titlespacing*{\chapter}{0pt}{0.5\baselineskip}{0.5\baselineskip}[0pt]
\titleformat{\section}{\zihao{-5}\heiti}{\thesection}{1em}{}
\titlespacing*{\section}{0pt}{0.5\baselineskip}{0.5\baselineskip}[0pt]
\usepackage[backend=biber,style=gb7714-2015]{biblatex}
\addbibresource[location=local]{example.bib}

\begin{document}
\chapter{序章}
正文内容脚注中引用参考文献\footnote{biblatex使用可以参考宏包手册\cite{Lehman2015}}
\printbibliography[heading=subbibliography,title=本章参考文献]
\end{document}
\end{codetex}

结果如图\ref{fig:eg:citeinfoot}所示。

\begin{figure}[!htb]
  \centering
  \fbox{\includegraphics[width=\figwd\textwidth,page=1]{egciteinfoot.pdf}}
  \caption{脚注中引用参考文献}\label{fig:eg:citeinfoot}
\end{figure}

\subsubsection{题注中的引用}

在题注中引用文献方法是类似的，直接在caption题注的内容中添加cite等引用命令即可，比如:

\begin{codetex}{题注中引用参考文献}{eg:cite:incaption}
%file:egciteincaption.tex
\documentclass{report}
\usepackage{ctex}
\usepackage{geometry}
\geometry{paperwidth=12cm,paperheight=9cm,top=0cm, bottom=1.5cm, left=1cm,right=1cm}
\usepackage{titlesec}
\titleformat{\chapter}{\zihao{5}\heiti}{\thechapter}{1em}{}
\titlespacing*{\chapter}{0pt}{0.5\baselineskip}{0.5\baselineskip}[0pt]
\titleformat{\section}{\zihao{-5}\heiti}{\thesection}{1em}{}
\titlespacing*{\section}{0pt}{0.5\baselineskip}{0.5\baselineskip}[0pt]
\usepackage{hyperref}
\usepackage[backend=biber,style=gb7714-2015]{biblatex}
\addbibresource[location=local]{example.bib}

\begin{document}
\chapter{序章}
\begin{figure}[!htb]
  \centering
  \fbox{\parbox[c][2cm][c]{4cm}{\centering\large example figure}}
  \caption{在题注中引用文献\cite{GPS1988--}}\label{cite:incaption}
\end{figure}
\printbibliography[heading=subbibliography,title=本章参考文献]
\end{document}
\end{codetex}

结果如图\ref{fig:eg:citeincaption}所示。

\begin{figure}[!htb]
  \centering
  \fbox{\includegraphics[width=\figwd\textwidth,page=1]{egciteincaption.pdf}}
  \caption{题注中引用参考文献}\label{fig:eg:citeincaption}
\end{figure}

\subsubsection{小页环境中的引用}
在小页环境中引用文献方法也是类似的，直接在小页环境的内容中添加cite等引用命令即可，比如:

\begin{codetex}{小页环境中引用参考文献}{eg:cite:inminipage}
%file:egciteinminipage.tex
\documentclass{report}
\usepackage{ctex}
\usepackage{geometry}
\geometry{paperwidth=12cm,paperheight=6cm,top=0cm, bottom=1.5cm, left=1cm,right=1cm}
\usepackage{titlesec}
\titleformat{\chapter}{\zihao{5}\heiti}{\thechapter}{1em}{}
\titlespacing*{\chapter}{0pt}{0.5\baselineskip}{0.5\baselineskip}[0pt]
\titleformat{\section}{\zihao{-5}\heiti}{\thesection}{1em}{}
\titlespacing*{\section}{0pt}{0.5\baselineskip}{0.5\baselineskip}[0pt]
\usepackage{hyperref}
\usepackage[backend=biber,style=gb7714-2015]{biblatex}
\addbibresource[location=local]{example.bib}

\begin{document}
\chapter{序章}
\fbox{
\begin{minipage}{0.5\linewidth}\centering
使用小页环境引用文献\cite{GPS1988--}
\end{minipage}}
\printbibliography[heading=subbibliography,title=本章参考文献]
\end{document}
\end{codetex}

结果如图\ref{fig:eg:citeinminipage}所示。

\begin{figure}[!htb]
  \centering
  \fbox{\includegraphics[width=\figwd\textwidth,page=1]{egciteinminipage.pdf}}
  \caption{小页环境中引用参考文献}\label{fig:eg:citeinminipage}
\end{figure}


\subsubsection{使用biblatex命令实现脚注文献表}

前面说过，biblatex可以访问和利用参考文献源文件中的任何数据。其中，就可以利用这一特点形成一个相关功能即: 将参考文献表放到脚注中，这在某些需要的时候是很有用的。

biblatex提供了一个footfullcite命令实现将文献表放到脚注中，看例\ref{eg:bib:infoot}给出的代码，3个footfullcite命令将3条文献放入脚注中，文献的著录格式仍然是指定的gb7714-2015ay样式。
\begin{codetex}{脚注参考文献表}{eg:bib:infoot}
%file:egbibinfoot.tex
\documentclass{article}
\usepackage{ctex}
\usepackage[paperwidth=12cm,paperheight=9cm,%
left=1cm,right=1cm,top=1cm,bottom=1.5cm]{geometry}
\usepackage[colorlinks=true,pdfstartview=FitH,linkcolor=blue,
anchorcolor=violet,citecolor=magenta]{hyperref}%书签功能，选项去掉链接红色方框
\usepackage{titleref}%标题引用
\usepackage[backend=biber,style=gb7714-2015ay]{biblatex}
\renewcommand{\bibfont}{\zihao{6}}
\addbibresource[location=local]{example.bib}

\begin{document}
\section{页边的文献表}
参考文献\cite{白书农1998-146-163}
\footfullcite{陈志勇2011--}
\footfullcite{储大同2010-721-724}
\footfullcite{顾炎武1982--}
中文段落参考文献中文段落参考文献中文段落参考文献中文段落参考文献中文段落
参考文献中文段落参考文献中文段落参考文献中文段落参考文献中文段落参考文献
中文段落参考文献中文段落参考文献中文段落参考
\printbibliography[title=【全部引文】]
\end{document}
\end{codetex}

结果如图\ref{fig:eg:bibinfoot}所示。

\begin{figure}[!htb]
  \centering
  \fbox{\includegraphics[width=\figwd\textwidth,page=1]{egbibinfoot.pdf}}
  \caption{脚注中的参考文献表}\label{fig:eg:bibinfoot}
\end{figure}


\subsubsection{使用biblatex命令和footmisc实现旁注文献表}

旁注文献表可以在脚注文献表的基础上，利用footmisc宏包实现。footmisc的side选项可以将脚注移到页边中，这样脚注参考文献表就变成了旁注参考文献表。例\ref{eg:bib:inmargin}给出测试代码。

\begin{codetex}{旁注参考文献表}{eg:bib:inmargin}
%file:egbibinmargin.tex
\documentclass{article}
\usepackage{ctex}
\usepackage[includemp,paperwidth=12cm,paperheight=9cm,%
left=1cm,right=1cm,marginparwidth=5cm,top=1cm,bottom=1.5cm]{geometry}
\usepackage[colorlinks=true,pdfstartview=FitH,linkcolor=blue,
anchorcolor=violet,citecolor=magenta]{hyperref}%书签功能，选项去掉链接红色方框
\usepackage{titleref}%标题引用
\usepackage[backend=biber,style=gb7714-2015ay]{biblatex}
\renewcommand{\bibfont}{\zihao{6}}
\addbibresource[location=local]{example.bib}
\usepackage[%
%   bottom,      % Footnotes appear always on bottom. This is necessary
%                % especially when floats are used
%   stable,      % Make footnotes stable in section titles
   perpage,     % Reset on each page
%   %para,       % Place footnotes side by side of in one paragraph.
   side,       % Place footnotes in the margin
%   ragged,      % Use RaggedRight
%   marginal,
%   norule,     % suppress rule above footnotes
%   %hang,
%   multiple,    % rearrange multiple footnotes intelligent in the text.
%   %symbol,     % use symbols instead of numbers
]{footmisc}

\begin{document}

\section{页边的文献表}
参考文献\cite{白书农1998-146-163}
\footfullcite{陈志勇2011--}
\footfullcite{储大同2010-721-724}
\footfullcite{顾炎武1982--}
中文段落参考文献中文段落参考文献中文段落参考文献中文段落参考文献中文段落
参考文献中文段落参考文献中文段落参考文献中文段落参考文献中文段落参考文献
中文段落参考文献中文段落参考文献中文段落参考

\newpage
\newgeometry{left=1cm,right=1cm,top=1cm,bottom=2cm}
\printbibliography[title=【全部引文】]
\end{document}
\end{codetex}

结果如图\ref{fig:eg:bibinmargin}所示。

\begin{figure}[!htb]
  \centering
  \fbox{\includegraphics[width=\figwd\textwidth,page=1]{egbibinmargin.pdf}}
  \caption{旁注中的参考文献表}\label{fig:eg:bibinmargin}
\end{figure}

\subsubsection{使用自定义环境实现旁注文献表}

旁注的文献表还可以通过自定义参考文献环境命令的方式实现，这种方式下可以同时存在脚注和旁注参考文献。例\ref{eg:bib:infootmargin}给出了测试代码，这也是参考文献表环境定义的一个例子。需要注意，这里定义的命令中使用了kewword域中的引用关键词信息，这一信息是由gb7714-2015样式文件处理后提供的，所以使用这种方式必须加载gb7714-2015样式。而且这里的环境定义相对比较简单，可以进一步改进。或者也可以利用biblatex提供的接口使用文献的条目类型驱动，具体可以参考biblatex宏包说明的Mixing Programming Interfaces 一节。

\begin{codetex}{另一种脚注和旁注参考文献表}{eg:bib:infootmargin}
%file:egbibinfootmargin
\documentclass[twoside]{article}
\usepackage{ctex}
\usepackage{geometry}
\geometry{includemp,paperwidth=21cm,paperheight=19cm,%
left=1cm,right=1cm,marginparwidth=6cm,top=1cm,bottom=1.5cm}
\usepackage{xcolor}
%书签功能，选项去掉链接红色方框
\usepackage[CJKbookmarks,colorlinks,bookmarksnumbered=true,pdfstartview=FitH,linkcolor=blue]{hyperref}
\usepackage[backend=biber,style=gb7714-2015]{biblatex}
\addbibresource[location=local]{example.bib}

%\newcommand{\itemcmd}[1]{#1\par}
\defbibenvironment{marginref}{\begingroup}
{\endgroup}{\zihao{6}\songti}%\newline\itemcmd
\defbibheading{marginref}{}
\newcommand{\pz}[1]{% 定义 pz 为旁注命令
\marginpar[\flushright\textcolor{blue}{\scriptsize#1}]{\scriptsize#1}}
\newcommand{\pzcite}[1]{%
\cite{#1}
\marginpar[\flushright\textcolor{blue}{{\printbibliography[env=marginref,keyword=#1,heading=marginref]}}]
{\printbibliography[env=marginref,keyword=#1,heading=marginref]}}

\begin{document}
\section{脚注和旁注中的文献表}
参考文献\pzcite{Eggrers--}中文段落参考文献中文段落参考文献中文段
参考文献中文段落参考文献中文段落参考文献中文段落参考文献中文段落
参考文献中文段落参考文献中文段落参考文献中文段落参考文献中文段落
参考文献\pzcite{汤万金2013-09-30--}中文段落参考文献中文段落参考
参考文献\footfullcite{刘裕国2013-01-12--}
\footfullcite{Dublin2012-06-14--}
\footfullcite{王夫之1845--}
中文段落参考文献中文段落参考文献中文段落参考文献中文段落
参考文献中文段落参考文献中文段落参考文献中文段落参考文献中文段落

text text text text text text text text text
\fbox{here is a marginpar}\pz{some note.}
text text text text text text text text text
text text text text text text text text text

参考文献中文段落参考文献中文段落参考文献中文
\fbox{这里是旁注}\pz{中文旁注}
段落参考文献中文段落参考文献中文段落参考文献
中文段落参考文献中文段落参考
\printbibliography[title=【参考文献】]
\end{document}
\end{codetex}

结果如图\ref{fig:eg:bibinfootmargin}所示。

\begin{figure}[!htb]
  \centering
  \fbox{\includegraphics[width=0.8\textwidth,page=1]{egbibinfootmargin.pdf}}
  \caption{脚注和旁注中参考文献表}\label{fig:eg:bibinfootmargin}
\end{figure}

\subsection{专题：beamer类中的参考文献}\label{sec:bib:inbeamer}
在beamer类中使用biblatex生成参考文献与一般文档类中大体上一致，略有差别，主要是refsection环境无法使用。在实际应用中，beamer 类有两种文献表是主要的，一是文末的文献表，二是脚注中的文献表。

\subsubsection{文末文献表和脚注文献表}
文末的文献表，一般是全局文献，所以可以不使用任何的refsection或者refsegment，也可以使用refsegment环境。不用refsegment时，在frame中需要引用文献的地方加入cite等命令，在某一frame中用printbibliography打印输出即可。使用refsegment环境时，将引用参考文献的内容包含在各个refsegment环境中，然后使用一个全局的printbibliography命令遍历各个refsegment打印输出。这两种方法在beamer中都可以使用。

脚注中的文献表类似于一般文档类中的做法，使用biblatex提供的footfullcite命令即可。例\ref{eg:bib:beamer}给出了一个测试代码。其结果如图\ref{fig:eg:bibinbeamerfoot}，\ref{fig:eg:bibinbeamer}所示。

\begin{codetex}{beamer中使用biblatex参考文献}{eg:bib:beamer}
%file:egbibinbeamer
\documentclass[xcolor=svgnames]{beamer}
\mode<presentation>
\usepackage{ctex}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{listings}
\usepackage[backend=biber,style=gb7714-2015]{biblatex}
\renewcommand{\bibfont}{\zihao{8}\songti}
\addbibresource[location=local]{example.bib}

\title{\LaTeX{} 参考文献之 \newline
Biblatex宏包使用和GB/T7714-2015参考文献样式}
%\renewcommand{\thefootnote}{\fnsymbol{footnote}}
\author{胡振震\footnote{hzzmail@163.com}}
\date{\today}
\renewcommand{\footnotesize}{\tiny}

\begin{document}
\begin{frame}[plain]
  \titlepage
\end{frame}

\begin{frame}{测试参考文献}
\tiny
在脚注中引用或者把文献表放到脚注中
\footnote{在脚注中引用\footcite{Saito2006-169-176}}
\footfullcite{中国职工教育研究会1985--}
\footfullcite{Fontana2002-309-313}
\footfullcite{Robertson2011--}
\footfullcite{雷光春2012--}
\footfullcite{Humphrey1971--}
\footfullcite{马欢2011-27-27}
\footfullcite{中国图书馆学会1957--}
\footfullcite{刘彻东1998-38-39}
\end{frame}

\begin{frame}{参考文献}
\printbibliography[heading=bibliography,title=参考文献]
\end{frame}
\end{document}
\end{codetex}

\begin{figure}[!htb]
  \centering
  \fbox{\includegraphics[width=\figwd\textwidth,page=2]{egbibinbeamer.pdf}}
  \caption{beamer类脚注中的参考文献表}\label{fig:eg:bibinbeamerfoot}
\end{figure}

\begin{figure}[!htb]
  \centering
  \fbox{\includegraphics[width=\figwd\textwidth,page=3]{egbibinbeamer.pdf}}
  \caption{beamer类全局参考文献表}\label{fig:eg:bibinbeamer}
\end{figure}

\subsubsection{文献表中的条目序号}

因为beamer类中重定义了一些内容，比如空格，list环境的标签等，或者因为一些非标准标签的块环境自定义，biblatex默认使用的文献表环境，可能会导致文献表的序号丢失(图\ref{fig:eg:bibinblock:nsw}中文献表只有第一条有序号)或者不是想要的顺序编码的标签(图\ref{fig:eg:bibinbeamer}中的文献表就是一个图标，而不是一个序号，这也许不是想要的)。这个序号丢失的问题来自ctex论坛的提问\cite{olqa2016--}。

\begin{figure}[!htb]
  \centering
  \fbox{\includegraphics*[viewport=38cm 15.5cm 83cm 28.5cm,clip=true,scale=0.25]{egpostersnw.pdf}}
  %\fbox{}%bb=40cm 10cm 83cm 30cm,bbllx=40cm,bblly=10cm,bburx=83cm,bbury=30cm
  \caption{一个自定义block中参考文献表(序号丢失)}\label{fig:eg:bibinblock:nsw}
\end{figure}

这种情况下，要得到参考文献表的顺序编码序号，有两种方法: 一是使用自定义的参考文献环境，避免使用基于list的环境，二是将list环境命令的标签重新设置回来。第一种方法比如利用gb7714-2015样式文件，设置其align选项为gb7714-2015就可以得到顺序标签，
代码如例\ref{eg:bib:beamer:sngb}所示，结果如图\ref{fig:eg:bibinbeamer:sngb}所示。第二种方法，最方便的是设置beamer的内部主题，比如defbeamertemplate*\{bibliography item\}和setbeamertemplate\{bibliography item\}，
代码如例\ref{eg:bib:beamer:sninner}所示，结果如图\ref{fig:eg:bibinbeamer:sninner}所示，其中利用setbeamertemplate\{bibliography item\}命令也可以设置成其他标签形式，beamer标准主题\pagescite[][96]{Tantau2015--}提供了default，article，book，online，triangle，text等6种形式，当不想要例\ref{fig:eg:bibinbeamer:sninner}中顺序编码标签时，完全可以选择这些标签形式。

\begin{codetex}{beamer中biblatex使用gb7714-2015定义的align=gb7714-2015选项}{eg:bib:beamer:sngb}
%file:egbeamersn.tex
\usepackage[backend=biber,bibstyle=gb7714-2015-m,%nature,%
citestyle=gb7714-2015,%,backref=true%gb，gbt7714_2005_n，
align=gb7714-2015%
]{biblatex}%biber，caspervector
\renewcommand{\bibfont}{\footnotesize}
\addbibresource[location=local]{bib.bib}
\end{codetex}

\begin{codetex}{beamer中biblatex利用内部主题设置文献表标签}{eg:bib:beamer:sninner}
%file:egbeamersnw.tex
\usepackage[backend=biber,bibstyle=gb7714-2015-m,%nature,%
citestyle=gb7714-2015,%,backref=true%gb，gbt7714_2005_n，
align=left%
]{biblatex}%biber，caspervector
\renewcommand{\bibfont}{\footnotesize}
\addbibresource[location=local]{bib.bib}
\defbeamertemplate*{bibliography item}{numeric}
{\hbox{[\printfield{labelnumber}]}}
\setbeamertemplate{bibliography item}[numeric]%book,numeric
\end{codetex}

\begin{figure}[!htb]
  \centering
  \fbox{\includegraphics[viewport=0.5cm 3cm 12.3cm 7cm,clip=true,scale=0.8,page=3]{egbeamersn.pdf}}
  \caption{beamer中biblatex使用gb7714-2015定义的align=gb7714-2015选项后的文献表}\label{fig:eg:bibinbeamer:sngb}
\end{figure}

\begin{figure}[!htb]
  \centering
  \fbox{\includegraphics[viewport=0.5cm 3cm 12.3cm 7cm,clip=true,scale=0.8,page=3]{egbeamersnw.pdf}}
  \caption{beamer中biblatex利用内部主题设置文献表标签后的文献表}\label{fig:eg:bibinbeamer:sninner}
\end{figure}

但需要注意的是，第二种方法对于标准beamer类或符合其规范的环境下才有效，对于一些自定义的环境可能无法起到作用，
比如在\href{run:./exampleandimage/egpostersnw.tex}{egpostersnw.tex文件}中的自定义的myblock环境中就没有效果。因此只能采用第一种方法，具体见\href{run:./exampleandimage/egpostersn.tex}{egpostersn.tex文件}的内容。其结果如图\ref{fig:eg:bibinblock:ns}所示。

\begin{figure}[!htb]
  \centering
  \fbox{\includegraphics*[viewport=38cm 15.5cm 83cm 28.5cm,clip=true,scale=0.25]{egpostersn.pdf}}
  %\fbox{}%bb=40cm 10cm 83cm 30cm,bbllx=40cm,bblly=10cm,bburx=83cm,bbury=30cm
  \caption{自定义block中使用gb7714-2015定义的align=gb7714-2015选项后的文献表}\label{fig:eg:bibinblock:ns}
\end{figure}

观察egpostersnr.tex文件所使用的主题beamerthemeZH.sty，理论上看beamer中定义block应该不会导致序号丢失的，但为什么这里就丢失了呢？仔细查看后，发现其中使用了ragged2e宏包中的justify命令，但事实上ragged2e说明文档中并没有该命令，而只有justifying命令，所以序号丢失的问题我估计是主题作者的justifying命令笔误了，导致了一些未知的问题。事实上只要把这个命令改回来，就不存在丢失的问题了，那么第二种方法的应用自然也没有问题。
详见\href{run:./exampleandimage/egpostersnr.tex}{egpostersnr.tex}，
\href{run:./exampleandimage/egpostersnr.tex}{egpostersnr.pdf}，
\href{run:./exampleandimage/beamerthemeZHM.sty}{beamerthemeZHM.sty}文件，其中beamerthemeZHM.sty就是原beamerthemeZH.sty文件的修正。

\subsubsection{beamer中biblatex参考文献表内容格式}
参考文献表的内容格式(包括段落、字体和颜色等)的修改，除了可以利用biblatex提供的钩子(见\ref{sec:bib:content:md}节)、自定义参考文献环境(见\ref{sec:bib:content:md}节)、设计和使用特定的参考文献样式(见\ref{sec:bib:style}节)外，还可以利用beamer主题进行修改，可以从Template/Color/Font三个角度进行修改。

从实践看，因为biblatex中给出的各条目参考文献中各块各单元都是一个编组，且这些编组都有其相应的域格式控制，因此段落格式(包括标点)和字体是不能通过beamer主题修改的，而因为biblatex的各单元的域格式并没有对颜色进行设置，因此beamer主题可以修改其颜色，代码如例\ref{eg:bib:beamer:color}所示，结果如图\ref{fig:eg:bibinbeamer:color}所示。

这里格式添加的原理是在条目开始时添加一个设置信息，遇到一个block时又添加一个设置信息，因为biblatex没有对域格式进行颜色设置，所以在各单元的编组外的颜色设置信息能够起到作用，而字体和标点设置信息因为编组内就有，编组外的设置信息自然无法起到作用。这里的遇到block产生添加信息也无非两条路子，一是重定义newblock命令，二是使用appto等命令在其后或前添加命令。

\begin{codetex}{beamer中biblatex利用颜色主题设置文献颜色}{eg:bib:beamer:color}
%file:egbeamer.tex
\usepackage[backend=biber,style=gb7714-2015%gb7714-2015,%nature,%
%,backref=true%gb，gbt7714_2005_n，
]{biblatex}%biber，caspervector
\renewcommand{\bibfont}{\footnotesize}
\addbibresource[location=local]{bib.bib}
%颜色设置-有效
\setbeamercolor{bibliography item}{fg=yellow}
\setbeamercolor{bibliography entry author}{fg=red}
\setbeamercolor{bibliography entry title}{fg=green}
\setbeamercolor{bibliography entry location}{fg=blue}
%\setbeamercolor{bibliography entry note}{fg=pink}
\setbeamertemplate{bibliography item}[book]
%段落格式设置-无效
%\defbeamertemplate*{bibliography entry article}{default}{}
%\defbeamertemplate*{bibliography entry title}{default}{\par}
%\defbeamertemplate*{bibliography entry location}{default}{\par}
%\defbeamertemplate*{bibliography entry note}{default}{\par}
\setbeamertemplate{bibliography entry article}[default]
\setbeamertemplate{bibliography entry title}[default]
\setbeamertemplate{bibliography entry location}[default]
\setbeamertemplate{bibliography entry note}[default]
%\setbeamertemplate{bibliography entry article}{\newline}
%\setbeamertemplate{bibliography entry title}{\newline}
%\setbeamertemplate{bibliography entry location}{\newline}
%\setbeamertemplate{bibliography entry note}{\newline}
%字体设置-无效
\setbeamerfont{bibliography item}{family=\rmfamily,size=\small,shape=\itshape}
\setbeamertemplate{bibliography entry article}{shape=\itshape}
\setbeamertemplate{bibliography entry title}{shape=\itshape}
\setbeamertemplate{bibliography entry location}{shape=\itshape}
\setbeamertemplate{bibliography entry note}{shape=\itshape}
\end{codetex}

\begin{figure}[!htb]
  \centering
  \fbox{\includegraphics[viewport=0.5cm 3cm 12.3cm 7cm,clip=true,scale=0.85,page=3]{egbeamer.pdf}}
  \caption{beamer中biblatex利用颜色主题设置文献颜色}\label{fig:eg:bibinbeamer:color}
\end{figure}

\section{参考文献样式定制方法}\label{seca:style:design}

biblatex强大还体现在参考文献样式的定制功能上。本文作为biblatex的使用教程，除了在上一节介绍biblatex基本的功能和机制(包括:通过选项设置修改、通过简单语句操作修改)外，也将介绍更深层次的功能，主要放在本节中，通过介绍biblatex-gb7714-2015样式包等的设计与实现来阐述biblatex的高阶功能和强大机制。介绍的步骤，首先是根据样式设计的需求，提出可能要解决的问题，然后分析其原理性思路，接着介绍功能应用，最后则是代码的实现。

%biblatex相当完善和强大，笔者开发样式文件过程中仅使用了biblatex提供的一小部分功能，更多功能其实都没有涉及到。可以说，biblatex作为参考文献问题的一个完整解决方案是名副其实的。笔者在设计样式文件时应用biblatex宏包功能的思路和实现总结如下:

\subsection{gb7714-2015样式设计与实现}

\subsubsection{动机}
需求分析是设计的根本来源。之所以要开发biblatex-gb7714-2015样式包肯定存在一定的动机，包括填补空白，改进完善等等。具体到细节上，可能包括如下方面，这既是biblatex-gb7714-2015样式设计的来源，也是要解决的问题:

\begin{enumerate}
  \item biblatex版本的兼容性(原来用李志奇分享的样式，但在biblatex升级后不能用了，所以希望样式能够克服biblatex版本变化带来的问题)
  \item 格式修改的可逆性(希望样式中做的修改时可以通过选项等方式调整的，以增加用户使用的灵活性，甚至可以通过选项等完全回复到标准样式。)
  \item 多语言对照(希望实现标准提出的要求)
  \item 文献表的整体格式(希望实现类似word中的标签形式，而不仅是latex中list的那种风格)
  \item 新增加的条目类型(除了利用常见条目实现外，还可以针对国标的条目增加新的类型)
  \item 自定义的域(因为国标有一些文献类型载体标识等的要求，所以要使用自定义的域)
  \item 著录条目中的作者格式(除提供标准要求格式外，希望提供多种格式选择)
  \item 著录条目中中英文不同的缩略词(希望实现标准的要求)
  \item 著录条目中的日期格式(希望实现标准的要求)
  \item 著录条目中的标点格式 (希望实现标准的要求)
  \item 著录条目中的域的解析(起止卷期等)(希望实现标准的要求)
  \item 标注的格式(希望实现标准的要求)
\end{enumerate}

上述这些是后期不断完善提出来的总结，其实在初期设计时，主要还是针对目标即GB/T 7714-2015标准来一条条的实现，缺什么增加什么，哪个有问题改什么。

\subsubsection{著录样式的设计途径}
  biblatex的核心之一——参考文献样式文件的设计遵循一定的规则：
  \begin{enumerate}
    \item driver的作用:条目驱动，修改一些顺序，略去一些输出和标点
    \item micro的作用:输出宏，修改需要的输出内容
    \item format的作用:域打印格式，修改一些斜体，强调样式等。
    \item command的作用:一些设置和命令
    \item biblatex.sty/def和各bbx/cbx文件中的代码
  \end{enumerate}

  可以从上述这些方面来设计实现需要的格式要求。

  下面通过一个问题查找过程来进一步说明文献著录表的内容组织原理：


\paragraph{文献著录表的内容组织原理}

biblatex是利用tex语句控制文献内容组织，因此我们可以坚定一点就是，对于文献内容的组织一定不是神秘的，是可以分析清楚的，当出现问题的时候，通过一步步的分析是能解决好的。

如前所述，根据宏包设置，使用biber解析完参考文献信息后，就需要利用样式中的各种定义来输出文献表。我们从某一条参考文献来看问题。某一类型的参考文献输出由该类型的driver控制，driver中控制各种bibmacro来组织内容输出，bibmacro利用各种fieldformat，command来控制域的格式和标点，当出现一些特殊的问题时，我们可以顺着这样的思路来查找。

下面我们举例来说明本样式的作者年制中，当作者缺省时，利用title判断中英文出错的问题。这个问题本质上由于前面说过的，当作者缺省时，把title作为标签后，会把title域清除，因此再利用title域信息判断中英文，自然无法正常工作。我们来看看这是怎么一个过程:

这是一个作者缺省的book条目，在gb7714-2015ay样式不使用佚名方式的情况下报错，主要是testCJKfirst函数（见\ref{sec:cjkjudge}中的代码）报错。这个函数主要用在作者，出版项等这些信息输出时的中英文判断。因为作者缺省，因此作者输出时就没有判断，而出错只能是在出版项中。我们把book的driver中macro输出一项一项注释掉并测试发现，当作者输出相关的macro存在时存在错误，注释掉则没有问题。于是深入来分析:

在book类的driver简化为如下三项输出:
\begin{texlist}
\DeclareBibliographyDriver{book}{%
  \usebibmacro{bibindex}%
  \usebibmacro{begentry}%
  \usebibmacro{author/editor+others/translator+others}%
  \setunit{\labelnamepunct}\newblock
  \usebibmacro{maintitle+title}%
  \newunit
  \usebibmacro{publisher+location+date}%
  \newunit\newblock
  \usebibmacro{finentry}}
\end{texlist}

其中usebibmacro\{author/editor+others/translator+others\}导致出错，该macro的思路是当存在author时输出author，没有时判断是否存在editor，存在则输出，不存在则判断是否存在translator，并进一步判断输出:
\begin{texlist}
\newbibmacro*{author/editor+others/translator+others}{%
  \ifboolexpr{
    test \ifuseauthor
    and
    not test {\ifnameundef{author}}
  }
    {\usebibmacro{author}}
    {\ifboolexpr{
       test \ifuseeditor
       and
       not test {\ifnameundef{editor}}
     }
       {\usebibmacro{editor+others}}
       {\usebibmacro{translator+others}}}}
\end{texlist}

显然这个例子中不存在author和editor，因此宏转到macro\{translator+others\}，我们来看这个宏:
\begin{texlist}
\newbibmacro*{translator+others}{%
  \ifboolexpr{
    test \ifusetranslator
    and
    not test {\ifnameundef{translator}}
  }
    {\printnames{translator}%
     \setunit{\printdelim{translatortypedelim}}%
     \usebibmacro{translator+othersstrg}%
     \clearname{translator}}
    {}}
\end{texlist}

这个宏来自biblatex.def，显然这个宏表明当translator不存在则不做任何事情，这种情况下是不会出错的，于是我们再找，发现这个宏在authoryear.bbx中重定义了。
\begin{texlist}
\renewbibmacro*{translator+others}{%
  \usebibmacro{bbx:translator}{translator+othersstrg}}

\newbibmacro*{bbx:translator}[1]{%
  \ifboolexpr{
    test \ifusetranslator
    and
    not test {\ifnameundef{translator}}
  }
    {...code for existed translator...}%
    {\global\undef\bbx@lasthash
     \usebibmacro{labeltitle}%
     \setunit*{\printdelim{nonameyeardelim}}}%
  \usebibmacro{date+extradate}}
\end{texlist}

显然当translator不存在时，使用了labeltitle宏，再来看这个宏:
\begin{texlist}
\newbibmacro*{labeltitle}{%
  \iffieldundef{label}
    {\iffieldundef{shorttitle}
       {\printfield{title}%
        \clearfield{title}}
       {\printfield[title]{shorttitle}}}
    {\printfield{label}}}
\end{texlist}

从中可以看到，该宏把title域作为标签进行输出，并在输出后清除了title域，自然，在完成了整个author/editor+others/translator+others宏后，title域就不存在了，因此在后面的publisher+location+date宏中使用title域来进行中英文判断是必然会出错的，找到了问题所在，那么就有相应的方法，比如在动态数据修改时，把title信息存储到userd域中，然后在publisher+location+date宏中利用该域的信息进行判断，就不会出现问题了。

从这样一个查找问题的例子，我们看到文献著录内容组织的基本原理，也克服了对biblatex复杂代码的恐惧，接下来就可以按部就班的解决想要解决的问题了。

\subsubsection{兼容性问题的解决思路}\label{sec:blx:compatibility}

\paragraph{biblatex版本的兼容性}
由于biblatex始终在更新，因此一些新版本的改动可能导致原来可用的样式失效，因此需要根据biblatex的版本做一定的调整。而要做调整需要知道当前的biblatex版本，以及当前版本做了哪些改动，是否影响原来的样式文件。

因此样式首先根据biblatex版本信息进行版本判断，然后做针对性的兼容处理。
biblatex在texlive中的版本对应关系是:
texlive2015对应biblatex3.0;
texlive2016对应biblatex3.4，从3.2版开始修改了姓名机制;
texlive2017对应biblatex3.7;
texlive2018对应biblatex3.11;

因为biblatex版本升级需要做的一些兼容性处理包括：

宏包选项:
\begin{texlist}
firstinits=true,%for texlive2014,2015;biblatex <=3.2
giveninits=true,%for texlive2016,2017;biblatex >=3.3
labeldate=true,%for texlive2014,2015,2016,2017;biblatex <3.8
labeldateparts=true,%for biblatex >=3.8a
\end{texlist}

命令:
\begin{texlist}
\printdateextralabel,%for texlive2014,2015,2016;biblatex <=3.4
\printlabeldateextra,%for texlive2017;biblatex >=3.7
\DeclareSortingScheme %for texlive2014,2015,2016,2017;biblatex <3.8
\DeclareSortingTemplate %for biblatex >=3.8a
\end{texlist}

biblatex的版本判断最初使用一个简单的字符流处理来解析
版本信息\verb|\abx@version|。

\begin{texlist}
\providetoggle{iftexlivesix}
%\def\versionstr{3.4}
%\def\versionstra{3.6}
%\ifx\abx@version\versionstr
%\toggletrue{iftexlivesix}
%\else
%\ifx\abx@version\versionstra
%\toggletrue{iftexlivesix}
%\else
%\togglefalse{iftexlivesix}
%\fi
%\fi
%改变版本判断机制，根据biblatex更新历史可知，版本3.3开始使用新的姓名处理机制
%所以当版本大于3.2开始，就用设置\toggletrue{iftexlivesix}
\def\numparserta#1.#2\relax{#1}%注意relax的重要性
\def\numparsertb#1.#2\relax{#2}
\def\numinteger{\expandafter\numparserta\abx@version\relax}
\def\numdigital{\expandafter\numparsertb\abx@version\relax}
\ifnumcomp{\numdigital}{>}{2}{\toggletrue{iftexlivesix}}{\togglefalse{iftexlivesix}}
\end{texlist}

但这种方式容易出现问题，于是换成利用xstring宏包的命令来提取版本中的数字进行判断:
\begin{texlist}
%版本判断
\providetoggle{iftexlivesix}%用于处理biblatex3.3开始改变的新的姓名机制
\providetoggle{iftexliveseven}%用于处理biblatex3.7的兼容性
\providetoggle{iftexliveeight}%用于处理biblatex3.8a的兼容性
%\def\numparserta#1.#2a\relax{#1}%注意relax的重要性
%\def\numparsertb#1.#2a\relax{#2}
%\def\numinteger{\expandafter\numparserta\abx@version\relax}
%\def\numdigital{\expandafter\numparsertb\abx@version\relax}
\StrChar{\abx@version}{3}[\numdigital]
%根据biblatex更新历史，当版本大于3.2开始，就用设置\toggletrue{iftexlivesix}
\ifnumcomp{\numdigital}{>}{2}{\toggletrue{iftexlivesix}}{\togglefalse{iftexlivesix}}
\ifnumcomp{\numdigital}{>}{6}{\toggletrue{iftexliveseven}}{\togglefalse{iftexliveseven}}
\ifnumcomp{\numdigital}{>}{7}{\toggletrue{iftexliveeight}}{\togglefalse{iftexliveseight}}
\end{texlist}

但这种方式仍然会存在问题，特别是当版本信息中带有字母的时候，比如3.8a版本。因此进一步考虑了判断的方式，设计了一种新的处理方式便于以后的扩展。这种方式自然兼容最新的版本，但老的版本的代码处理必须要到位，即因为biblatex版本升级增加了新的老版本时，对应该老版本的选择必须要实现，否则可能漏掉这些旧版本的处理。
\begin{texlist}
%版本判断，当版本继续更新时，增加一个新的toggle用以处理新的旧版，最新版本永远用iftlatest
\providetoggle{iftlfive}%用于处理biblatex3.2之前的版本
\providetoggle{iftlsix}%用于处理biblatex3.3开始改变的新的姓名机制后版本
\providetoggle{iftlseven}%用于处理biblatex3.7的兼容性
\providetoggle{iftleight}%用于处理biblatex3.8到3.9的兼容性
\providetoggle{iftlatest}%用于最新版biblatex，目前是biblatex3.10，20180117
\StrBefore{\abx@version}{.}[\numinteger]%以点区分整数和小数
\StrBehind{\abx@version}{.}[\numdigital]%小数部分可能带字母所以需将其去掉，见下一行代码
\IfInteger{\numdigital}{}{\StrGobbleRight{\numdigital}{1}[\numdigital]}
\togglefalse{iftlfive}
\togglefalse{iftlsix}
\togglefalse{iftlseven}
\togglefalse{iftleight}
\toggletrue{iftlatest}
\ifnumcomp{\numinteger}{=}{3}{
    \ifnumcomp{\numdigital}{<}{10}{\ifnumcomp{\numdigital}{>}{7}{\toggletrue{iftleight}\togglefalse{iftlatest}}{}}{}%>3.8 版本用iftleight=true表示
    \ifnumcomp{\numdigital}{=}{7}{\toggletrue{iftlseven}\togglefalse{iftlatest}}{}%3.7 版本用iftlseven=true表示
    \ifnumcomp{\numdigital}{<}{7}{\ifnumcomp{\numdigital}{>}{2}{\toggletrue{iftlsix}\togglefalse{iftlatest}}{}}{}%3.3-3.6 版本用iftlsix=true表示
    \ifnumcomp{\numdigital}{<}{3}{\toggletrue{iftlfive}\togglefalse{iftlatest}}{}%3.0-3.2 版本用iftlfive=true表示
}{\ifnumcomp{\numinteger}{>}{3}{
   \blx@warning@noline{%
   biblatex version is >= 4.x.\MessageBreak
   if errors raised，Please contact biblatex-gb7714-2015 pkg author.}%
}{\toggletrue{iftlfive}\togglefalse{iftlatest}%2.x版本统一用iftlfive=true表示
   \blx@warning@noline{%
   biblatex version is <= 2.x.\MessageBreak
   if errors raised，Please contact biblatex-gb7714-2015 pkg author.}%
}}
\newcommand\defversion[2]{\csdef{codeversion#1#2}}%定义不同版本的命令
\newcommand\switchversion[2]{\csuse{codeversion#1#2}}%使用不同版本的命令

\defversion{3.0}{opt}{
    %biblatex3.3版前(比如texlive2015中的3.0版)的使用方式

    %增加标签对齐选项，right是默认的右对齐，left是左对齐，gb7714-2015无效，仍然为右对齐模式，因为舍弃了list类环境后出错。
    \DeclareBibliographyOption{gbalign}[right]{%texlive2015中的3.0版中的DeclareBibliographyOption选项没有类型说明
        \ifstrequal{##1}{right}{}{}
        \ifstrequal{##1}{left}{\setalignleft}{}
        \ifstrequal{##1}{gb7714-2015}{}{}
    }

    \ExecuteBibliographyOptions{
      firstinits=true,    %名字有缩写，参考3.1.2.3 Internal
    }
}

\defversion{3.4}{opt}{
    % Alter settings that carry through from biblatex
    %biblatex3.3版后(比如texlive2016中的3.4版)的使用方式

    %增加标签对齐选项，right是默认的右对齐，left是左对齐，gb7714-2015是项对齐方式
    \DeclareBibliographyOption[string]{gbalign}[right]{%
        \ifstrequal{##1}{left}{\setalignleft}{}
        \ifstrequal{##1}{gb7714-2015}{\setaligngbstyle}{}
    }

    \ExecuteBibliographyOptions{
      giveninits=true,
    }
}

\defversion{3.7}{opt}{
    %biblatex3.7版后(比如texlive2017中的3.7版)的使用方式

    %增加标签对齐选项，right是默认的右对齐，left是左对齐，gb7714-2015是项对齐方式
    \DeclareBibliographyOption[string]{gbalign}[right]{%
        \ifstrequal{##1}{left}{\setalignleft}{}
        \ifstrequal{##1}{gb7714-2015}{\setaligngbstyle}{}
    }

    \ExecuteBibliographyOptions{
      giveninits=true,
      date         = year,  %日期仅写到年
      urldate =edtf, %iso8601
      eventdate =edtf,
    }
}

\defversion{3.10}{opt}{
    %biblatex3.10版后的使用方式

    %增加标签对齐选项，right是默认的右对齐，left是左对齐，gb7714-2015是项对齐方式
    \DeclareBibliographyOption[string]{gbalign}[right]{%
        \ifstrequal{##1}{left}{\setalignleft}{}
        \ifstrequal{##1}{gb7714-2015}{\setaligngbstyle}{}
    }

    \ExecuteBibliographyOptions{
      giveninits=true,
      date         = year,  %日期仅写到年
      urldate =iso, %iso8601，edtf
      eventdate =iso,
    }
}

\iftoggle{iftlfive}{\switchversion{3.0}{opt}}{}%biblatex<=3.2
\iftoggle{iftlsix}{\switchversion{3.4}{opt}}{}%3.3<=biblatex<=3.6
\iftoggle{iftlseven}{\switchversion{3.7}{opt}}{}%biblatex=3.7
\iftoggle{iftleight}{\switchversion{3.7}{opt}}{}%3.8<=biblatex<=3.9
\iftoggle{iftlatest}{\switchversion{3.10}{opt}}{}%biblatex最新3.10
\end{texlist}

版本判断其实也可以考虑其它方法，比如用宏包的判断命令\verb|\@ifpackagelater|，具体可以参考nature样式的做法：
\begin{texlist}
\@ifpackagelater{biblatex}{2016/03/27}
{\ExecuteBibliographyOptions{giveninits}}
{\ExecuteBibliographyOptions{firstinits}}

% Modify the name format
\@ifpackagelater{biblatex}{2016/03/27}
{
\DeclareNameFormat{default}{%
  \nameparts{#1}%
  \usebibmacro{name:family-given}
    {\namepartfamily}
    {\namepartgiveni}
    {\namepartprefix}
    {\namepartsuffix}%
 \usebibmacro{name:andothers}%
}
}
{
\DeclareNameFormat{default}{%
  \usebibmacro{name:last-first}{#1}{#4}{#5}{#7}%
  \usebibmacro{name:andothers}%
}
}
\end{texlist}

还有可能用到一些文档环境的判断方法，可以使用\verb|\@ifclassloaded|命令，类似的还有判断宏包是否加载的命令，\verb|\@ifpackageloaded|比如：
\begin{texlist}
\@ifclassloaded{beamer}{
    \DeclareFieldFormat{title}{#1}%
    \DeclareFieldFormat[article,patent,thesis,unpublished]{title}{#1}
    \AtBeginDocument{%
    \patchcmd{\abx@macro@title}{\newunitpunct}{}{}{}}}{}
\end{texlist}

同时也要注意，可能会用到要在编译不同时刻展开或替换，代码放置的位置，比如在宏包末尾，在导言区末尾，在正文开始处等：
\begin{texlist}
\AtEndOfPackage{code}
\AtEndPreamble{code}
\AtBeginDocument{code}
\end{texlist}

\paragraph{版本兼容的两个途径}

从实践看，实现不同biblatex版本的兼容有两个比较合适的途径。

一是 不同版本不同的实现。这是前述选项设置不同版本处理的方法，不同的版本的选项不一样，所以针对具体版本设置相应的选项。其他的宏和命令，也可以类似，在不同的版本下，同一个命令有不同的定义，不同版本使用不同的代码。

二是 使用最新的实现代码。这与第一种方法不同，即不同的版本使用相同的定义，使用一个代码，比如最新的代码。但这时可能会出现问题，因为随着biblatex的更新，最新的代码中可能会使用一些biblatex中新增的定义或功能，而老版本的biblatex不具备，其解决方案是判断当前的版本，如果是biblatex新增的功能不存在就把它从biblatex新版中拷贝进样式文件中来补全功能。

两种途径，一般第一种途径使用较多。第二种也有，但较少。目前应用的主要是在修改textcite命令的标点时候用，由于要在文献表中和标注标签中实现作者域不同的标点，因此需要不同的文境下面使用不同的定义，这在较新的版本中通过 DeclareDelimFormat 定义不同文境下的标点是很容易实现的。因此考虑使用这种方式，但由于texlive2015中的biblatex 3.0不具备该功能，因此对其做补充。

比如 name:andothers 宏中使用的\verb|\printdelim{andothersdelim}|，在不同的文境下需要不同的定义，标注中需要是空格，而文献表中需要是逗号。
\begin{texlist}
\DeclareDelimFormat{andothersdelim}{\addcomma\addspace}
\DeclareDelimFormat[textcite]{andothersdelim}{\addspace}
%
%   修改作者数量超过限定值，做省略时的处理格式
%
%   原理方法:判断作者或译者是否中文，若中文用字符等，否则用etcl。
\renewbibmacro*{name:andothers}{%
  \ifboolexpr{%
    test {\ifnumequal{\value{listcount}}{\value{liststop}}}
    and
    test \ifmorenames
  }%
    {%这里做一个判断是在处理author还是translator用于两者是不同语言的情况
    \ifcurrentname{translator}{\testCJKfirst{usere}}{\testCJKfirst{userf}}%
    %这句判断如果放到\andothersdelim后面会在等或etc.前增加一个空格，所以放前面
    \ifnumgreater{\value{liststop}}{1}%
       {\finalandcomma}%
       {}%biblatex作者要区别单作者加等的情况，这里为符合gbt7714-2015第7.2节的要求加上了逗号。
\printdelim{andothersdelim}\iftoggle{ifCJKforgbt}{\bibstring{andotherscn}}{\bibstring{andothers}}%
%\andothersdelim\bibstring{andotherscn}
}%
{}}
\end{texlist}

但biblatex3.0没有相应功能，为简便起见，直接将 DelimFormat 相关的功能补充进来。当然这仍然可以采用前述的第一种方法来解决，针对biblatex3.0做针对性的实现，即不考虑不同文境下的标点输出，而直接在标注命令中根据版本进行标点的局部重定义。两中途径主要根据方便与否进行选择，这里的问题选择第二种途径，因此补充 DelimFormat 相关功能：
\begin{texlist}
    \iftoggle{iftlfive}{

    \def\blx@inf@delimdeclare#1#2{%
    \blx@info{Delimiter '#1' in context '#2' already defined, overwriting}}

    \def\blx@warn@delimuse#1#2{%
    \blx@warning{Delimiter '#1' in context '#2' undefined}}
    % Delimiter interface

    % [<contextname, ...>]{<name, ...>}{<code>}
    \newrobustcmd*{\DeclareDelimFormat}{%
      \@ifstar
        {\blx@declaredelimclear}
        {\blx@declaredelim}}

    \newrobustcmd*{\blx@declaredelimclear}[3][]{%
      \ifcsvoid{blx@declaredelimcontexts@#2}
        {}
        {\def\do##1{\csundef{blx@printdelim@##1@#2}}%
         \dolistcsloop{blx@declaredelimcontexts@#2}}%
      \cslet{blx@declaredelimcontexts@#2}\@empty
      \ifblank{#1}
        {\blx@declaredelim{#2}{#3}}
        {\blx@declaredelim[#1]{#2}{#3}}}

    \newrobustcmd*{\blx@declaredelim}[3][]{%
      \ifblank{#1}
        {\blx@declaredelim@i{}{}{#2}{#3}}
        {\def\do##1{%
           \listcsadd{blx@declaredelimcontexts@#2}{##1}%
           \blx@declaredelim@i{blx@printdelim@##1@}{##1}{#2}{#3}}%
         \docsvlist{#1}}}%

    \def\blx@declaredelim@i#1#2#3#4{%
      \def\do@i##1{%
        \ifcsdef{#1##1}
          {\blx@inf@delimdeclare{##1}{#2}}
          {}%
        \csdef{#1##1}{#4}}%
      \forcsvlist{\do@i}{#3}}

    % *[<contextname, ...>]{<alias>}{<delim>}
    \newrobustcmd*{\DeclareDelimAlias}{%
      \@ifstar
        {\blx@declaredelimalias}
        {\blx@declaredelimaliasauto}}

    \newrobustcmd*{\blx@declaredelimalias}[3][]{%
      \ifblank{#1}
        {\blx@declaredelimalias@i{}{#2}{#3}}
        {\def\do##1{%
           \blx@declaredelimalias@i{blx@printdelim@##1@}{#2}{#3}}%
         \docsvlist{#1}}}

    \newrobustcmd*{\blx@declaredelimaliasauto}[2]{%
      \blx@declaredelimalias@i{}{#1}{#2}%
      \ifcsvoid{blx@declaredelimcontexts@#2}
        {}
        {\def\do##1{%
           \blx@declaredelimalias@i{blx@printdelim@##1@}{#1}{#2}}%
         \dolistcsloop{blx@declaredelimcontexts@#2}}}

    \def\blx@declaredelimalias@i#1#2#3{%
      \ifcsdef{#1#2}
        {\blx@inf@delimdeclare{#2}{#1}}
        {}%
      \csdef{#1#2}{\csuse{#1#3}}}

    \def\blx@delimcontext{none}
    \newcommand*{\printdelim}[2][]{%
      \ifblank{#1}
        {\ifcsdef{blx@printdelim@\blx@delimcontext @#2}
          {\csuse{blx@printdelim@\blx@delimcontext @#2}}
          {\ifcsdef{#2}% fall back on legacy macros
            {\csuse{#2}}
            {\blx@warn@delimuse{#2}{*}}}}
        {\ifcsdef{blx@printdelim@#1@#2}
          {\csuse{blx@printdelim@#1@#2}}
          {\blx@warn@delimuse{#2}{#1}}}}

    \newcommand*{\delimcontext}[1]{%
      \edef\blx@delimcontext{\blx@delimcontextalias{#1}}}

    \def\blx@delimcontextalias#1{%
      \ifcsdef{blx@delimcontextalias@#1}
        {\csuse{blx@delimcontextalias@#1}}
        {#1}}

    \newcommand*{\DeclareDelimcontextAlias}[2]{%
      \csgdef{blx@delimcontextalias@#1}{#2}}
    }{}
\end{texlist}

\paragraph{GBK编码文件的兼容性}

在使用纯英文的文档中，不涉及到文件的编码问题。但在中文文档中可能涉及到文件编码的问题，因为默认情况下windows下创建的文件是cp 936编码即GBK编码，如果不将其转换为utf-8编码，那么就会涉及到该问题。

我们知道gbk编码的tex文档，利用pdflatex/latex能正确编译，利用xelatex能编译，但中文会显示乱码，在源文档前面增加 XeTeX 原语：\verb|\XeTeXinputencoding "GBK"|  后，显示正常。而 utf-8 编码的tex文档，利用xelatex能正确编译，而pdflatex/latex则不能编译。总的来说，使用GBK编码的情况现在已经大为减少，而遇到时通常是使用pdflatex/latex编译的。因此在参考文献样式中也将面临这一问题。

在biblatex中提供了texencoding和bibencoding选项，它是通过将输入的选项值传递给biber，然后biber利用perl的encode模块实现编码转换的。因此只要是perl的encode模块支持的编码转换，biblatex都是支持的。perl的encode模块的信息见
\href{http://perldoc.perl.org/Encode.html}{encode}，中文的编码信息见
\href{http://perldoc.perl.org/Encode/CN.html}{encode::cn}。用法可以参见：
\href{http://www.xuebuyuan.com/1128675.html}{perl文件编码处理问题}。

当使用GBK编码时，我们可以在biblatex中使用选项：
\begin{texlist}
texencoding=GBK
bibencoding=GBK
\end{texlist}

然而当biblatex的样式文件中含有一些中文字符串时，仍然会出现问题，因为这些字符与样式文件一样是utf-8编码的。因此要把这些字符串替换掉。这时可以使用命令来替换字符，然后用GBK编码的文件中的字符串来重定义这些命令。这一解决思路来自于
\href{https://github.com/CasperVector/biblatex-caspervector}{biblatex-caspervector}
。而且需要注意的是，当这一替换在样式文件内部进行时，仍然会出现问题，因此还需要在宏包结尾来进行替换。

处理代码如下：
\begin{texlist}
%
%   增加一个源文件编码选择选项，当true时可以使用GBK编码。
%   v1.0k, 2018.05.08, by hzz
%
% 原理方法：将需要输出的中文字符串用命令形式表示存储，采用utf8编码时采用bbx文
% 档内的定义即是utf8编码的中文字符串，但tex源文件是gbk编码时，利用gb7714-2015-gbk.def
% 文档内的gbk编码的字符串覆盖。这种覆盖只能在宏包末尾加载时成功实现，所以使用
% AtEndOfPackage。该解决思路学自biblatex-caspervector宏包。
% 另外注意：
% gbk编码的tex文档，利用pdflatex/latex能正确编译，利用xelatex能编译，但中文显示乱码
% 在源文档前面增加 XeTeX 原语：\XeTeXinputencoding "GBK" 后，显示正常
% utf-8编码的tex文档，利用xelatex能正确编译，而pdflatex/latex不能编译。
    \newtoggle{bbx:codegbk}
    \DeclareBibliographyOption{gbcodegbk}[false]{%
        \settoggle{bbx:codegbk}{#1}}
    \ExecuteBibliographyOptions{gbcodegbk}

    \def\str@bibliography{参考文献}
    \def\str@references{参考文献}
    \def\str@bytranslator{译}
    \def\str@andotherscn{等}
    \def\str@backrefpage{引用页}
    \def\str@backrefpages{引用页}
    \def\str@noaddress{出版地不详}
    \def\str@nopublisher{出版者不详}
    \def\str@edition{版}

    \AtEndOfPackage{%
	\iftoggle{bbx:codegbk}{%
		\ExecuteBibliographyOptions{texencoding = GBK}
        \input{gb7714-2015-gbk.def}
	}{}}
\end{texlist}

测试文件见：
\href{run:exampleandimage/testeggbk.tex}{eggbk.tex}，
\href{run:exampleandimage/testeggbkay.tex}{eggbkay.tex}。注意编译时请使用pdflatex或latex。

同时也注意到，bbx文件处理“佚名”和“等”这些本地化字符串之间的差别，因为处理“佚名”的动态数据修改始终是在perl中进行的，所以直接给出中文字符没有问题。而“等”这些本地化字符串必须要用GBK编码的文件中的重定义进行覆盖。

另外还要注意的是，GBK编码的文件不能使用中文的bibtex键即中文的引用关键字。


\subsubsection{中英文混合文献表的解决思路}\label{sec:mix:cnen}

考虑到我国引用参考文献通常是中英文混合的情况，因此不考虑针对中文的本地化处理，而是在英文本地化的基础(英文的本地化字符串设置文档是english.lbx)上添加一些中文要求的本地化字符串来使用。

需要注意:本地化字符串的定义在lbx文件和bbx文件中是不一样的，lbx文件中用的是DeclareBibliographyStrings，而bbx文件中用的是DefineBibliographyStrings，两者的参数是不一样的。

而为了区分使用中英文的字符串，对参考文献条目中数据域内容进行中英文判断，若是中文则使用中文字符串，若是英文则使用英文字符串。这里的中英文判断主要是在tex中的判断，利用对域中的信息进行检测，当信息的第一个字符是CJK字符时，判断该域的信息是中文的，否则是英文的。

在作者年制中不同语种文献分集时也有一个中英文判断，主要是利用动态数据修改的方法。利用perl正则表达式判断作者和标题域中是否有中文信息(可以用排除法即匹配不是英文数字标点的字符通常是中文字符，当然最直接的是用unicode的中文字符范围匹配)，有的话设置cn，否则为en。

事实上这种判断可以进一步扩展，利用强大的perl正则表达式，对所有的关键域进行判断，并在一些域中设置标识，用于tex输出时进行判断，而避免直接使用上述CJK字符判断函数。

\paragraph{利用字符流解析或者xstring宏包的函数}\label{sec:cjkjudge} 以实现中英文的判断

latex判断字符属于哪个区间的方法，最直接的思路就是利用\verb|`|获取字符的编码，然后利用编码进行判断。这里testCJKfirstchar函数就是这样的思路。

字符编码获取的简单方法如下：
\begin{texlist}
    \newcounter{charcode}
    \setcounter{charcode}{`文}
    编码为：\thecharcode
\end{texlist}

cjk字符判断函数如下：
\begin{texlist}
%定义判断中文字符的函数，用于判断作者等信息是否由中文字符构成
%2E00-2E7F 追加标点
%2E80-2EFF cjk部首补充
%2FF0-2FFF 表意文字描述符
%3000-303F cjk符号和标点
%3300-33FF cjk兼容
%3400-4DBF cjk统一表意符号扩展
%4E00-9FBF cjk统一表意符号
%中文范围4E00-9FA5
\providetoggle{ifCJKforgbt}
\def\testCJKfirstchar#1#2&{%
\ifnumgreater{`#1}{"2E7F}{\toggletrue{ifCJKforgbt}}{\togglefalse{ifCJKforgbt}}%
}%

%利用edef展开或xstring抽取第一个字符判断
%现在采用xstring方法，避免抽取的是编组符号
\def\testCJKfirst#1{%
%\edef\tempa{#1}%可以替换下面两句，但失去忽略多余编组功能
\exploregroups%
\StrChar{#1}{1}[\tempa]%
\expandafter\testCJKfirstchar\tempa&}
\end{texlist}

测试文件见：
\href{run:exampleandimage/testcharcode-utf8-xelatex.tex}{testcharcode-utf8-xelatex.tex}，
\href{run:exampleandimage/testcharcode-gbk-xelatex.tex}{testcharcode-gbk-xelatex.tex}。
\href{run:exampleandimage/testcjk-utf.tex}{egtestcjk-utf.tex}。


然而利用\verb|`|获取编码的方法只对原始支持unicode编码的引擎有效，比如xelatex。当使用GBK编码时，如果加xetex原语
\footnote{\url{http://blog.chinaunix.net/uid-23755487-id-2976433.html}}
后使用xelatex编译也能够获得字符编码，但当使用pdflatex或latex编译时，就不能获取，因为\verb|`|的意义变了。因此继续使用上述方法就会出现问题，因此考虑刘海洋提供的利用CJKsymbol进行判断的思路
\footnote{\url{http://bbs.ctex.org/forum.php?mod=viewthread&tid=152663}}，方法如下：

\paragraph{利用CJKsymbol进行的cjk判断}\label{sec:cjkjudgea} 以实现中英文的判断

函数如下：
\begin{texlist}
%
%   判断CJK字符的函数，用于判断作者等信息是否由中文字符构成
%   v1.0k,20180509,hzz
%
% 原理方法:因为考虑使用gbk编码的问题，将原来基于`加字符获取字符编码的cjk判断
% 函数更换成为利用\CJKsymbol的方法。解决方案由刘海洋提供。因为在gbk编码的文件
% 中使用pdflatex编译时`不再是xelatex中的意义。当然这里利用tex的判断方法也可以
% 用biber中的perl方法代替。当前使用这一函数能解决问题情况下，暂不做修改。
%
%   原理是：CJK 输出汉字最终会使用 \CJKsymbol。
%   因此重定义 \CJKsymbol，以在这个宏中设置\ifCJK为真。
%   注意这时整个字符串内只要有cjk字符那么就会判断为cjk。
    \providetoggle{ifCJKforgbt}
    \def\testCJKfirst#1{%
      \begingroup%
      \global\togglefalse{ifCJKforgbt}%
      \def\CJKsymbol##1{\global\toggletrue{ifCJKforgbt}}%
      \setbox0=\hbox{#1}%
      \endgroup}%
\end{texlist}

测试文件见：
\href{run:exampleandimage/testcjk-utf-xelatex.tex}{egtestcjk-utf-xelatex.tex}，
\href{run:exampleandimage/testcjk-gbk-pdflatex.tex}{egtestcjk-gbk-pdflatex.tex}。

然而，该方法解决了gbk编码的问题，但又会导致utf编码时xelatex编译产生问题。当直接对字符进行判断时没有问题，但当字符时定义在一个宏中时，就会出现缺少\}的问题。比如：

\begin{texlist}
\documentclass[UTF8]{ctexart}
\usepackage{etoolbox}
\usepackage{xstring}

\newif\ifCJK
\def\testCJK#1{%
  \begingroup
  \global\CJKfalse
  \def\CJKsymbol##1{\global\CJKtrue}
  \setbox0=\hbox{#1}%
  \endgroup}

\def\hztmp{汉}

\edef\hztmpb{汉}

\begin{document}

\testCJK{Eng}
\ifCJK CJK\else Eng\fi

\testCJK{eng汉字}
\ifCJK CJK\else Eng\fi

%\testCJK{\hztmp}
%\ifCJK CJK\else Eng\fi
%
%\testCJK{\hztmpb}
%\ifCJK CJK\else Eng\fi

%\expandafter\testCJK\hztmp
%\ifCJK CJK\else Eng\fi
%
%\expandafter\testCJK\hztmpb
%\ifCJK CJK\else Eng\fi

\testCJK\hztmp
\ifCJK CJK\else Eng\fi

\testCJK\hztmpb
\ifCJK CJK\else Eng\fi
\end{document}
\end{texlist}

因此，只能利用最终的办法，就是利用动态数据修改中perl进行直接标识。

\paragraph{中文的本地化字符串} 在英文的本地化文件基础上增加修改定义的字符串，以满足中文的规范，比如：

\begin{texlist}
\DefineBibliographyStrings{english}{
bibliography     = {参考文献},
references       = {参考文献},
%bytranslator= {\addcomma\ 译\adddot}, %将trans. by 改成 译
bytranslator= {\addcomma\ 译},%\addperiod
and         = {\addcomma},%将第2和3人名见的and符号改成 逗号，用\finalnamedelim命令也可以定义，参见3.9.1节
%andothers   = {et al.},        %将超过3个人名的省略，et al.改成为 等
andotherscn   = {等},        %将超过3个人名的省略，et al.改成为 等
noaddress = {[S.l.]},
nopublisher = {[s.n.]}
}
\end{texlist}

\subsubsection{功能增加及格式还原的解决思路}

GB样式是在标准样式基础上修改的，因此只要还原每一个修改，那么最终一定能够从gb样式还原到标准样式。为了方便控制这种修改和还原，采用宏包选项控制的方式进行，因此需要增加相应的控制选项。

从总体功能上看，GB样式与标准样式的区别主要有：
\begin{itemize}
  \item 中英文判断问题及对应的缩略词输出问题
  \item GB样式中对于期刊有起止卷期的要求
  \item GB样式对于多语言文献对照的要
  \item GB样式对于作者缺省时处理的要求
  \item GB样式对于顺序编码制文献表标签对齐要求
\end{itemize}

其中前三项在本节其它地方介绍，后面两项可以通过选项来进行控制。作者缺省时的处理用选项gbnoauthor控制还原，文献表标签对齐用gbalign选项控制还原。

从著录格式上看，GB样式与标准样式的区别主要有：
\begin{itemize}
  \item 作者域格式
  \item 标题、网址、页码等其他域的格式
  \item 出版项缺省的格式
  \item 标点
  \item 文献类型和载体标识
  \item 对一些域的输出做了限制
\end{itemize}

作者域格式利用选项gbnamefmt还原。
标题等域的格式利用选项gbfieldstd还原。
出版项缺省的格式利用选项gbpub还原。
标点比如析出源之前的\texttt{//}利用选项gbpunctin还原。
其它域比如卷等，在标准样式中是区分不同的文献条目类型，比如书籍或期刊文章中卷格式是不同的，书籍中加了vol引导词，而期刊文章中没有。而gb样式中[年份, 卷(期)]这种方法是比较清晰的格式，在一些样式如APA等也有应用，其实也可不考虑还原回，甚至也可以使用另一种常见的全部加引导词的方式，类似iso690样式的做法。
而对于域出现的顺序，则不做还原，避免大量的代码改动。对于原来标准样式中输出的域做的限制，也可以利用选项取消，这里采用gbstrict选项还原。

总的来说，尽管GB/T 7714样式看起来并不一定让人觉得美观，但我认为它是经过深入设计的，特别是考虑了中英文文献混合的情况，当采用某些英文文献常见做法（比如使用引导词）时，这种英文的引导词其实并不适合于中文，而中文又没有对应的合适的引导词，所以还不如用标点来代替。比如用\texttt{//}代替in，用[年份, 卷(期)]代替[年份, vol. 卷, no. 期)]，用:代替pp.等。但域内容的一些格式、字体等是可以根据需要进行调整的，以达到更美观的效果。

\paragraph{biblatex的宏包选项增加方法} 要利用biblatex的选项机制来实现某些目的，需要首先弄清楚biblatex及其样式文件中的一些判断/选择机制。

在gb7714-2015.bbx文件中有四种常见的判断方式包括:
版本的判断，
宏包选项的判断，
宏包选项控制的切换标记的判断，
一般的域是否定义或与字符串比较是否相同的判断。

第一种判断，是根据已有的信息直接判断，比如利用\verb|\abx@version|
或\verb|\abx@date| 进行判断，这种处理结果是直接展开的，可以用于后面的任意定义。

第二种判断，是根据不执行默认设置的选项进行判断。例如（注意该选项是string 类型）：

\begin{texlist}
\DeclareBibliographyOption[string]{gbalign}[right]{%
    \ifstrequal{##1}{left}{\setalignleft}{}
    \ifstrequal{##1}{gb7714-2015}{\setaligngbstyle}{}
}
\end{texlist}

这里定义的选项gbalign，但不利用ExecuteBibliographyOptions命令执行默认的设置。这时宏包会按照没有该选项影响的方式进行处理。只有当在biblatex加载时，该选项才会有意义。

当选项给出时，宏包会执行选项中对应选项值的代码，比如给出为gbalign=left，则执行setalignleft命令。

还要注意：当加载选项又不设置选项值时，宏包会执行DeclareBibliographyOption 命令中给出的默认选项，也就是说，当给出选项gbalign，等价于给出gbalign=right。但此时选项定义中没有对应该right 值需要再执行的命令，既不执行setalignleft，也不执行setaligngbstyle，因此不做任何处理。只有设置宏包选项为left或gb7714-2015时才会调用setalignleft和setaligngbstyle命令做进一步的处理。

第三种判断，根据宏包选项控制对切换标记进行设置，然后在代码中应用切换标记判断。比如standard.bbx中定义的url 等选项。
\begin{texlist}
\newtoggle{bbx:gbpub}
\DeclareBibliographyOption[boolean]{gbpub}[true]{%
    %\settoggle{bbx:gbpub}{#1} %或采用下面这一句
    \ifstrequal{##1}{false}{\togglefalse{bbx:gbpub}}{\toggletrue{bbx:gbpub}}}
\ExecuteBibliographyOptions{gbpub}
\end{texlist}

注意到在上述选项定义后面，使用了选项默认执行命令，这时宏包选项定义中的代码会立刻被执行，即在样式中设置了gbpub=true。

注意，样式中可以利用切换标记bbx:gbpub进行任意的宏定义。但如果该宏展开层次是与这里定义的宏包选项同一层次的，那么切换标记会根据默认值是false 而展开，因为宏该宏展开时，选项的执行还未进行。如果宏是下一层的展开（即不需要在加载时展开的），那么会根据展开时，切换标记bbx:gbpub的值进行展开。即这种机制的切换标识判设置，能用于usemacro使用或者域格式定义中，但无法用来判断然后再定义macro，因为定义宏和使用宏是两个不同的展开层级。

注意 ExecuteBibliographyOptions 命令是用来执行选项的，如果不给出这一命令，且宏包加载选择中没有给出选项设置（给出选项等价于执行ExecuteBibliographyOptions），那么toggle只有新建toggle 时的默认定义false。

还要注意该命令执行选项是立刻进行的，如果选项的定义代码不是设置切换标记，而是直接调用命令，比如前面的gbalign的情况，那么就需要被调用命令是有定义的，即命令的定义至少与宏包选项定义在同一展开层次，甚至先于宏包选项定义。

还需要注意，如果给出了命令
\begin{texlist}
\ExecuteBibliographyOptions{gbpub}%等价于下一条命令
\ExecuteBibliographyOptions{gbpub=true}
\ExecuteBibliographyOptions{gbpub=false}
\end{texlist}
等价于在宏包加载时给出选项。类似的，如果在宏包加载时给出选项gbpub=false，那么bbx:gbpub的值设置为false。如果在宏包加载时给出选项gbpub，gbpub=true，那么bbx:gbpub的值设置为true。
但要注意宏包加载选项设置可以覆盖这个命令的设置，因为通常随宏包加载选项会把选项放在样式选项之后。而后面的选项设置会覆盖前面的设置。

第四种判断，利用iffieldundef和iffieldequalstr进行判断即可。域内容的判断方法比如：
\begin{texlist}
%方法1
\iffieldequalstr{note}{news}{\usebibmacro{newsdate}}%判断是否为报纸
                                     {\usebibmacro{date}}%
%方法2
\def\comparetmp{news}\edef\comparetmpb{\thefield{note}}%
\ifx\comparetmp\comparetmpb%
\usebibmacro{newsdate}%
\else%
\usebibmacro{date}%
\fi
\end{texlist}


总结起来，宏包选项的问题需要注意宏包选项的展开顺序。宏包选项的定义如果不使用ExecuteBibliographyOptions命令或者不在加载时设置，那么定义的代码是不执行的。因此如果其他代码中需要使用该宏包选项定义代码中的信息比如切换标记是无法正确获取的。而当使用ExecuteBibliographyOptions命令或者加载选项时，那么宏包选项代码会立即展开，其中需要使用的宏则需要有定义，即先于或与宏包选项定义处于同一展开层。

\paragraph{作者缺省处理} 利用选项gbnoauthor控制

\begin{texlist}
    %增加一个处理佚名或noauthor的控制选项
    \DeclareBibliographyOption{gbnoauthor}[true]{%
      \ifstrequal{##1}{false}{}{\dealnoathor}}
    %\ExecuteBibliographyOptions{gbnoauthor=true}
\end{texlist}

这一选项的机制是，默认情况下不执行选项，这时按照bbx中给出的默认方式进行处理。当加载biblatex时，给出选项，如果是false，则不做任何处理。如果是true，则调用dealnoathor 命令，执行内部的代码，以产生‘佚名’等信息来补充缺失的作者。

dealnoathor的处理代码：
\begin{texlist}
%
%   佚名/noauthor的处理
%
%   原理方法:利用样式层的动态数据修改实现
\def\dealnoathor{
        \DeclareStyleSourcemap{
            \maps[datatype=bibtex]{
                \map{%默认情况下将空缺作者设置为佚名
                    \step[fieldsource=userb,match={cn},final]
                    \step[fieldset=author, fieldvalue={佚名}]
                }
                \map{%默认情况下将空缺作者设置为佚名
                    \step[fieldsource=userb,match={en},final]
                    \step[fieldset=author, fieldvalue={NOAUTHOR}]
                }
            }
        }
}
\end{texlist}


\paragraph{文献表标签对齐} 利用选项gbalign控制

\begin{texlist}
    %
    %   增加标签对齐选项
    %
    %   right是默认的右对齐，left是左对齐，gb7714-2015是项对齐方式
    \DeclareBibliographyOption[string]{gbalign}[right]{%
        \ifstrequal{##1}{left}{\setalignleft}{}
        \ifstrequal{##1}{gb7714-2015}{\setaligngbstyle}{}
    }
\end{texlist}

这一选项的机制是，默认情况下不执行选项，这是按照bbx中给出的默认方式即右对齐处理标签。当加载biblatex时，给出选项，如果是left，则调用setalignleft 命令，利用其中的代码产生左对齐效果。如果是gb7714-2015，则调用setaligngbstyle 命令，执行内部的代码，以实现类似word中的项对齐效果。

\begin{texlist}
%
%   顺序编码制标签对齐方式处理
%
%   原理方法:修改序号标签格式为左对齐,注意各参考文献内容还是对齐的，
%   这样就会使得序号标签与参考文献内容的间隔增大，这个问题是没有办法解决的
%   因为采用list做具有一定宽度的序号标签，\labelwidth只能设置一个，且是最宽的标签的宽度
%   但总的来说参考文献内容对齐是合理和漂亮的，
%   而标签则只能对齐一个方向，要么左对齐要么右对齐，看个人选择了。
%   \DeclareFieldFormat{shorthandwidth}{\mkbibbrackets{#1}} %源来自numeric.BBX
%   \DeclareFieldFormat{labelnumberwidth}{\ttfamily\mkbibbrackets{#1}\hfill}
%   \iftoggle{alignleft}{\DeclareFieldFormat{labelnumberwidth}{\mkbibbrackets{#1}\hfill}}{}% 这种方式无效是因为加载时就已经展开了。
%
%   修改序号标签格式为左对齐
\def\setalignleft{\DeclareFieldFormat{labelnumberwidth}{\mkbibbrackets{##1}\hfill}}
%
%   修改序号标签格式为以各条参文献为基础进行对齐的方式，即序号与条目内容间隔相等的方式。
\def\setaligngbstyle{%
\def\blx@bibitem##1{%
  \blx@ifdata{##1}
    {\begingroup
     \blx@getdata{##1}%
     \blx@bibcheck
     \iftoggle{blx@skipentry}{}{%
       \blx@setdefaultrefcontext{##1}%
       \global\let\blx@noitem\@empty
       \blx@setoptions@type\abx@field@entrytype
       \blx@setoptions@entry
       \blx@thelabelnumber
       \addtocounter{instcount}\@ne
       \blx@initsep
       \blx@namesep
       \csuse{blx@item@\blx@theenv}\relax
%       \blx@initsep   %移动到上面去，恢复bibnamesep等的作用机制
%       \blx@namesep
       \csuse{blx@hook@bibitem}%
       \blx@execute
       \blx@initunit
       \blx@anchor
       \blx@beglangbib
       \bibsentence
       \blx@pagetracker
       \blx@driver\abx@field@entrytype
       \blx@postpunct
       \blx@endlangbib}%
     \par\endgroup}%这里增加了一个\par
    {}}
\newlength{\lengthid}
\newlength{\lengthlw}
\newcommand{\itemcmd}{%
\settowidth{\lengthid}{[\printfield{labelnumber}]}
\addtolength{\lengthid}{\biblabelsep}
\setlength{\lengthlw}{\textwidth}
\addtolength{\lengthlw}{-\lengthid}
\addvspace{\bibitemsep}%恢复\bibitemsep的作用
%\parshape 2 0em \textwidth \lengthid \lengthlw
\hangindent\lengthid
[\printfield{labelnumber}]\hspace{\biblabelsep}}
\defbibenvironment{bibliography}
{\begingroup\setlength{\parindent}{0em}}
{\endgroup}
{\itemcmd}}
\end{texlist}

\paragraph{作者域格式} 利用选项gbnamefmt控制

\begin{texlist}
    %
    %   增加姓名大小写格式处理选项
    %
    \DeclareBibliographyOption[string]{gbnamefmt}[uppercase]{%
        %\ifstrequal{##1}{gbuppercase}{}{}%
        \ifstrequal{##1}{lowercase}{\execgblowercase}{}%
        \ifstrequal{##1}{none}{\execnamedefault}{}
        \ifstrequal{##1}{pinyin}{\execnamepinyin}{}
        \ifstrequal{##1}{apa}{\execnameapa}{}
    }
    %\ExecuteBibliographyOptions{gbnamefmt}
\end{texlist}

这一选项的机制是，首先在bbx中定义了姓名域格式比如name:given-family等宏，然后根据输入的选项执行execgblowercase等命令，其中有重定义的姓名域格式。当宏包加载时给出选项设置，那么就会完成姓名域格式重定义。

作者的数量由biblatex选项控制，作者年制的参考文献表和标签中的作者名数量做区分。列表中最大为3 个，引用中最大为1个。
\begin{texlist}
\ExecuteBibliographyOptions{
  %maxnames     = 3 , %设置名字最大数量
  %minnames     = 3,  %设置缩减后的名字最小数量
  maxbibnames=3, %将文献列表和引用中最大名字数量区分开
  minbibnames=3,
  maxcitenames=1,
  mincitenames=1
}
\end{texlist}

\paragraph{标题等的域格式} 利用选项gbfieldstd控制

\begin{texlist}
    %
    %   增加一个恢复域格式为标准样式的控制选项
    %   v1.0k, 2018.05.15, by hzz
    %
    %   原理方法:
    %   默认设置该选项为false，采用国标要求的域格式输出相关域
    %   当设置该选项为true时，则重新利用标准样式的域格式输出相关的域
    \newtoggle{bbx:gbfieldstd}
    \DeclareBibliographyOption{gbfieldstd}[false]{%
      \settoggle{bbx:gbfieldstd}{#1}%
      \ifstrequal{#1}{false}{}{\execgbfdfmtstd}%
      }
    \ExecuteBibliographyOptions{gbfieldstd}
\end{texlist}
这一选项里面有两个机制，默认情况下执行选项为false，此时设置toggle：bbx:gbfieldstd为false，不执行其它命令，此时采用bbx文件中默认定义的域格式输出，同时在某些宏中根据bbx:gbfieldstd标记为false输出相应的代码。当设置选项为true时，执行execgbfdfmtstd命令中的代码重定义对应的域格式，并在某些宏中输出对应toggle为true的代码。

出版项的处理代码为(注意其中的标点处理)：
\begin{texlist}
\renewbibmacro*{publisher+location+date}{\bibpubfont%
\iftoggle{bbx:gbpub}%
{\testCJKfirst{userd}%
\iflistundef{location}{%\adddot
\iffieldequalstr{note}{standard}{}{%从gbt7714-2015标准第19页看到，标准存在出版项时输出，没有时完全省略。
\iftoggle{ifCJKforgbt}{\printtext{[\str@noaddress]}\addcolon\addspace}{\printtext{[S.l.\adddot]}\addcolon\addspace}%
}}%  \bibstring{noaddress}
{\printlist{location}\addcolon\addspace}%
%\addcolon\addspace%
\iflistundef{publisher}{%
\iffieldequalstr{note}{standard}{}{%
\iftoggle{ifCJKforgbt}{\printtext{[\str@nopublisher]}\setunit{\adddot\addspace}\setunit*{\addcomma\addspace}}%
{\printtext{\mkbibbrackets{s.n.}}\setunit{\adddot\addspace}\setunit*{\addcomma\addspace}}%
}}%
{\printlist{publisher}\setunit*{\addcomma\addspace}}%
%\addcomma\addspace%
\usebibmacro{date}%
%\newunit %去掉这个标点
}%
{\printlist{location}%
  \iflistundef{publisher}
    {\setunit*{\addcomma\space}}
    {\setunit*{\addcolon\space}}%
  \printlist{publisher}%
  \setunit*{\addcomma\space}%
  \usebibmacro{date}%
  %\newunit
  }%
}
\end{texlist}


\paragraph{出版项缺省的格式} 利用选项gbpub控制。

\begin{texlist}
    %
    %   增加一个出版项自动处理控制选项，当true时使用出版者不详等信息补充缺失的出版信息。
    %
    \newtoggle{bbx:gbpub}
    \DeclareBibliographyOption{gbpub}[true]{%
        %\settoggle{bbx:gbpub}{#1} %或采用下面这一句
        \ifstrequal{#1}{false}{\togglefalse{bbx:gbpub}}{\toggletrue{bbx:gbpub}}}
    \ExecuteBibliographyOptions{gbpub}
\end{texlist}
这个选项的机制是默认执行选项为true，进而设置bbx:gbpub这一toggle为true。bbx中的处理出版项的宏根据该toggle输出相应的代码。

\paragraph{标点格式} 特别是析出源之前的\texttt{//}利用选项gbpunctin控制。

\begin{texlist}
    %
    %   增加控制析出文献来源前的标点符号//输出的选项
    %   v1.0k, 2018.04.20,added in  by hzz
    \newtoggle{bbx:gbpunctin}
    \DeclareBibliographyOption{gbpunctin}[true]{%
        \settoggle{bbx:gbpunctin}{#1}}
    \ExecuteBibliographyOptions{gbpunctin}
\end{texlist}
这个选项的机制是默认执行选项为true，进而设置bbx:gbpunctin这一toggle为true。bbx中的处理出版项的宏根据该toggle输出相应的代码。


\paragraph{文献类型和载体标识} 利用选项gbtype控制。

\begin{texlist}
    %
    %   增加一个控制是否输出文献类型和载体标识的选项
    %
    %   原理方法:
    %   对于biblatex3.4以上版本DeclareBibliographyOption命令中的[datatype]如果是boolean，那么是可以省略的
    %   所以用老版本的不用[datatype]的命令可以兼容所有biblatex版本
    \newtoggle{bbx:gbtype}
    %\DeclareBibliographyOption[boolean]{gbtype}[true]{%biblatex高版本
    \DeclareBibliographyOption{gbtype}[true]{%biblatex低版本
      \settoggle{bbx:gbtype}{#1}}
    \ExecuteBibliographyOptions{gbtype}
\end{texlist}

这个选项的机制是默认执行选项为true，进而设置bbx:gbtype这一toggle为true。bbx中的处理出版项的宏根据该toggle输出相应的代码。

文献载体的输出用标题域格式进行实现，由于[]的存在，因此对于标点的处理特别小心：
\begin{texlist}
%
%   新增文献类型标识符的格式
%
\DeclareFieldFormat{gbtypeflag}{%
\iftoggle{bbx:url}{\iffieldundef{url}%当存在url时，增加一个OL标识符
{\nobreak\printtext{[}\nobreak#1\nobreak\printtext{\iffieldundef{medium}{}{\texttt{/}\thefield{medium}}]}}%
{\nobreak\printtext{[}\nobreak#1\nobreak\printtext{\texttt{/}OL]}}%
}{\nobreak\printtext{[}\nobreak#1\nobreak\printtext{\iffieldundef{medium}{}{\texttt{/}\thefield{medium}}]}}}

%
%   新增用于报纸的文献类型标识符的格式
%
\DeclareFieldFormat{gbtypeflagn}{%用于报纸newspaper
\iftoggle{bbx:url}{\iffieldundef{url}%当存在url时，增加一个OL标识符
{\nobreak\printtext{[}\nobreak N\printtext{\iffieldundef{medium}{}{\texttt{/}\thefield{medium}}]}\nobreak}%
{\nobreak\printtext{[}\nobreak N\printtext{\texttt{/}OL]}\nobreak}%
}{\nobreak\printtext{[}\nobreak N\printtext{\iffieldundef{medium}{}{\texttt{/}\thefield{medium}}]}\nobreak}}

%
%   新增用于标准的文献类型标识符的格式
%
\DeclareFieldFormat{gbtypeflags}{%用于标准standard
\iftoggle{bbx:url}{\iffieldundef{url}%当存在url时，增加一个OL标识符
{\nobreak\printtext{[}\nobreak S\printtext{\iffieldundef{medium}{}{\texttt{/}\thefield{medium}}]}\nobreak}%
{\nobreak\printtext{[}\nobreak S\printtext{\texttt{/}OL]}\nobreak}%
}{\nobreak\printtext{[}\nobreak S\printtext{\iffieldundef{medium}{}{\texttt{/}\thefield{medium}}]}\nobreak}}

\DeclareFieldFormat{title}{#1\adddot\addthinspace}
\DeclareFieldFormat{journaltitle}{#1\isdot}%添加\isdot用于缩写名带点情况，将其转换为缩写点，便于标点的追踪
\DeclareFieldFormat{issuetitle}{#1}
\DeclareFieldFormat{maintitle}{#1}
\DeclareFieldFormat{booktitle}{#1}
\DeclareFieldFormat%将期刊等文献的标题中原来带的引号去掉
  [article,patent,thesis,unpublished]
  {title}{#1\adddot\addthinspace}%\mkbibquote{#1\isdot}
\DeclareFieldFormat%将期刊等文献的标题中原来带的引号去掉
  [inbook,incollection,inproceedings]
  {title}{#1}%\nopunct\unspace

%
%   标题的字母大小写格式修改
%
%   注意:修改标题的字母大小写，不能用前面的title的格式而要用titlecase
%   因为titlecase is applied to the contents of the field directly，title is not
%\DeclareFieldFormat{titlecase}{\MakeCapital#1}%重设标题格式，将其修改为首字母大写
\DeclareFieldFormat{titlecase}{\iftoggle{bbx:titlelink}{%
\iffieldundef{url}{\MakeCapital#1}{%
\href{\thefield{url}}{#1}}}{\MakeCapital#1}}%重设标题格式，将其修改为首字母大写

%
%   重设title的输出
%
%   20180425，v1.0k，为标题增加字体控制命令，Hu Zhenzhen
%   原理方法:将文献类型标识符输出出去，原输出来自biblatex.def文件
%   利用toggle做标识符是否输出的判断
\renewbibmacro*{title}{%
  \ifboolexpr{%
    test{\iffieldundef{title}}%
    and
    test{\iffieldundef{subtitle}}%
  }%
    {}%
    {\printtext[title]{\bibtitlefont%增加字体控制命令
       \printfield[titlecase]{title}%
       \ifboolexpr{test {\iffieldundef{subtitle}}}%这里增加了对子标题的判断，解决不判断多一个点的问题
       {}{\setunit{\subtitlepunct}%
       \printfield[titlecase]{subtitle}}%
       \iffieldundef{titleaddon}{}%判断一下titleaddon，否则直接加可能多一个空格
        {\setunit{\subtitlepunct}\printfield{titleaddon}}%
        \iftoggle{bbx:gbtype}{%
         \iffieldundef{note}{\printfield[gbtypeflag]{usera}}%在标题后直接给出文献标识字母，判断一下，是否是报纸和标准
        {\iffieldequalstr{note}{standard}{\printfield[gbtypeflags]{usera}}%判断是否为标准
                                         {\iffieldequalstr{note}{news}{\printfield[gbtypeflagn]{usera}}% 判断是否为报纸
                                                                      {\printfield[gbtypeflag]{usera}}}% 其它
        }}{}%
     %\iffieldundef{booktitle}{\newunit}{}%当title是析出时，不要标点
     %\newunit
}%
}}
\end{texlist}

\paragraph{域输出的限制} 利用选项gbstrict控制。

\begin{texlist}
    %
    %   增加一个严格按GB/T 7714-2015给出著录格式控制域的输出的选项
    %   v1.0k, 2018.05.08, by hzz
    %
    %   原理方法:
    %   默认设置该选项为真，进而不输出GB/T 7714-2015中没有的域的信息
    %   这样可以避免因为bib文件带有多余的域的信息的输出，比如因为bibtex样式
    %   可能需要用于中英文判断的language域的信息。
    \newtoggle{bbx:gbstrict}
    \DeclareBibliographyOption{gbstrict}[true]{%
      \settoggle{bbx:gbstrict}{#1}}
    \ExecuteBibliographyOptions{gbstrict}
\end{texlist}

这个选项的机制是默认执行选项为true，进而设置bbx:gbstrict这一toggle为true，bbx中处理各条目类型的驱动根据toggle限制一些域的输出。当设置为false后，则取消相应的限制。


\subsubsection{著录格式控制}

著录格式不仅包括整个文献表的格式，还包括表中每一个条目的具体格式。下面分别介绍：

\paragraph{文献表环境和打印输出}
  biblatex宏包的参考文献表的打印与文献表环境相关，或者说文献表环境直接决定了整个文献表的格式，下面来分析biblatex中关于文献表环境的代码：

  \begin{enumerate}
  \item 根据biblatex.sty文件中的\verb|\blx@bibliography|命令可以知道，定义的参考文献表的环境的开始代码在命令中\verb|\blx@bibliography| 中，结束代码在\verb|\blx@endbibliography|中，循环项代码在\verb|\blx@bibitem| 中的\verb|blx@item@\blx@theenv}|命令中。参考文献循环打印依靠\verb|\blx@listloop| 命令实现。
  \item 从\verb|\blx@listloop|可以知道，各条参考文献表的指引信息是混合在一起的并且以|字符为分隔。将混合的参考文献指引信息解析成单独的指引信息，并交给\verb|\blx@bibitem|命令处理。
  \item \verb|\blx@bibitem|首先开始一个编组，然后根据单独一条参考文献的指引信息，获取数据，执行判断，利用参考文献表环境定义的循环项代码对参考文献内容设置段落格式，最后结束编组。在定义gbalign=gb7714-2015 样式的段落格式时，采用了parshape 或者hangindent命令来实现，所以其中增加了一个par 命令以使其生效。
  \end{enumerate}


\paragraph{作者格式控制}

\zhongdian{【注意】：texlive2015中的biblatex版本是3.0，texlive2016中biblatex的版本是3.4，新版本对于名字域打印有了较大变化(即不同版本的biblatex对于DeclareNameFormat的输入参数处理有所不同，如例\ref{eg:name:variables}所示)，所以需做相应的修改，为此在biblatex中首先进行版本判断，然后根据版本不同分别进行设置。}

\begin{codetex}{texlive2016中biblatex3.4版Name域格式输入参数的修改}{eg:name:variables}
for biblatex version 3.0
#1 The last names.
#2 The last names, given as initials.
#3 The first names.
#4 The first names, given as initials.
#5 The name prefixes,
#6 The name prefixes, given as initials.
#7 The name affixes,
#8 The name affixes, given as initials.
for biblatex version 3.4
\namepartfamily
\namepartfamilyi
\namepartgiven
\namepartgiveni
\namepartprefix
\namepartprefixi
\namepartsuffix
\namepartsuffixi
\end{codetex}
处理处理见样式文件。

作者信息的输出最高一层是在驱动中:
\begin{texlist}
\usebibmacro{author/editor+others/translator+others}
\end{texlist}

其中当存在作者时，由如下宏输出:
\begin{texlist}
\renewbibmacro*{author}
\end{texlist}

其中作者列表又由如下命令输出:
\begin{texlist}
\printnames{author}
\end{texlist}

printnames这种命令的输出格式通常由相应输出域的域格式控制，这里则是author域控制:
\begin{texlist}
\DeclareNameAlias{author}{sortname}%for author year style

\DeclareNameAlias{author}{default}%for numeric style
\end{texlist}

其中sortname，default域格式又是:
\begin{texlist}
\DeclareNameAlias{sortname}{family-given/given-family}

\DeclareNameAlias{author}{default}
\DeclareNameAlias{default}{given-family}
\end{texlist}

其中的关键是given-family和family-given两个域格式使用name:family-given和name:family-given宏进行输出。
真实的作者姓名格式在这两个宏中，因此做一定的处理。注意其中的输入参数为：
{namepartfamily}，{namepartgiveni}，{namepartprefix}，{namepartsuffix}（使用名的首字母缩写）或
{namepartfamily}，{namepartgiven}，{namepartprefix}，{namepartsuffix}（不使用缩写）。

\begin{texlist}
%biblatex3.3版后(比如texlive2016中的3.4版)的使用方式
\renewbibmacro*{name:given-family}[4]{%利用family-given定义given-family
  \ifuseprefix
    {\usebibmacro{name:delim}{##3##1}%
     \usebibmacro{name:hook}{##3##1}%
     \ifdefvoid{##3}{}{%
       \ifcapital
         {\mkbibnameprefix{\MakeCapital{##3}}\isdot}
         {\mkbibnameprefix{##3}\isdot}%
       \ifprefchar{}{\bibnamedelimc}}%
     \ifdefvoid{##2}{\mkbibnamefamily{\MakeCapital{##1}}}{\mkbibnamefamily{\MakeUppercase{##1}}}\isdot
     \ifdefvoid{##2}{}{\revsdnamepunct\bibnamedelimd\mkbibnamegiven{\MakeUppercase{##2}}\isdot}%\MakeCapital
     \ifdefvoid{##4}{}{\bibnamedelimd\mkbibnamesuffix{##4}\isdot}}
    {\usebibmacro{name:delim}{##1}%
     \usebibmacro{name:hook}{##1}%
     \ifdefvoid{##2}{\mkbibnamefamily{\MakeCapital{##1}}}{\mkbibnamefamily{\MakeUppercase{##1}}}\isdot
     %
     \ifboolexpe{%
       test {\ifdefvoid{##2}}
       and
       test {\ifdefvoid{##3}}}
       {}
       {\revsdnamepunct}%
     \ifdefvoid{##2}{}{\bibnamedelimd\mkbibnamegiven{\MakeUppercase{##2}}\isdot}%\MakeCapital
     \ifdefvoid{##3}{}{\bibnamedelimd\mkbibnameprefix{##3}\isdot}
     \ifdefvoid{##4}{}{\bibnamedelimd\mkbibnamesuffix{##4}\isdot}}
 }
 \renewbibmacro*{name:family-given}[4]{%
 \usebibmacro{name:given-family}{##1}{##2}{##3}{##4}}

%biblatex3.3版前(比如texlive2015中的3.0版)的使用方式
\renewbibmacro*{name:last-first}[4]{%
  \ifuseprefix
    {\usebibmacro{name:delim}{##3##1}%
     \usebibmacro{name:hook}{##3##1}%
     \ifblank{##3}{}{%
       \ifcapital
         {\mkbibnameprefix{\MakeCapital{##3}}\isdot}
         {\mkbibnameprefix{##3}\isdot}%
       \ifpunctmark{'}{}{\bibnamedelimc}}%
     %\mkbibnamelast{#1}\isdot
     \ifblank{##2}{\MakeCapital##1}{\mkbibnamelast{\MakeUppercase{##1}}}\isdot%\MakeUppercase %\mkbibnamelast{\MakeUppercase{#1}} %\MakeSentenceCase
     %注意上一句\MakeCapital后面如果再跟一个{}包含#1，则没有效果，可能是包在里面少了一层展开
     %因为机构名通常包括在{}内，所以要多展开一次才行，所以这里去掉#1 外面的{}
     %\mkbibnamelast{\MakeUppercase{#1}}\isdot
     %\ifblank{#4}{}{\bibnamedelimd\mkbibnameaffix{#4}\isdot}%这句放到后面
     \ifblank{##2}{}{\revsdnamepunct\bibnamedelimd\mkbibnamefirst{\MakeUppercase{##2}}\isdot}%
     \ifblank{##4}{}{\addcomma\addspace\bibnamedelimd\mkbibnameaffix{##4}\isdot}}
    {\usebibmacro{name:delim}{##1}%
     \usebibmacro{name:hook}{##1}%
     %\mkbibnamelast{#1}\isdot  %3.9.1 Generic Commands and Hooks，对姓重新处理，如下句: %\mkbibnamelast{\MakeUppercase{#1}}
     \ifblank{##2}{\MakeCapital##1}{\mkbibnamelast{\MakeUppercase{##1}}}\isdot  %大写，参考4.6.4 Miscellaneous Commands，\MakeUppercase %\MakeSentenceCase
     %\mkbibnamelast{\MakeUppercase{#1}}\isdot
     %\ifblank{#4}{}{\bibnamedelimd\mkbibnameaffix{#4}\isdot}%这句放到后面
     \ifblank{##2##3}{}{\revsdnamepunct}%
     \ifblank{##2}{}{\bibnamedelimd\mkbibnamefirst{\MakeUppercase{##2}}\isdot}%
     \ifblank{##3}{}{\bibnamedelimd\mkbibnameprefix{##3}\isdot}%
     \addcomma\addspace%
     \ifblank{##4}{}{\addcomma\addspace\bibnamedelimd\mkbibnameaffix{##4}\isdot}%
     }
 }

 \renewbibmacro*{name:first-last}[4]{%
 \usebibmacro{name:last-first}{##1}{##2}{##3}{##4}}
\end{texlist}

\paragraph{超出数量的作者列表处理}
作者数量超出制定数量时，需要用等或et al.来标识。处理宏如下：
\begin{texlist}
%
%   修改作者数量超过限定值，做省略时的处理格式
%
%   原理方法:判断作者或译者是否中文，若中文用字符等，否则用etcl。
\renewbibmacro*{name:andothers}{%
  \ifboolexpr{%
    test {\ifnumequal{\value{listcount}}{\value{liststop}}}
    and
    test \ifmorenames
  }%
    {%这里做一个判断是在处理author还是translator用于两者是不同语言的情况
    \ifcurrentname{translator}{\testCJKfirst{usere}}{\testCJKfirst{userf}}%
    %这句判断如果放到\andothersdelim后面会在等或etc.前增加一个空格，所以放前面
    \ifnumgreater{\value{liststop}}{1}%
       {\finalandcomma}%
       {}%biblatex作者要区别单作者加等的情况，这里为符合gbt7714-2015第7.2节的要求加上了逗号。
\printdelim{andothersdelim}\iftoggle{ifCJKforgbt}{\bibstring{andotherscn}}{\bibstring{andothers}}%
%\andothersdelim\bibstring{andotherscn}
}%
{}}
\end{texlist}


\paragraph{日期格式控制}\label{sec:date:fmt}
随着biblatex的更新，日期格式控制更趋完善。加上biblatex3.8a中biber解析出日期中月份和天数都不带引导的0，比如6月直接解析为6，而不像以前那样解析为06，所以需要特别的注意。因此对于新版本，有些日期比如online的发布日期，访问日期等，采用专门的格式选项如edtf（v3.10后弃用）、iso等进行控制，而老版本则仍然使用原来定义的输出宏。比如:

\begin{texlist}
\defversion{3.7}{date}{
    \DeclareFieldFormat{urldate}{##1}
    \renewbibmacro*{urldate}{%
    \addspace\printtext{[}\printurldate\printtext{]}}%能用高层命令+选项尽量用命令(比如这里的\printurldate)，而不用\blx@edtfdate这种更底层的命令

    \newbibmacro*{newsdate}{%%新增加一个新闻日期
    \blx@edtfdate{}{}%
    }

    \newbibmacro*{modifydate}{%新增加一个带括号的日期，用于表示电子资源的更新和修改日期，而公告日期则按日期格式
        \iffieldundef{year}{%
                \iffieldundef{endyear}{\iffieldundef{eventyear}{}{\printtext{(}\printeventdate\printtext{)}}}%
                {\printtext{(}\printenddate\printtext{)}}%
        }{\iffieldequalstr{year}{}{%因为year存在，但为空
            }{\printtext{(}\blx@edtfdate{}{}\printtext{)}}%
         }%
    }%
}

\defversion{3.4}{date}{
    \renewbibmacro*{urldate}{%
    \addspace\printtext{[}\printfield{urlyear}%
    \iffieldundef{urlmonth}{}{\bibrangedash\printfield{urlmonth}}%
    \iffieldundef{urlday}{}{\bibrangedash\printfield{urlday}}\printtext{]}}

    \newbibmacro*{newsdate}{%%新增加一个新闻日期
    \iffieldundef{year}{}{\printfield{year}%
    \iffieldundef{month}{}{\bibrangedash\printtext{\thefield{month}}%
    \iffieldundef{day}{}{\bibrangedash\printfield{day}}}}%
    }

    \newbibmacro*{modifydate}{%新增加一个带括号的日期，用于表示电子资源的更新和修改日期，而公告日期则按日期格式
        \iffieldequalstr{year}{}{%替换\iffieldundef{year}，因为year总是存在，但为空
            \iffieldundef{endyear}{%
                \iffieldundef{eventyear}{}{\printtext{\mkbibparens{\printtext{\printfield{eventyear}}%
                \iffieldundef{eventmonth}{}{\bibrangedash\thefield{eventmonth}}%
                \iffieldundef{eventday}{}{\bibrangedash\printfield{eventday}}}}%
                }%
            }{%
                \iffieldundef{endyear}{}{\printtext{\mkbibparens{\printtext{\printfield{endyear}}%
                \iffieldundef{endmonth}{}{\bibrangedash\thefield{endmonth}}%
                \iffieldundef{endday}{}{\bibrangedash\printfield{endday}}}}%
                }%
            }%
        }%
        {%
            \iffieldundef{year}{}{\printtext{\mkbibparens{\printtext{\printfield{year}}%
            \iffieldundef{month}{}{\bibrangedash\thefield{month}}%
            \iffieldundef{day}{}{\bibrangedash\printfield{day}}}}%
            }%
        }%
    }%
}

\iftoggle{iftlfive}%%根据texlive/biblatex版本选择
    {\switchversion{3.4}{date}}%
    {\iftoggle{iftlsix}%
        {\switchversion{3.4}{date}}%
        {\switchversion{3.7}{date}}%
    }
\end{texlist}

\paragraph{条目标签中的日期格式}\label{sec:dateinlabel}
主要用于authoryear样式，在authoryear样式中有一个mergedate选项，使用该选项可以进行更多的标签日期格式控制。其中主要是重定义了date+extradate(3.8版，以前的版本叫date+extrayear).

其中有两点需要注意:

1. printdateextra，printlabeldateextra，这样的命令在biblatex.sty中是找不到的定义，因为biblatex实际有定义的命令是这样的:
\begin{texlist}
{\protected\def\blx@imc@printlabeldate{\csuse{mkdaterange#1}{label}}
        \protected\def\blx@imc@printlabeldateextra{\csuse{mkdaterange#1extra}{label}}}
\end{texlist}

printdateextra，printlabeldateextra等命令是由如下命令解析为上述命令:
\begin{texlist}
\blx@regimcs{\printlabeldate \printlabeltime \printlabeldateextra \stripzeros \forcezerosy \forcezerosmdt \mkyearzeros \mkmonthzeros \mkdayzeros \mktimezeros}
\end{texlist}

biblatex很多命令都有类似的方式。

2. 日期的数据来源由DeclareLabeldate定义选择。
日期的的具体格式，则由宏包选项控制。比如labeldate=ymd来控制。(3.5版以上，以前的是datelabel选项)


\paragraph{版本项格式控制}

version/edition域的做格式处理，增加中文判断函数，并增加了注释符以避免带入空格。

\begin{texlist}
%对version的版本信息做出修改，源来自biblatex.DEF
\DeclareFieldFormat{version}{%
\testCJKfirst{userd}%userd保存有标题的信息，用于中文判断
\ifinteger{#1}%
{\iftoggle{ifCJKforgbt}{\printtext{#1版}}%
{\mkbibordedition{#1}~\bibstring{version}}}%
{#1\isdot}}
\end{texlist}


\paragraph{卷期域格式控制} 卷期范围解析函数用于处理连续出版物，2个卷期的情况，函数如下：
\begin{texlist}
%用于解析连续出版物，2个卷期的情况
%\def\multivolumeparsetoparts#1/#2{\def\multivolumefirst{#1}\def\multivolumesecond{#2}}
%\def\multinumberparsetoparts#1/#2{\def\multinumberfirst{#1}\def\multinumbersecond{#2}}
%范围起止间隔符号还是用-，而不是与date相同的/，因为有合期期刊的问题，需要用到/符号
\newcommand{\multivolparser}[1]{%
    \IfSubStr{#1}{-}%
        {\StrBefore{#1}{-}[\multivolfirst]\StrBehind{#1}{-}[\multivolsecond]}%
        {\def\multivolfirst{#1}\def\multivolsecond{}}%
}

\newcommand{\multinumberparser}[1]{%
    \IfSubStr{#1}{-}%
        {\StrBefore{#1}{-}[\multinumberfirst]\StrBehind{#1}{-}[\multinumbersecond]}%
        {\def\multinumberfirst{#1}\def\multinumbersecond{}}%
}

%这里利用李志奇的范围数据解析函数，修改后用来处理卷volume的范围。
%他的这个函数是通用的，只能在使用数据前使用，如果多次使用前一次得到的数据就会被冲掉
%这里的范围起止判断符号还是用-，而不是与date相同的/，因为有合期期刊的问题，需要用到/符号
%\def\gbt@parse@range#1{%
%    \edef\gbt@tmpa{#1}%
%    \expandafter\gbt@parse@rangei\gbt@tmpa-\@empty}
%\def\gbt@parse@rangei#1-#2\@empty{%
%    \global\def\gbt@range@first{#1}%
%    \def\gbt@tmpa{#2}%
%    \ifx\gbt@tmpa\@empty%
%        \global\def\gbt@range@second{}%
%    \else%
%        \gbt@parse@rangeii#2\@empty%
%    \fi}
%\def\gbt@parse@rangeii#1-#2\@empty{%
%    \def\gbt@tmpa{#2}%
%    \ifx\gbt@tmpa\@empty%
%        \global\def\gbt@range@second{#1}%
%    \else%
%        \gbt@parse@rangeii#2\@empty%
%    \fi}

%这里写的number的解析函数，与上面的卷解析函数是类似的。
%\def\multinumberparser#1{%
%    \edef\gbnumbertmp{#1}%
%    \expandafter\multinumberparsetoparts\gbnumbertmp-\@empty}
%\def\multinumberparsetoparts#1-#2\@empty{%
%    \def\multinumberfirst{#1}%
%    \def\gbnumbertmp{#2}%
%    \ifx\gbnumbertmp\@empty%
%        \def\multinumbersecond{}%
%    \else%
%        \multinumberparsetopartsb#2\@empty%
%    \fi}
%\def\multinumberparsetopartsb#1-#2\@empty{%
%    \def\gbnumbertmp{#2}%
%    \ifx\gbnumbertmp\@empty%
%        \def\multinumbersecond{#1}%
%    \else%
%        \multinumberparsetopartsb#2\@empty%
%    \fi}
\end{texlist}

\paragraph{标点和空格的特点和机制} 用于实现满足标准要求的标点和间距。

  \begin{enumerate}
    \item 标点符号设置比如:renewrobustcmd*\{\textbackslash bibinitperiod\}\{\} 和renewcommand*\{\textbackslash revsdnamepunct\}\{\} 等用于全局修改标点。
    \item 如isdot/adddot，adddot将原样(逐字，如实)句点转换为缩写点在有利用printtext输入原样字符的时候很重要比如[s.n.] 中，比如title末尾。
    \item 利用newunit输出的标点，需要后面遇到printfield等命令有内容才输出标点，这是标点的异步处理机制。
    \item setunit*的作用是前面printtext等没有输出时候就不输出，见4.11.7.3 节的应用以及出版项缺省时的代码处理。
    \item 标点和空格的调试方法:有时引入多余的空格和标点后很难快速处理，那么需要调试，调试的第一步是注释掉多余的代码，实现无多余空格或标点情况(一种快速方法是直接在一个printtext输出各相关域)，然后一步步恢复原来的代码，直到找到多余空格或标点产生的原因，最后根据原因作出修改。
    \item 多余空格的引入，可能来自于如下方面(下面是已经遇到的，可能还有更多)
    \begin{itemize}
    \item 行末空格引入，解决方法:把相关的代码行结尾用\%符号注释。
    \item mkbibparens等命令引入，解决方法:利用printtext\{(\}，printtext\{)\}来代替
    \item nopunct等命令引入，这种引入的空格使用unspace命令还消除不了，解决方法:避免使用nopunct命令，而在标点设置时多做判断，只有有内容时才设置标点，而不是过分依赖biblatex提供的标点异步处理机制。
    \end{itemize}

    \item 短横线相关的字符，参考: unicode 表

        \begin{itemize}
        \item 0x2d:hyphen :\char"2D，直接输入键盘短横线得到\verb|-|，即为连字符
        \item 0x2010:hyphen :\char"2010
        \item 0x2011:non breaking hyphen :\char"2011
        \item 0x2012:figure dash :\char"2012
        \item 0x2013:en dash :\char"2013，直接输入两个键盘短横线得到\verb|--|
        \item 0x2014:em dash :\char"2014，中文全角的一段破折号线，可以用三个短横线得到\verb|---|
        \item 0x2212:mathematical minus :\char"2212
        \end{itemize}
        biblatex中页码范围中的间隔符是\verb|\bibrangedash|，默认则是en dash。可以通过设置如下命令做修改:
        \begin{texlist}
        \DefineBibliographyExtras{english}{\renewcommand*{\bibrangedash}{-}}% 将页码间隔符替换为hypen连字符
        \end{texlist}
        而日期成分之间的间隔符则是\verb|\bibdatesep|，默认是hyphen，即连字符。

    \item 使用printtext等命令确保异步处理机制不被破坏，典型的例子为，专利的公告日期(对于3.7以上版本)使用了biblatex的内容宏，但还需要将其用printtext包围起来，比如:
        \begin{texlist}
        %
        %   专利的公告日期、或报纸的日期的输出宏
        %   20160701，v1.0，新增加
        %   20180405，为biblatexv3.10版本，出现多出点bug做处理，Hu Zhenzhen
        %
        %   原理方法:加上printtext避免破坏异步标点机制
        %
        \newbibmacro*{newsdate}{%%
        \printtext{\blx@isodate{}{}}%%
        }
        \end{texlist}

    \item beamer中标题后面的标点情况，beamer对bibmacro\{title\}做了patch以实现特殊的效果。比如:
    \begin{texlist}
    \pretocmd{\abx@macro@title}
       {\ifcsundef{abx@name@labelname}{}{\let\bbx@tempa\labelnamepunct}%
        \bbx@tempa\newblock\unspace\usebeamercolor[fg]{bibliography entry title}}{}{}
    \apptocmd{\abx@macro@title}
       {\ifcsundef{abx@field@title}{}{\ifpunct{}{\midsentence\newunitpunct}}
        \newblock\unspace\usebeamercolor[fg]{bibliography entry note}}{}{}
    \end{texlist}
    该patch详见beamerbaselocalstructure.sty文件。需要注意\verb|abx@field@title|，在biblatex中是有newbibmacro\{title\}产生的。注意到在apptocmd做的patch中，midsentence命令隐藏了其前面的标点并重新做标点最终，因此其后的newunitpunct命令必将输出标点，因此无论如何标题后面必然会出现一个newunitpunct控制的标点，这个标点一般情况下是可以用的，但是对于有些文献类型比如inbook，析出文献标题后面没有标点只有//，因此需要将该标点去掉，所以需要反处理该patch。
    通过测试表明，无论是在title前再做pretocmd或者在title后再做apptocmd 都会产生问题，多个的apptocmd的机制大体是前一个做完后，后一个在其基础上处理，而apptocmd主要做的是封装，因此前一个产生的效果无法消除。但通过思考发现，使用patchcmd 可以对前面的效果产生影响，它不是封装而是一种替换，所以可以将前面封装的效果去掉。比如:
    \begin{texlist}
    %
    %   文献标题后的标点问题
    %   20180405，v1.0k，为texlive2017以上版本中的beamer兼容性做的处理，Hu Zhenzhen
    %
    %   原理方法:如下代码处理texlive2017以上版本中，beamer中文献的标题后出现两个点的情况:
    %   texlive2017以上的beamer中对macro{title}做了patch，正常情况下不会出现两个点的情况，但由于
    %   之前为了处理texlive2015，2016下的title格式添加了adddot，导致出现两个点的情况，而且也影响
    %   析出文献的//符号的输出，因此再次对macro{title}做patch消除beamer中做apptocmd时添加的\newunitpunct
    \ifboolexpr{%
        test{\iftoggle{iftlfive}}
        or
        test{\iftoggle{iftlsix}}
      }{}%
      {%texlive 2017对应iftlseven以上版本
      \DeclareFieldFormat{title}{#1}%
      \DeclareFieldFormat[article,patent,thesis,unpublished]{title}{#1}
      \AtBeginDocument{%
      \@ifclassloaded{beamer}
        {\patchcmd{\abx@macro@title}{\newunitpunct}{}{}{}}{}}
      }
    \end{texlist}

  \end{enumerate}



\subsubsection{动态数据修改}
利用biber在处理数据源时的动态处理，可以处理一些数据，比如设置一些域的值用于进一步的判断和应用；也可以用来进行中英文判断；也可以用来处理关联条目等等。

\paragraph{基本原理和方法}
biber动态数据处理，详见biblatex说明文档Dynamic Modification of Data一节和bbx文件中DeclareSourcemap的内容。
  \begin{enumerate}
    \item map的作用，对条目逐条进行处理
    \item final作用，当不成立map终止。
    \item append的作用，给域添加信息
    \item origfieldvalue来源
    \item overwite选项有无的作用，无overwite时，只要域原有信息，那么就不再map，有overwite时，则进行覆盖。\bc{注意:使用append的时候也需要overwite选项}。
    \item biblatex3.4以后的版本可以使用foreach选项，而3.0版只能一个域一个域的处理，意味着每一个域处理都要写一个map 步。
    \item date域仅作为解析用，不出现在bbl文件中，所以在bbx内部进行日期判断的时候要注意，不使用date 域而要用由其解析出来的year 等域进行判断，而且当date域的内容不符合解析格式要求时，自动忽略掉，那么信息有可能丢失，因此当有不符合解析格式的日期信息时应放到year 域中。
    \item 动态数据处理中利用正则表达式可以用来处理特殊字符，对于参考文献信息中一些特殊字符比如\&等，除了利用jabref软件的biblatex 可以自动转换外，利用动态数据修改也可以做一定的处理，比如对一些容易出现这种字符的域进行处理，使其内容符合tex源文件书写规则，即在特殊字符前加上斜杠。注意利用正则表达式处理\%，\#时直接在regexp中写字符没有问题，但是对于\&字符就存在问题，所以对于该字符使用十六进制表示方法\verb|\x26|。 比如:



    \begin{texlist}
    %for texlive >2016
    \DeclareStyleSourcemap{
        \maps[datatype=bibtex]{
            \map[overwrite, foreach={title,booktitle,journaltitle,journal,publisher,address,location,institution,organization}]{
                \step[fieldsource=\regexp{$MAPLOOP}, match=\regexp{([^\\])\#}, replace=\regexp{$1\\\#}]
            }
            \map[overwrite, foreach={title,booktitle,journaltitle,journal,publisher,address,location,institution,organization}]{
                \step[fieldsource=\regexp{$MAPLOOP}, match=\regexp{([^\\])\%}, replace=\regexp{$1\\\%}]
            }
            \map[overwrite, foreach={title,booktitle,journaltitle,journal,publisher,%
            address,location,institution,organization}]{
                \step[fieldsource=\regexp{$MAPLOOP}, match=\regexp{([^\\])\x26}, replace=\regexp{$1\\\x26}]
            }
        }
    }

    %for texlive 2015
    \DeclareStyleSourcemap{
        \maps[datatype=bibtex]{
            \map[overwrite]{%title,booktitle,journaltitle,journal,publisher,address,location,institution,organization
            \step[fieldsource={title}, match=\regexp{([^\\])\x26}, replace=\regexp{$1\\\x26}]
            }
            \map[overwrite]{
            \step[fieldsource={booktitle}, match=\regexp{([^\\])\x26}, replace=\regexp{$1\\\x26}]
            }
            \map[overwrite]{
            \step[fieldsource={journaltitle}, match=\regexp{([^\\])\x26}, replace=\regexp{$1\\\x26}]
            }
            \map[overwrite]{
            \step[fieldsource={journal}, match=\regexp{([^\\])\x26}, replace=\regexp{$1\\\x26}]
            }
            \map[overwrite]{
            \step[fieldsource={publisher}, match=\regexp{([^\\])\x26}, replace=\regexp{$1\\\x26}]
            }
            \map[overwrite]{
            \step[fieldsource={address}, match=\regexp{([^\\])\x26}, replace=\regexp{$1\\\x26}]
            }
            \map[overwrite]{
            \step[fieldsource={location}, match=\regexp{([^\\])\x26}, replace=\regexp{$1\\\x26}]
            }
            \map[overwrite]{
            \step[fieldsource={institution}, match=\regexp{([^\\])\x26}, replace=\regexp{$1\\\x26}]
            }
            \map[overwrite]{
            \step[fieldsource={booktitle}, match=\regexp{([^\\])\#}, replace=\regexp{$1\\\#}]
            }
            \map[overwrite]{
            \step[fieldsource={booktitle}, match=\regexp{([^\\])\%}, replace=\regexp{$1\\\%}]
            }
        }
    }
    \end{texlist}

  \end{enumerate}

\paragraph{数据模型}
  下面介绍biblatex数据模型与动态数据处理的关系。

  biblatex提供了数据模型定义功能，这在真正需要定义一些新的条目类型和域时是用得到的。但实际上，从本样式实践的经验看，为了biblatex 的兼容性考虑，没有必要使用数据模型定义功能去费力地定义新的条目类型，反而直接利用动态数据处理来将bib 中的一些类型转换成biblatex 支持的类型会更方便，其中要做一定的区分可以利用一些域的信息进行判断，比如note域等于news 或standard。
  \begin{enumerate}
      \item biblatex默认做的别名处理其实是用DeclareDriverSourcemap做的，这是驱动层的映射。在本样式中，因为usera域是在用户层的映射中做的，所以biblatex做的默认别名处理还不够，还需要在用户层首先处理usera域。而因为DeclareDriverSourcemap 中会增加一些不需要的信息，比如thesis类型中的typer域在GB/T7714标准中是并不需要的，这可以利用DeclareSourcemap，DeclarestyleSourcemap(\bc{注意texlive2016 的biblatex3.4 仅支持1 个styleSourcemap，而biblatex3.7则已经支持多个styleSourcemap})先进行映射，这样就避开了DeclareDriverSourcemap。 或者在增加DeclareDriverSourcemap，将标准样式中的默认DeclareDriverSourcemap增加的信息去掉(详见gb7714-2015ay.bbx中的处理和说明)。

    \begin{texlist}
    \DeclareStyleSourcemap{
        \maps[datatype=bibtex]{
    %        \map{%尝试未定义数据模型的newspaper类型映射为article，newspaper完全是针对gb7714的新类型，在biblatex中完全没有定义
    %             %但从实践看，并没有什么影响，映射过来就可以了。这一段可以用下面的驱动层别名映射替代，所以这里注释掉用下面的\DeclareBibliographyAlias命令
    %        \step[typesource=newspaper, typetarget=article, final]
    %        }
            \map{%尝试未定义数据模型的standard类型映射为book，standard类型在blx-dm中有出现，但仅定义了类型，域和约束等都没有定义
            \step[fieldsource=booktitle,final]%当存在booktitle域是映射为inbook
            \step[typesource=standard, typetarget=inbook, final]
            }
            \map{%尝试未定义数据模型的standard类型映射为book，standard类型在blx-dm中有出现，但仅定义了类型，域和约束等都没有定义
            \step[typesource=standard, typetarget=book, final]%当不存在booktitle 域是映射为book
            }
            \map{%先于标准样式的driver层映射，将其先映射过来，并取消type设置
            \step[typesource=mastersthesis, typetarget=thesis, final]
            %\step[fieldset=type, fieldvalue=mathesis]
            }
            \map{%先于标准样式的driver层映射，将其先映射过来，并取消type设置
            \step[typesource=phdthesis, typetarget=thesis, final]
            %\step[fieldset=type, fieldvalue=phdthesis]
            }
            \map{%先于标准样式的driver层映射，将其先映射过来，并取消type设置
            \step[typesource=techreport, typetarget=report, final]
            %\step[fieldset=type, fieldvalue=techreport]
            }
        }
    }
    \DeclareBibliographyAlias{newspaper}{article}%定义驱动别名，尝试以替代驱动层映射，实践表明是可行的。
    \end{texlist}

      \item 数据模型在blx-dm.DEF中，可以看到standard有条目类型定义，但域和约束没有定义，而biblatex标准样式默认做的别名处理中的其它一些条目比如electronic等是有域和约束定义的。
      \item 标准样式standard.BBX中的DeclareBibliographyAlias\{*\}\{misc\} 将一些数据模型中没有定义的条目直接用misc条目的驱动处理，这不是驱动层的数据源映射，只是利用其驱动进行输出。有一个问题是DeclareBibliographyAlias\{newspaper\}\{article\}是否可以实现？还是要定义数据模型？从实践结果看是不需要定义数据模型的，并且驱动的别名处理等价于驱动层映射。比如:
          做了用户层映射后:
          \begin{texlist}
          \DeclareSourcemap{
            \maps[datatype=bibtex]{%增加文献标识符如[M],[J]等，下面首先生成这一信息
                \map{
                    \pertype{newspaper}%增加一个新闻报纸的类型newspaper
                    \step[fieldset=usera, fieldvalue={N}]%因为没有专门的驱动，这句的目的是定义一个usera域，方便映射为article 后判断
                    \step[fieldset=note, fieldvalue=news]
                    }
                }
            }
            \end{texlist}

            做别名处理:
            \begin{texlist}
            \DeclareBibliographyAlias{newspaper}{article}%定义驱动别名，以替代驱动层映射
            \end{texlist}

            能达到驱动层或样式层中条目类型转换所实现的效果。
            \begin{texlist}
            \DeclareStyleSourcemap{
                \maps[datatype=bibtex]{
                    \map{%尝试未定义数据模型的newspaper类型映射为article，newspaper完全是针对gb7714的新类型，在biblatex 中完全没有定义
                         %但从实践看，并没有什么影响，映射过来就可以了。
                    \step[typesource=newspaper, typetarget=article, final]
                    }
                }
            }
            \end{texlist}

      \item 从实践看，数据模型中完全没有定义的条目类型newspaper也可以进行数据源映射。
  \end{enumerate}

\paragraph{用于关联条目的动态修改的命令封装及关联条目格式}

实现动态的条目关联，可以利用动态数据修改的方法。要对多个条目实现关联，那么需要多次数据映射，biblatex3.7及以上版本可以存在多个DeclareStyleSourcemap，因此做关联的封装命令就是基于此:

\begin{texlist}
    \newcommand{\defdoublelangentry}[2]{%
    \edef\entrykeya{#1}
    \edef\entrykeyb{#2}
        \DeclareStyleSourcemap{
          \maps[datatype=bibtex]{
            \map{
              \step[fieldsource=entrykey, match=\entrykeya, final]
              \step[fieldset=related, fieldvalue=\entrykeyb]
            }
          }
       }
    }
\end{texlist}

命令defdoublelangentry有两个输入参数，第一个是主条目，第二个是与主条目关联的条目的列表。多次使用该命令，即可实现多次数据映射，当然因为DeclareStyleSourcemap只能存在于导言区，因此defdoublelangentry也只能存在于导言区。

关联条目之间用命令relateddelim分隔，但实际上因为related宏输出时，不知道是何原因考虑的是主条目的关联条目之间的分隔，这在双语文献中是有问题的，需要在主条目后也进行分隔，因此对该宏修改如下:

\begin{texlist}
\renewbibmacro*{related}{%
  \ifboolexpr{ test {\iffieldundef{related}} or test {\ifrelatedloop} }
    {}
    {\usebibmacro{begrelated}%
     \def\bbx@tempa{}%
     \setcounter{bbx:relatedtotal}{0}%
     \def\do##1{%
       \entrydata{##1}{%
         \ifrelatedloop
           {}
           {\stepcounter{bbx:relatedtotal}%
            \gappto{\bbx@tempa}{##1,}}}}%
     \docsvfield{related}%
     \restorefield{related}{\bbx@tempa}%
     \ifnumgreater{\value{bbx:relatedtotal}}{0}
       {\listcsxadd{bbx:relatedloop}{\strfield{entrykey}}%
        \iffieldundef{clonesourcekey}
          {}
          {\listcsxadd{bbx:relatedloop}{\strfield{clonesourcekey}}}%
        \setcounter{bbx:relatedcount}{0}%
        \def\do{%
          \stepcounter{bbx:relatedcount}%
          \ifnumgreater{\value{bbx:relatedcount}}{0}%为使主条目与关联条目做分隔，这里做修改，从1改为0
            {\ifcsundef{relateddelim\strfield{relatedtype}}
              {\printtext{\relateddelim}}
              {\printtext{\csuse{relateddelim\strfield{relatedtype}}}}}
            {}}%
        \ifbibmacroundef{related:\strfield{relatedtype}}
          {\appto{\do}{\usebibmacro{related:default}}}
          {\appto{\do}{\usebibmacro*{related:\strfield{relatedtype}}}}%
        \iffieldformatundef{related:\strfield{relatedtype}}
          {\def\bbx@tempa{related}}
          {\def\bbx@tempa{related:\strfield{relatedtype}}}%
        \iffieldformatundef{relatedstring:\strfield{relatedtype}}
          {\def\bbx@tempb{relatedstring:default}}
          {\def\bbx@tempb{relatedstring:\strfield{relatedtype}}}%
        \printtext[\bbx@tempa]{%
          \usebibmacro{begrelatedloop}%
          \iffieldundef{relatedstring}
            {\ifboolexpr{
               test {\ifnumgreater{\value{bbx:relatedtotal}}{1}}
               and
               test {\ifbibxstring{\thefield{relatedtype}s}}
             }
               {\printtext[\bbx@tempb]{%
                  \bibstring[\mkrelatedstring]{\thefield{relatedtype}s}}}
               {\iffieldbibstring{relatedtype}
                  {\printtext[\bbx@tempb]{%
                     \bibstring[\mkrelatedstring]{\thefield{relatedtype}}}}
                  {}}}
            {\iffieldbibstring{relatedstring}
               {\printtext[\bbx@tempb]{%
                  \bibstring[\mkrelatedstring]{\thefield{relatedstring}}}}
               {\printfield[\bbx@tempb]{relatedstring}}}%
          \docsvfield{related}%
          \usebibmacro{endrelatedloop}}}%
       {}%
     \usebibmacro{endrelated}}}
\end{texlist}

\subsubsection{标注样式的设计途径}
针对GB/T 7714-2015标注，设定相应的选项，其中考虑不同biblatex版本带来的变化。同时也修改或增加用于实现标准要求的标注命令。

标注命令定义使用DeclareCiteCommand命令，设置上标，包围符号，标注前后内容等。针对GB/T7714-2015中关于引用标注的特殊要求，增加了一些方便实现要求的命令比如pagescite、yearpagescite等。具体的实现见gb*.cbx文件。

\paragraph{标签中的标点和间隔符号}
文献表中的标签和正文中的标注标签都有标点和间隔符号问题，但两者可能存在一定的差异，不同版本的biblatex中也可能不同，但新的版本中通常是可以用一个相同的钩子来实现的，比如作者年制中作者和年份之间的标点:
\begin{texlist}
\renewcommand*{\nameyeardelim}{\addcomma\space}
\end{texlist}

\paragraph{标注(引用)标签中的作者数量}
引用标签的生成机制，即责任者截短时的歧义消除问题，见说明文档4.11.4 Name Disambiguation 节。
  \begin{enumerate}
    \item uniquename的作用，用于姓名间的歧义消除。
    \item uniquelist的作用，用于姓名列表间的歧义消除。
  \end{enumerate}


关于这两个选项的参数设置，可以在样式中设置，也可以在宏包加载时设置，\bc{注意宏包加载时的设置会覆盖样式中的设置}。

还要注意，说明文档中uniquelist的默认选项是false，这是错误的，从实践看是true，从biblatex.sty文件的代码看也是如此，比如:
\begin{texlist}
\DeclareBibliographyOption[boolean]{uniquelist}[true]{%
  \ifcsdef{blx@opt@uniquelist@#1}
    {\letcs\blx@uniquelist{blx@opt@uniquelist@#1}}
    {\blx@err@invopt{uniquelist=#1}{}}}
\DeclareTypeOption[boolean]{uniquelist}[true]{%
  \ifcsdef{blx@opt@uniquelist@#1}
    {\letcs\blx@uniquelist{blx@opt@uniquelist@#1}}
    {\blx@err@invopt{uniquelist=#1}{}}}
\DeclareEntryOption[boolean]{uniquelist}[true]{%
  \ifcsdef{blx@opt@uniquelist@#1}
    {\letcs\blx@uniquelist{blx@opt@uniquelist@#1}}
    {\blx@err@invopt{uniquelist=#1}{}}}
\def\blx@opt@uniquelist@false{0}
\def\blx@opt@uniquelist@true{1}
\def\blx@opt@uniquelist@minyear{2}
\end{texlist}
无论选项是否给出，上面定义选项中的代码都会自动执行，当选项不给出，则自动调用默认的参数(因为代码中直接使用了输入参数，当没有输入参数，自然就会使用默认参数)来进行处理，显然这里是true。


\subsection{一个项目示例}
\subsubsection{介绍}
这是一个国内某期刊英文版的参考文献定制样式，项目不是很复杂，给出了两个示例，一是文献表示例(图\ref{fig:proj:bibl:ega})，二是引用标签示例(图\ref{fig:proj:cite:ega})。我们需要根据这两个示例来开发相应的样式，即bbx和cbx文件。

\begin{figure}[!htb]
  \centering
  \includegraphics[width=0.9\textwidth]{project-ega-bibliography.png}
  \caption{定制项目文献表示例}\label{fig:proj:bibl:ega}
\end{figure}

\begin{figure}[!htb]
  \centering
  \includegraphics[width=0.5\textwidth]{project-ega-citation.png}
  \caption{定制项目引用标签示例}\label{fig:proj:cite:ega}
\end{figure}

相比之下，这种只有有限示例，而没有像GB/T7714-2015标准那样详细规定的样式，开发起来会自由一些，因为只要实现示例中的格式即可，未定义的作者可以自己把握，而不需要详细测试每一条规定。此外因为该格式只有英文文献，语言只有英文，也不存在多语言的问题。但该格式也有一些有挑战的东西，特别是引用标签与文献表的作者标签存在明显不同，对于使用相同钩子的两个标签，可能需要特别的处理，以实现不同的格式。

参考文献样式的定制前面已经有了初步介绍，详见\ref{sec:style:def}节，本项目开发也是类似的，关于定制的基本方法不再赘述，下面主要介绍定制需要的所有功能是如何实现的。

\subsubsection{bbx文件开发}
如前所述，biblatex样式文件开发方法，有一个非常便捷的方式是基于标准样式进行。这种方式不仅相对简单，而且对biblatex的兼容性也更好。当biblatex升级时，除非有api改动，绝大多数情况下可以不用修改即可复用。

在本项目开发中，可以看到参考文献表的样式与标准样式很像，因此完全可以在其基础上进行开发，同时还可以利用gb7714-2015ay样式，其中有不少符合中文规范的处理。本项目主要利用这两个样式的代码进行开发。

\paragraph{文献表环境}

看文献表的第一眼可以观察到各条目的缩进格式，即第一行顶格，第二行开始缩进约3个字母宽度，这是由biblatex参考文献环境控制，通常是list环境构建，设置合适的参数就可以实现目标。

\begin{codetex}{重定义参考文献环境确定缩进}{eg:proj:bibenv}
%=====================================================================
%参考文献列表环境
%=====================================================================
  \defbibenvironment{bibliography}%修改参考文献列表环境，不要缩进
  {\list
     {}
     {%\setlength{\leftmargin}{\bibhang}%
      %\setlength{\itemindent}{-\leftmargin}%
      \setlength{\leftmargin}{1.5em}%
      \setlength{\itemindent}{-1.5em}%
      \setlength{\itemsep}{\bibitemsep}%
      \setlength{\parsep}{\bibparsep}}}
  {\endlist}
  {\item}
\end{codetex}

\paragraph{作者域处理}
接着我们看示例中个条目类型相同的部分，主要是作者和页码。这里先处理作者域。显然，作者标签有点像中文风格，姓在前，名的缩写为大小首字母，且没有加点。firstname和givenname之间没有空格，姓的后面也没有标点，姓的首字母大写，其它小写。这种格式与gb7714-2015的风格有点像，可以复用其代码，略作大小写修改，同时使用几个钩子将标点和空格处理完毕。

\begin{codetex}{作者域处理}{eg:proj:author}
\renewrobustcmd*{\bibinitperiod}{}
\renewcommand*{\revsdnamepunct}{\space}
\renewcommand*{\bibnamedelimd}{}
\renewcommand*{\bibnamedelima}{}
\renewcommand*{\bibinitdelim}{}

\renewbibmacro*{author}{%
  \ifboolexpr{
    test \ifuseauthor
    and
    not test {\ifnameundef{author}}
  }
    {\usebibmacro{bbx:dashcheck}
       {%\bibnamedash
       \printnames{author}%
       }%
       {\usebibmacro{bbx:savehash}%
        \printnames{author}%
        \iffieldundef{authortype}
          {\setunit{\addspace}}
          {\setunit{\addcomma\space}}}%
     \iffieldundef{authortype}
       {}
       {\usebibmacro{authorstrg}%
        \setunit{\addspace}}}%
    {\global\undef\bbx@lasthash
     \usebibmacro{labeltitle}%
     \setunit*{\addspace}}%
     \setunit{\addcomma\space}%增加一个逗号
  \usebibmacro{date+extrayear}
  }

%biblatex3.3版后(比如texlive2016中的3.4版)的使用方式
\renewbibmacro*{name:given-family}[4]{%利用family-given定义given-family
  \ifuseprefix
    {\usebibmacro{name:delim}{#3#1}%
     \usebibmacro{name:hook}{#3#1}%
     \ifdefvoid{#3}{}{%
       \ifcapital
         {\mkbibnameprefix{\MakeCapital{#3}}\isdot}
         {\mkbibnameprefix{#3}\isdot}%
       \ifprefchar{}{\bibnamedelimc}}%
     \ifdefvoid{#2}{\mkbibnamefamily{\MakeCapital{#1}}}{\mkbibnamefamily{\MakeSentenceCase{#1}}}\isdot
     \ifdefvoid{#2}{}{\revsdnamepunct\bibnamedelimd\mkbibnamegiven{\MakeUppercase{#2}}\isdot}%\MakeCapital{#2}
     \ifdefvoid{#4}{}{\bibnamedelimd\mkbibnamesuffix{#4}\isdot}}
    {\usebibmacro{name:delim}{#1}%
     \usebibmacro{name:hook}{#1}%
     \ifdefvoid{#2}{\mkbibnamefamily{\MakeCapital{#1}}}{\mkbibnamefamily{\MakeSentenceCase{#1}}}\isdot
     %
     \ifboolexpe{%
       test {\ifdefvoid{#2}}
       and
       test {\ifdefvoid{#3}}}
       {}
       {\revsdnamepunct}%
     \ifdefvoid{#2}{}{\bibnamedelimd\mkbibnamegiven{\MakeUppercase{#2}}\isdot}%\MakeCapital{#2}
     \ifdefvoid{#3}{}{\bibnamedelimd\mkbibnameprefix{#3}\isdot}
     \ifdefvoid{#4}{}{\bibnamedelimd\mkbibnamesuffix{#4}\isdot}}}

\renewbibmacro*{name:family-given}[4]{%利用family-given定义given-family
  \ifuseprefix
    {\usebibmacro{name:delim}{#3#1}%
     \usebibmacro{name:hook}{#3#1}%
     \ifdefvoid{#3}{}{%
       \ifcapital
         {\mkbibnameprefix{\MakeCapital{#3}}\isdot}
         {\mkbibnameprefix{#3}\isdot}%
       \ifprefchar{}{\bibnamedelimc}}%
     \ifdefvoid{#2}{\mkbibnamefamily{\MakeCapital{#1}}}{\mkbibnamefamily{\MakeSentenceCase{#1}}}\isdot
     \ifdefvoid{#2}{}{\revsdnamepunct\bibnamedelimd\mkbibnamegiven{\MakeUppercase{#2}}\isdot}%\MakeCapital{#2}
     \ifdefvoid{#4}{}{\bibnamedelimd\mkbibnamesuffix{#4}\isdot}}
    {\usebibmacro{name:delim}{#1}%
     \usebibmacro{name:hook}{#1}%
     \ifdefvoid{#2}{\mkbibnamefamily{\MakeCapital{#1}}}{\mkbibnamefamily{\MakeSentenceCase{#1}}}\isdot
     %
     \ifboolexpe{%
       test {\ifdefvoid{#2}}
       and
       test {\ifdefvoid{#3}}}
       {}
       {\revsdnamepunct}%
     \ifdefvoid{#2}{}{\bibnamedelimd\mkbibnamegiven{\MakeUppercase{#2}}\isdot}%%\MakeCapital{#2}
     \ifdefvoid{#3}{}{\bibnamedelimd\mkbibnameprefix{#3}\isdot}
     \ifdefvoid{#4}{}{\bibnamedelimd\mkbibnamesuffix{#4}\isdot}}}
\end{codetex}

此外，多个姓名之间用逗号分隔，最后一个姓名前不用and，而使用逗号，可以通过使用钩子以及处理本地化字符串and来实现。
\begin{codetex}{本地化字符串处理}{eg:proj:localbibstr}
\DefineBibliographyStrings{english}{
and         = {\addcomma},%将第2和3人名见的and符号改成 逗号，用\finalnamedelim命令也可以定义，参见3.9.1节
byeditor    = {\mkbibparens{Eds\adddot\isdot}},
urlseen     = {Accessed on},
january          = {Jan\adddot},
february         = {Feb\adddot},
  march            = {Mar\adddot},
  april            = {Apr\adddot},
  may              = {May},
  june             = {June},
  july             = {July},
  august           = {Aug\adddot},
  september        = {Sept\adddot},
  october          = {Oct\adddot},
  november         = {Nov\adddot},
  december         = {Dec\adddot},
}
\end{codetex}

\paragraph{条目类型及其使用的域}

接下来我们首先来看一下示例中所给出的条目类型(表\ref{tab:proj:entrytypes})及其所使用的域。
\begin{table}[!hbtp]
\centering
\caption{支持的条目类型}\label{tab:proj:entrytypes}
\begin{tabular}{|l|c|l|}
  \hline
  % after \\: \hline or \cline{col1-col2} \cline{col3-col4} ...
  entry type  &  & references \\ \hline
article                        & for & journals' paper \\
inproceedings                  & for & proceedings' paper\\
book                           & for & whole books\\
inbook                         & for & monographs or chapters in edited books\\
report                         & for & reports\\
thesis/phdthesis/masterthesis  & for & thesis\\
patent                         & for & patents\\
standard                       & for & standards\\
online/www                     & for & websites  \\
  \hline
\end{tabular}
\end{table}

根据对各条目内容的分析可以得到各条目使用的域为:
\begin{codetex}{各条目使用的域}{eg:proj:fields}
article:
author,date or year.title.journaltitle,volume(number),pages.doi

inproceedings:
author,date or year.title.booktitle.publisher,address or location,pages

book:
author,date or year.title.edition.publisher,address or location,pages

inbook:
author,date or year.title.editor or bookauthor.booktitle.edition.publisher,address or location,pages

report:
author,date or year.title.publisher,address or location.type or number,pages

thesis/phdthesis/masterthesis:
author,date or year.title.type.institution,address or location,pages

patent:
author,date or year.title.number

standard:
author,date or year.title.translator.publisher,address or location,pages

online/www:
author,date or year.title.organization.url.urldate
\end{codetex}

\paragraph{article类型处理}
article条目中，标题为正常字体，期刊名为斜体，卷为粗体，期用圆括号包围，页码前面的符号为逗号，无引导词如pp.，而且doi需要换行。

修改期刊名钩子，卷期定义一个新的域格式，调整页码的引导符，修改doi格式，可以处理完成。
\begin{codetex}{article条目处理}{eg:proj:article}
\DeclareFieldFormat{journaltitle}{\mkbibitalic{#1}\isdot}%添加\isdot，用于缩写名带点情况，将其转换为缩写点便于标点追踪
\DeclareFieldFormat%将期刊等文献的标题中原来带的引号去掉
  [article,patent,unpublished,incollection,inproceedings,inbook]
  {title}{#1\adddot\addthinspace}
\DeclareFieldFormat{titlecase}{\MakeCapital#1}%重设标题格式，将其修改为首字母大写

\DeclareFieldFormat{pages}{#1}%去掉前面引导页码的pp.等字符

\DeclareFieldFormat{addnumflag}{%%增加一个number带括号的格式，避免使用mkbibparens而引入一个不必要的空格
\nobreak\printtext{(}\nobreak #1\nobreak\printtext{)}}
\DeclareFieldFormat{addvolflag}{\mkbibbold{#1}}

\renewbibmacro*{journal+issuetitle}{%
  \usebibmacro{journal}%
  \setunit*{\addspace}%
  \iffieldundef{series}
    {\setunit{\addcomma\addspace}}
    {\newunit
     \printfield{series}%
     \setunit{\addcomma\addspace}}%
  \usebibmacro{volume+number+eid}%
  \setunit{\addcomma\addspace}%
  \usebibmacro{issue+date}%
  \setunit{\addcolon\space}%
  \usebibmacro{issue}%
  \newunit}

\newbibmacro*{journal}{%
  \iffieldundef{journaltitle}
    {}
    {\printtext[journaltitle]{%
       \printfield{journaltitle}%
       \setunit{\subtitlepunct}%
       \printfield{journalsubtitle}}}}

%调整期刊卷和期的格式，
\renewbibmacro*{volume+number+eid}{%
  \printfield[addvolflag]{volume}%
  %\setunit*{\adddot}%去掉点号
  %\printfield{number}%
  \iffieldundef{number}{}{\printfield[addnumflag]{number}}%
  %\iffieldundef{number}{}{\printtext{\mkbibparens{\printfield{number}}}}% 增加一个圆括号
  \iffieldundef{eid}{}{%
  \setunit{\addcomma\space}%
  \printfield{eid}}}

\renewbibmacro*{doi+eprint+url}{%
  \iftoggle{bbx:eprint}
    {\usebibmacro{eprint}}
    {}%
  \newunit\newblock
  \iftoggle{bbx:url}
    {\usebibmacro{url+urldate}}
    {}
  \newunit\newblock
  \iftoggle{bbx:doi}
    {\iffieldundef{doi}{}{\printtext{\newline}}\printfield{doi}}%注意这里printtext的运用，避免前面点的跳行
    {}}

%修改article的驱动，期刊文章，连续出版物中的析出文献的格式
\DeclareBibliographyDriver{article}{%
  \usebibmacro{bibindex}%
  \usebibmacro{begentry}%
  \usebibmacro{author/translator+others}%
  \setunit{\printdelim{nametitledelim}}\newblock
  \usebibmacro{title}%
  \newunit
  \printlist{language}%
  \newunit\newblock
  \usebibmacro{byauthor}%
  \newunit\newblock
  \usebibmacro{bytranslator+others}%
  \newunit\newblock
  \printfield{version}%
  \newunit\newblock
  %\usebibmacro{in:}%
  \usebibmacro{journal+issuetitle}%
  \newunit
  \usebibmacro{byeditor+others}%
  \newunit
  \usebibmacro{note+pages}%
  \newunit\newblock
  \iftoggle{bbx:isbn}
    {\printfield{issn}}
    {}%
  \newunit\newblock
  \usebibmacro{doi+eprint+url}%
  \newunit\newblock
  \usebibmacro{addendum+pubstate}%
  \setunit{\bibpagerefpunct}\newblock
  \usebibmacro{pageref}%
  \newunit\newblock
  \iftoggle{bbx:related}
    {\usebibmacro{related:init}%
     \usebibmacro{related}}
    {}%
  \usebibmacro{finentry}}
\end{codetex}

\paragraph{inproceedings类型处理}

标题为正常字体，文集名为斜体，需要出版项，同时观察book，report类型可以发现，出版项中，出版者在前，出版地在后，中间逗号连接，出版者缺省时不输出。

修改文集名的钩子，修改出版项格式，页码由前面的article中做的全局处理实现。注意到文集名后出版项前的符号是逗号，但这里使用了点号，因为作者认为这样更合理，不同信息块之间通常是由点分隔，示例中绝大部分情况都是如此。当然用逗号分隔也没有任何难度，只需在驱动中出版项前加入一个逗号标点即可。
\begin{codetex}{inproceedings条目处理}{eg:proj:inproceedings}
\DeclareFieldFormat{maintitle}{\mkbibemph{#1}}
\DeclareFieldFormat{booktitle}{\mkbibemph{#1}}
\DeclareFieldFormat%将期刊等文献的标题中原来带的引号去掉
  [article,patent,unpublished,incollection,inproceedings,inbook]
  {title}{#1\adddot\addthinspace}

\renewbibmacro*{publisher+location+date}{%
\printlist{publisher}
\iflistundef{location}{}{\setunit*{\addcomma\space}}%
  \printlist{location}%%
  \setunit*{\addcomma\space}%
  \usebibmacro{date}%
  \newunit}

%会议论文格式修改
\DeclareBibliographyDriver{inproceedings}{%
  \usebibmacro{bibindex}%
  \usebibmacro{begentry}%
  \usebibmacro{author/translator+others}%
  \setunit{\printdelim{nametitledelim}}\newblock
  \usebibmacro{title}%
  \newunit
  \printlist{language}%
  \newunit\newblock
  \usebibmacro{byauthor}%
  \newunit\newblock
  %\usebibmacro{in:}%
  \usebibmacro{maintitle+booktitle}%
  \newunit\newblock
  \usebibmacro{event+venue+date}%
  \newunit\newblock
  \usebibmacro{byeditor+others}%
  \newunit\newblock
  \iffieldundef{maintitle}
    {\printfield{volume}%
     \printfield{part}}
    {}%
  \newunit
  \printfield{volumes}%
  \newunit\newblock
  \usebibmacro{series+number}%
  \newunit\newblock
  \printfield{note}%
  \newunit\newblock
  \printlist{organization}%
  \newunit
  \usebibmacro{publisher+location+date}%
  \newunit\newblock
  \usebibmacro{chapter+pages}%
  \newunit\newblock
  \iftoggle{bbx:isbn}
    {\printfield{isbn}}
    {}%
  \newunit\newblock
  \usebibmacro{doi+eprint+url}%
  \newunit\newblock
  \usebibmacro{addendum+pubstate}%
  \setunit{\bibpagerefpunct}\newblock
  \usebibmacro{pageref}%
  \newunit\newblock
  \iftoggle{bbx:related}
    {\usebibmacro{related:init}%
     \usebibmacro{related}}
    {}%
  \usebibmacro{finentry}}
\end{codetex}

\paragraph{book类型处理}
书名为斜体，出版项使用与inproceedings一致的全局处理。驱动无需修改使用标准样式提供的即可。
\begin{codetex}{book条目处理}{eg:proj:book}
\DeclareFieldFormat%
  [book,report,thesis]
  {title}{\mkbibemph{#1}}
\end{codetex}


\paragraph{inbook类型处理}
章节名正常字体，全书名为斜体，同时全书还需要作者或编者，章节和书名之间用in:表示，出版项和页码使用前述的全局处理。
设置书名钩子，处理in的本地化字符串格式后，最重要是是全书编者中跟着的提示信息(Eds.)。这种提示信息常是由本地化字符串提供，显然eds表示编者，通常全书的作者还可以用bookauthor域表示，但这里为了体现eds信息，使用editor域，于是我们需要对editor域输出格式做修改，得到符合要求的结果。其中byeditor本地化字符串处理，见例\ref{eg:proj:localbibstr}。
\begin{codetex}{inbook条目处理}{eg:proj:inbook}
\DeclareFieldFormat{maintitle}{\mkbibemph{#1}}
\DeclareFieldFormat{booktitle}{\mkbibemph{#1}}

\renewbibmacro*{in:}{%
  \printtext{%
    \mkbibitalic{\bibstring{in}}\intitlepunct}}

\renewbibmacro*{byeditor+others}{%
  \ifnameundef{editor}
    {}
    {\printnames[byeditor]{editor}%
     \setunit{\addspace}%
     \usebibmacro{byeditor+othersstrg}%
     \clearname{editor}%
     \newunit}%
  \usebibmacro{byeditorx}%
  \usebibmacro{bytranslator+others}}

%修改inbook的驱动
\DeclareBibliographyDriver{inbook}{%
  \usebibmacro{bibindex}%
  \usebibmacro{begentry}%
  \usebibmacro{author/translator+others}%
  \setunit{\printdelim{nametitledelim}}\newblock
  \usebibmacro{title}%
  \newunit
  \printlist{language}%
  \newunit\newblock
  \usebibmacro{byauthor}%
  \newunit\newblock
  \usebibmacro{in:}%
  \usebibmacro{bybookauthor}%
  \newunit\newblock
  \usebibmacro{byeditor+others}%
  \newunit\newblock
  \usebibmacro{maintitle+booktitle}%
  \newunit\newblock
  \printfield{edition}%
  \newunit
  \iffieldundef{maintitle}
    {\printfield{volume}%
     \printfield{part}}
    {}%
  \newunit
  \printfield{volumes}%
  \newunit\newblock
  \usebibmacro{series+number}%
  \newunit\newblock
  \printfield{note}%
  \newunit\newblock
  \usebibmacro{publisher+location+date}%
  \newunit\newblock
  \usebibmacro{chapter+pages}%
  \newunit\newblock
  \iftoggle{bbx:isbn}
    {\printfield{isbn}}
    {}%
  \newunit\newblock
  \usebibmacro{doi+eprint+url}%
  \newunit\newblock
  \usebibmacro{addendum+pubstate}%
  \setunit{\bibpagerefpunct}\newblock
  \usebibmacro{pageref}%
  \newunit\newblock
  \iftoggle{bbx:related}
    {\usebibmacro{related:init}%
     \usebibmacro{related}}
    {}%
  \usebibmacro{finentry}}
\end{codetex}

\paragraph{report类型处理}
在report类中，标题为斜体，后面是出版项，和报告类型及编号。修改驱动调整出版项和报告类型的顺序。也要注意两者之间示例给出的逗号分隔符，这里作者仍然使用了点号，原因如前所述，不同信息块的分隔用点号，当然如果要改成逗号也非常简单。唯一需要注意的是，通常报告的出版者用institution域表示，所以对其做域publisher类似的处理。
\begin{codetex}{report条目处理}{eg:proj:report}
\DeclareFieldFormat%
  [book,report,thesis]
  {title}{\mkbibemph{#1}}

\renewbibmacro*{institution+location+date}{%
  \printlist{institution}%
  \iflistundef{location}{}{\setunit*{\addcomma\space}}%
  \printlist{location}%
  \setunit*{\addcomma\space}%
  \usebibmacro{date}%
  \newunit}

%report
\DeclareBibliographyDriver{report}{%
  \usebibmacro{bibindex}%
  \usebibmacro{begentry}%
  \usebibmacro{author}%
  \setunit{\printdelim{nametitledelim}}\newblock
  \usebibmacro{title}%
  \newunit
  \printlist{language}%
  \newunit\newblock
  \usebibmacro{byauthor}%
  \newunit\newblock
  \printfield{version}%
  \newunit
  \printfield{note}%
  \newunit\newblock
  \usebibmacro{institution+location+date}%
  \newunit\newblock
  \printfield{type}%
  \setunit*{\addspace}%
  \printfield{number}%
  \newunit\newblock
  \usebibmacro{chapter+pages}%
  \newunit
  \printfield{pagetotal}%
  \newunit\newblock
  \iftoggle{bbx:isbn}
    {\printfield{isrn}}
    {}%
  \newunit\newblock
  \usebibmacro{doi+eprint+url}%
  \newunit\newblock
  \usebibmacro{addendum+pubstate}%
  \setunit{\bibpagerefpunct}\newblock
  \usebibmacro{pageref}%
  \newunit\newblock
  \iftoggle{bbx:related}
    {\usebibmacro{related:init}%
     \usebibmacro{related}}
    {}%
  \usebibmacro{finentry}}
\end{codetex}

\paragraph{thesis类型处理}
标题是斜体，带论文类型，后面是出版项和页码。标题修改使用钩子，出版项和页码使用前述的全局设置。主要是论文类型。目前没有做任何的额外处理，因为biblatex自动会将phdthesis，masterthesis转换为thesis，并设置type。如果用户直接使用thesis，并且需要type信息，那么需要在type域中输入类型是phdthesis或masterthesis。

\paragraph{patent类型处理}
标题为正常字体，后面跟专利号。无需任何处理。

\paragraph{standard类型处理}
因为standard类型在biblatex中没有定义，因此需要增加一个standard类型的驱动，类似于book的驱动，只是标题改为正常字体。

\begin{codetex}{standard条目处理}{eg:proj:standard}
%增加标准的驱动
\DeclareBibliographyDriver{standard}{%
  \usebibmacro{bibindex}%
  \usebibmacro{begentry}%
  \usebibmacro{author/editor+others/translator+others}%
  \setunit{\printdelim{nametitledelim}}\newblock
  \usebibmacro{maintitle+title}%
  \newunit
  \printlist{language}%
  \newunit\newblock
  \usebibmacro{byauthor}%
  \newunit\newblock
  \usebibmacro{byeditor+others}%
  \newunit\newblock
  \printfield{edition}%
  \newunit
  \iffieldundef{maintitle}
    {\printfield{volume}%
     \printfield{part}}
    {}%
  \newunit
  \printfield{volumes}%
  \newunit\newblock
  \usebibmacro{series+number}%
  \newunit\newblock
  \printfield{note}%
  \newunit\newblock
  \usebibmacro{publisher+location+date}%
  \newunit\newblock
  \usebibmacro{chapter+pages}%
  \newunit
  \printfield{pagetotal}%
  \newunit\newblock
  \iftoggle{bbx:isbn}
    {\printfield{isbn}}
    {}%
  \newunit\newblock
  \usebibmacro{doi+eprint+url}%
  \newunit\newblock
  \usebibmacro{addendum+pubstate}%
  \setunit{\bibpagerefpunct}\newblock
  \usebibmacro{pageref}%
  \newunit\newblock
  \iftoggle{bbx:related}
    {\usebibmacro{related:init}%
     \usebibmacro{related}}
    {}%
  \usebibmacro{finentry}}
\end{codetex}

\paragraph{online类型处理}
最后是online类型，标题后跟的是组织，后面跟的是网址及其访问日期。主要要修改的是url和urldate的域格式。因为urldate域需要提供所有的年月日信息，所以设置urldate宏包选项，注意区别于date域的选项。同时因为其特殊的形式，修改月份的本地化字符串，如例\ref{eg:proj:localbibstr}所示。

\begin{codetex}{online条目处理}{eg:proj:online}
\ExecuteBibliographyOptions{
  useprefix = true,  %名字的信息包括前缀
  %firstinits = true,    %名字有缩写，参考3.1.2.3 Internal
  giveninits = true,
  date   = year,  %日期仅写到年
  urldate= comp,
  %maxnames     = 3 , %设置名字最大数量
  %minnames     = 3,  %设置缩减后的名字最小数量
  maxbibnames=3, %将文献列表和引用中最大名字数量区分开
  minbibnames=3,
}

\DeclareFieldFormat{url}{Available from\space\url{#1}}
\DeclareFieldFormat{urldate}{\mkbibbrackets{\bibstring{urlseen}\space#1}}
\end{codetex}

\paragraph{全局选项及texlive兼容性处理}
全局选项设置如例\ref{eg:proj:online}所示，使用类似于gb7714-2015的设置，使用姓名前缀和缩写，设置文献表中作者标签最大和最小姓名数为3。

对于biblatex的兼容性，因为升级可能带来的变化，这里特别做了处理，主要是texlive2016和texlive2017，其中的biblatex版本分别为3.4和3.7。对于本项目，其中有一个命令存在差异，因此换个版本会报错，因此特别做出处理，处理方式类似于gb7714-2015样式。

\begin{codetex}{texlive兼容性处理}{eg:proj:texlive}
\providetoggle{iftexlivesix}
\providetoggle{iftexliveseven}%为处理texlive2016到2017的变化
%版本判断，根据biblatex更新历史可知，版本3.3开始使用新的姓名机制
%所以当版本大于3.2开始，就用设置\toggletrue{iftexlivesix}
\def\numparserta#1.#2\relax{#1}%注意relax的重要性
\def\numparsertb#1.#2\relax{#2}
\def\numinteger{\expandafter\numparserta\abx@version\relax}
\def\numdigital{\expandafter\numparsertb\abx@version\relax}
\ifnumcomp{\numdigital}{>}{2}{\toggletrue{iftexlivesix}}{\togglefalse{iftexlivesix}}
\ifnumcomp{\numdigital}{>}{6}{\toggletrue{iftexliveseven}}{\togglefalse{iftexliveseven}}

\iftoggle{iftexliveseven}{%
  \renewbibmacro*{date+extrayear}{%
    \iffieldundef{labelyear}
      {}
      {\printtext{%[parens]%这里把括号去掉
         \iffieldsequal{year}{labelyear}
           {\printlabeldateextra}%
           {\printfield{labelyear}%
            \printfield{extrayear}}}}}%
}{%
\renewbibmacro*{date+extrayear}{%
    \iffieldundef{\thefield{datelabelsource}year}
      {}
      {\printtext{%[parens]%这里把括号去掉
         \iffieldsequal{year}{\thefield{datelabelsource}year}
           {\printdateextralabel}%
           {\printfield{labelyear}%
            \printfield{extrayear}}}}}%
}
\end{codetex}

如此完成了bbx文件的开发。

\subsubsection{cbx文件开发}
下面进行cbx文件开发。cbx引用标签样式示例给出了3个。分别是1位作者、2位、3位或以上作者的情况。可以看到2位作者时全部给出，超过3位则只给出一位，这可以通过设置宏包选项实现，例\ref{eg:proj:cbxopt}中给出的其它选项，与gb7714-2015相同。单个姓名的标签采用默认的方式处理，作者和年份之间的分隔符，修改对应的钩子即可。

\begin{codetex}{cbx设置宏包选项}{eg:proj:cbxopt}
\ExecuteBibliographyOptions{
  %autocite  = superscript ,
  %autopunct = true       ,
  %sorting   = none        ,
  maxcitenames=2,
  mincitenames=1,
  uniquename=init,%因为使用了名字缩写选项，所以需要设置uniquename=init而不是full避免冲突
  labeldate=true,
  uniquelist=minyear,
}

\DeclareDelimFormat{nameyeardelim}{\addcomma\addspace}
\end{codetex}

除此之外，还有几个格式需要实现，包括:
\begin{itemize}
  \item et al. 的斜体
  \item 两位作者时，and连接
  \item 同作者文献，连续出现，作者名只出现一次
\end{itemize}

这三个问题其实是本项目最复杂的地方。因为一般情况下，引用标签与文献表中的作者标签使用相同的钩子，因此格式相同。那么在文献表中作者格式确定的情况下，无法全局的重定义这些钩子，否则会影响文献表。

好在tex的作用域机制保证了重定义可以作用在局部范围内。于是重定义name:andothers宏来实现etal斜体，重定义finalnamedelim来实现and连接。但是作者省略的问题，还无法解决，思考解决方法，找到authoryear文献表中存在的省略，这里其实也可以复用其中的宏，于是新定义一个cite:labelname取代直接打印姓名的方式，重定义cite宏实现要求，最后重定义cite命令，在引用标签外加上圆括号。

\begin{codetex}{cbx重定义实现要求}{eg:proj:cbxredef}
\newbibmacro*{cite:labelname}{%
    \usebibmacro{bbx:dashcheck}%
       {}%\bibnamedash%
       {\usebibmacro{bbx:savehash}%
        \printnames{labelname}%
        \setunit{\printdelim{nameyeardelim}}}}

\renewbibmacro*{cite}{%
  \iffieldundef{shorthand}%
    {\ifthenelse{\ifnameundef{labelname}\OR\iffieldundef{labelyear}}%
       {\usebibmacro{cite:label}%
        \setunit{\printdelim{nonameyeardelim}}}%
       {\renewcommand*{\finalnamedelim}{%
  \ifnumgreater{\value{liststop}}{2}{\finalandcomma}{}%
  \addspace and\space}%
  \renewbibmacro*{name:andothers}{%
  \ifboolexpr{%
    test {\ifnumequal{\value{listcount}}{\value{liststop}}}
    and
    test \ifmorenames
  }%
    {\ifnumgreater{\value{liststop}}{1}%
       {\finalandcomma}%
       {}%
     \andothersdelim\mkbibemph{\bibstring{andothers}}}%
    {}}%
\usebibmacro{cite:labelname}%\printnames{labelname}%
}%
\usebibmacro{cite:labelyear+extrayear}}%
    {\usebibmacro{cite:shorthand}}}

%\DeclareCiteCommand{\cite}[\mkbibparens]{⟨precode⟩}{⟨loopcode⟩}{⟨sepcode⟩}{⟨postcode⟩}
%
\DeclareCiteCommand{\cite}[\mkbibparens]
  {\usebibmacro{prenote}}
  {\usebibmacro{citeindex}%
   \usebibmacro{cite}}
  {\multicitedelim}
  {\usebibmacro{postnote}}
\end{codetex}

到此，我们完成了所有的开发。

项目所有文档见:
\href{run:./exampleandimage/egzazhi.tex}{egzazhi.tex}，
\href{run:./exampleandimage/zazhi.bbx}{zazhi.bbx}，
\href{run:./exampleandimage/zazhi.cbx}{zazhi.cbx}，
\href{run:./exampleandimage/egbib.bib}{egbib.bib}。

结果如图\ref{fig:proj:res}所示。

\begin{figure}[!htb]
  \centering
  \includegraphics[width=0.9\textwidth,page=1]{egzazhi.pdf}
  \caption{样式定制结果}\label{fig:proj:res}
\end{figure}


\subsubsection{小结}
通过上述实践，我们完成了一个定制项目，可以看到biblatex的强大，它提供的api相当全面和有效，利用它以及标准样式可以较为方便构建满足需要的定制格式。

\subsection{样式定制中的一些技巧}

\subsubsection{选项的范围限制}

选项有不同的作用范围，包括Load-time、Global、Per-refcontext、Per-type、 Per-entry、Per-namelist、Per-name等，有时可以针对不同的需要来设置不同的选项作用范围，例就是一种针对条目类型的选项设置：

\begin{codetex}{针对条目类型的选项设置}{eg:opt:range}
\ExecuteBibliographyOptions[%
  book,%
  bookinbook,%
  bookinarticle,%
  bookincollection,%
  bookinincollection,%
  mvbook,%
  inbook,%
  bookininbook,%
  bookininarticle,%
  inreference,%
  bookinreference,%
  bookininreference%
  ]{useeditor=false,usetranslator=false}
\end{codetex}

\subsubsection{排序格式的宏重用}

排序格式用 DeclareSortingScheme(老版本biblatex)/DeclareSortingTemplate 定义，很多时候可以利用宏重用来精简代码，比如有多个不同的格式，其中仅有部分的差别，多数内容都是相同的，此时可以将相同的内容定义为宏，然后在不同的格式中重用，比如：

\begin{codetex}{排序格式中的宏重用}{eg:sort:scheme}
\def\bbx@sorting@reused{
  \sort{
    \field{sortname}
    \field{author}
    \field{editor}
    \field{translator}
    \literal{0000}
  }
  \sort{
    \field{sorttitle}
    \field{title}
  }
  \sort{
    \field{sortyear}
    \field{year}
  }
}

\DeclareSortingScheme{anonymous}{
  \sort{
    \field{presort}
  }
  \sort[final]{
    \field{sortkey}
  }
 \bbx@sorting@reused
}
\end{codetex}

\subsubsection{不同位置/方式的代码处理}

biblatex 提供了很多接口可以在不同的位置使用一些代码，比如在AtEndPreamble、AtEveryCitekey、AtDataInput等处，进行一些内容检测、筛选、替换等处理操作。比如，在AtEveryCitekey处检测数据来实现筛选替换。比如，在AtDataInput 处对每个条目做检测以实现筛选。又比如，利用check，利用map，
或者在宏中利用判断比如 ifcitation 等进行判断和后续操作等等。

具体代码，比如：

\begin{codetex}{不同位置的代码处理}{eg:code:hooka}
%导言区结束加代码：
\AtEndPreamble{
  \ifundef{\bbx@manuscripts@sorting}{}%
    {
    \DeclareSortingScheme{anonymous+manuscripts}{
      \sort{
        \field{presort}
      }
      \sort[final]{
        \field{sortkey}
      }
      \bbx@anonymous@sorting
      \bbx@manuscripts@sorting
      }
    }
}

%条目引用开始处加代码：
\AtEveryCitekey{\iffieldundef{prenote}{\blx@initunit}{}}
\end{codetex}

\begin{codetex}{引用位置的本地化字符串/空格处理}{eg:code:hookb}
%本地化字符串：
%在正文标注中，无论中文作者还是英文作者都使用“等”作为作者缩略时的标记
%区别于文献表中，中文作者用等，而英文作者用et al.
\AtEveryCite{%
\renewbibmacro*{name:andothers}{%
 \ifboolexpr{
   test {\ifnumequal{\value{listcount}}{\value{liststop}}}
   and
   test \ifmorenames
 }{\ifnumgreater{\value{liststop}}{1}
      {\finalandcomma}%
      {}%\finalandcomma
\printdelim{andothersdelim}\bibstring{andotherscn}%
}{}}}


%空格处理：
%引用每一篇文献时，局部定义andothersdelim分隔符
\AtEveryCitekey{%
\iffieldequalstr{userf}{cn}{\renewcommand*{\andothersdelim}{\addthinspace}}%\addthinspace
  {\renewcommand*{\andothersdelim}{\addspace}}%
}
%而因为textcite命令中有专门的分隔符环境可以用，因此会覆盖andothersdelim的设置
\DeclareDelimFormat[textcite]{andothersdelim}{\iffieldequalstr{userf}{cn}{\addthinspace}{\addspace}}%
\end{codetex}


\subsubsection{数据模型定义}

biblatex 提供了数据模型的高级定义功能，可以自定义条目类型、域、域集合、条目类型支持的域等，比如下例定义了一种新的条目类型 newsarticle：

\begin{codetex}{数据模型定义}{eg:datamodel:define}
\DeclareDatamodelEntrytypes{
  newsarticle}

\DeclareDatamodelFields[type=list, datatype=name]{
  with,
  writer,
  producer,
  execproducer,
  director}

\DeclareDatamodelFields[type=field, datatype=literal]{
  abstractloc,
  titleisdescription,
  newspaper,
  urldescription}

\DeclareDatamodelFields[type=field, datatype=verbatim]{
  abstracturl}

\DeclareDatafieldSet{author}{
    \member[field=author]

\DeclareDatamodelEntryfields{
  titleisdescription,
  with,
  abstractloc,
  abstracturl,
  urldescription}

\DeclareDatamodelEntryfields[newsarticle]{
  author,
  newspaper,
  title,
  day,
  endday,
  endmonth,
  endyear,
  month,
  year,
  addendum,
  doi,
  editor,
  editora,
  editorb,
  editorc,
  editoratype,
  editorbtype,
  editorctype,
  eid,
  eprint,
  eprintclass,
  eprinttype,
  issn,
  issue,
  issuetitle,
  issuesubtitle,
  language,
  note,
  number,
  origlanguage,
  pages,
  series,
  subtitle,
  titleaddon,
  translator,
  url,
  urlday,
  urlendday,
  urlendmonth,
  urlendyear,
  urlmonth,
  urlyear,
  volume}
\end{codetex}

当然，数据模型定义很多时候并不是唯一的解决方案，一些情况下，利用条目类型别名设置已经能够满足需求，不需要专门为某一类型条目设置数据模型。


\subsubsection{日期格式控制选项定义}

根据日期格式选择的定义可以知道，样式作者可以为不同的日期增加新的选项，先看一下 biblatex 中日期相关选项的定义：

\begin{codetex}{日期相关选项的定义}{eg:dateopt:define}
\def\do#1{%
  \DeclareBibliographyOption[string]{#1date}{%
    \ifstrequal{##1}{iso8601}
      {\blx@warning@noline{'iso8601' date format specifier is deprecated.\MessageBreak
         Use 'iso' instead}%
       \csdef{blx@dateformat@#1date}{iso}}
      {\ifstrequal{##1}{edtf}
         {\blx@warning@noline{'edtf' date format specifier is deprecated.\MessageBreak
            Use 'iso' instead}%
          \csdef{blx@dateformat@#1date}{iso}}
         {\csdef{blx@dateformat@#1date}{##1}}}%
    \ifstrequal{##1}{ymd}
      {\renewrobustcmd*{\bibdaterangesep}{\slash}%
       \renewrobustcmd*{\bibtimerangesep}{\slash}%
       \renewrobustcmd*{\bibdateeraendprefix}{\bibdateeraprefix}}
      {}%
    \ifcsdef{mkdaterange##1}
      {\protected\csedef{blx@imc@print#1date}{\noexpand\csuse{mkdaterange##1}{#1}}%
       \protected\csedef{blx@imc@print#1dateextra}{\noexpand\csuse{mkdaterange##1extra}{#1}}}
      {\ifcsdef{mkbibrange##1}%LEGACY(<3.5)
        {\blx@warning@noline{%
           '\string\mkbibrange##1(extra)' date range macro in style is deprecated,\MessageBreak
           please define '\string\mkdaterange##1(extra)' instead}%
         \protected\csedef{blx@imc@print#1date}{\noexpand\csuse{mkbibrange##1}{#1}}%
         \protected\csedef{blx@imc@print#1dateextra}{\noexpand\csuse{mkbibrange##1extra}{#1}}}
        {\blx@err@invopt{#1date=##1}{}}}}%
    % Default for new date fields is "comp" but this is overridden below by
    % biblatex defaults
    \setkeys{blx@opt@pre}{#1date=comp}%
    % Time format options
    \DeclareBibliographyOption[string]{#1time}{%
      \csdef{blx@timeformat@#1time}{##1}%
      \ifcsdef{mktimerange##1}
        {\protected\csedef{blx@imc@print#1time}{\csuse{mktimerange##1}{#1}}}
        {\blx@err@invopt{#1time=##1}{}}}%
    % Default for new time fields is "24h"
    \setkeys{blx@opt@pre}{#1time=24h}%
    % Boolean to determine if times are printed with dates
    \newtoggle{blx@#1dateusetime}%
    \DeclareBibliographyOption[boolean]{#1dateusetime}{%
      \ifstrequal{##1}{true}
        {\toggletrue{blx@#1dateusetime}}
        {\togglefalse{blx@#1dateusetime}}}}
\abx@dodatetypes
\end{codetex}

可以看到当存在\verb|mkdaterange##1|命令时，biblatex就会定义一个对应的\verb|blx@imc@print#1date|用来输出日期。因此只要定义\verb|mkdaterange##1|就可以为日期选项比如date，urldate等增加新的选项。

比如：

\begin{codetex}{日期选项的增加}{eg:dateopt:valueadd}
\newcommand*{\mkdaterangeapalong}[1]{%
  \blx@metadateinfo{#1}%
  \iffieldundef{#1year}{}
    {\datecircaprint
     \ifstrequal{#1}{url}% URL dates are unlikely to be BCE ...
       {\printtext{%
           \mkbibdateapalongmdy{#1year}{#1month}{#1day}%
           \iffieldundef{#1endyear}%
             {}%
             {\iffieldequalstr{#1endyear}{}% open-ended range?
               {\mbox{\bibdatedash}}
               {\bibdatedash%
                \iffieldsequal{#1year}{#1endyear}%
                  {\iffieldsequal{#1month}{#1endmonth}%
                    {\iffieldsequal{#1day}{#1endday}%
                      {}%
                      {\mkbibdateapalongmdy{}{}{#1endday}}}%
                    {\mkbibdateapalongmdy{}{#1endmonth}{#1endday}}}%
                  {\mkbibdateapalongmdy{#1endyear}{#1endmonth}{#1endday}}}}%
           \dateuncertainprint}}
       {\printtext{%
           \mkbibdateapalong{#1year}{#1month}{#1day}%
           \dateeraprint{#1year}%
           \iffieldundef{#1endyear}%
             {}%
             {\iffieldequalstr{#1endyear}{}% open-ended range?
               {\mbox{\bibdatedash}}
               {\bibdatedash%
                \iffieldsequal{#1year}{#1endyear}%
                  {\iffieldsequal{#1month}{#1endmonth}%
                    {\iffieldsequal{#1day}{#1endday}%
                      {}%
                      {\mkbibdateapalong{}{}{#1endday}}}%
                    {\mkbibdateapalong{}{#1endmonth}{#1endday}}}%
                  {\mkbibdateapalong{#1endyear}{#1endmonth}{#1endday}%
                 \dateeraprint{#1endyear}}}%
             \enddateuncertainprint}}}}}
			
  \protected\def\mkbibdateapalongmdy#1#2#3{%
    \iffieldundef{#2}%
      {}%
      {\mkbibmonth{\thefield{#2}}}%
    \iffieldundef{#3}%
      {}%
      {\addspace}%
       \stripzeros{\thefield{#3}}%
    \iffieldundef{#1}%
      {}%
      {\ifthenelse{\iffieldundef{#3}}%
        {\ifthenelse{\iffieldundef{#2}}%
          {}%
          {\addspace}}%
        {\addcomma\addspace}%
       \iffieldbibstring{#1}{\biblcstring{\thefield{#1}}}{\thefield{#1}}}}}
\end{codetex}



\subsubsection{美式标点}

\begin{codetex}{美式标点}{eg:punc:us}
\uspunctuation
\end{codetex}

\subsubsection{不同条目类型的域格式}

\begin{codetex}{不同条目类型的域格式}{eg:fieldfmt:entrytypes}
\DeclareFieldFormat[article]{number}{\bibstring{number}\addnbspace#1}
\DeclareFieldFormat[patent]{number}{\mkonepagegrouped{#1}}
\DeclareFieldFormat{pages}{%
  \mkpageprefix[bookpagination][\mkpagegrouped]{#1}%
}
\DeclareFieldFormat{sentencecase}{\bbx@colon@search{\MakeSentenceCase*}{#1}}
\DeclareFieldFormat[book,inbook,incollection,inproceedings]{series}
  {\bibstring{jourser}\addnbspace#1}
\DeclareFieldFormat[online]{title}{#1\isdot}
\DeclareFieldFormat[report]{title}{\mkbibquote{#1\isdot}}
\DeclareFieldFormat{url}{\bibstring{url}\addcolon\space\url{#1}}
\DeclareFieldFormat*{volume}
  {\bibstring{volume}\addnbspace#1}
\DeclareFieldFormat[article,periodical]{volume}
  {\bibstring{jourvol}\addnbspace#1}
\end{codetex}

\subsubsection{文献表中相同作者用dash代替}

可以利用authoryear中的代码：
\begin{codetex}{相同作者用dash代替}{eg:author:same}
% An option that carries through from author-year styles
\DeclareBibliographyOption[boolean]{dashed}[true]{%
  \ifstrequal{#1}{true}
    {\ExecuteBibliographyOptions{pagetracker}%
     \renewbibmacro*{bbx:savehash}{\savefield{fullhash}{\bbx@lasthash}}}
    {\renewbibmacro*{bbx:savehash}{}}}

\InitializeBibliographyStyle{\global\undef\bbx@lasthash}

\newbibmacro*{bbx:savehash}{\savefield{fullhash}{\bbx@lasthash}}

% Bibliography macros
\renewbibmacro*{author}{%
  \ifboolexpr{
    test \ifuseauthor
    and
    not test {\ifnameundef{author}}
  }
    {%
      \iffieldequals{fullhash}{\bbx@lasthash}
        {\bibnamedash\addcomma\space}
        {\printnames{author}}%
      \usebibmacro{bbx:savehash}%
      \iffieldundef{authortype}
        {}
        {%
          \setunit{\addcomma\space}%
          \usebibmacro{authorstrg}%
        }%
    }
    {\global\undef\bbx@lasthash}%
}
\end{codetex}



\section{结论}
通过本文的工作给出了\LaTeX 文档中文参考文献相关问题的biblatex解决方案，包括: 基本参考文献生成、分章参考文献、指定格式的著录和标注样式等，基本能够满足日常的各类参考文献生成需求，能够为\LaTeX 文档写作提供帮助。

\section{后记}
因水平有限，难免存在一些错误，请各位朋友批评指正。如果遇到什么问题，也可以邮件联系，欢迎交流。

%%----------------------------------------------------------------
\input{articlemodelpartc.tex}
%%一篇论文结束
%%----------------------------------------------------------------


%%================================================================
%%下一篇论文,格式与上一篇类似,只要修改内容即可
%%----------------------------------------------------------------
%新的一篇论文放到articlesecond.tex文件中，后面的新论文类似，通常不包含进来。


%为方便超链接查看，这里可以加入目录
\vspace{1cm}
\noindent\rule{\linewidth}{3pt}
\phantomsection
\addcontentsline{toc}{section}{目录}
\tableofcontents
%\renewcommand{\numberline}[1]{#1~}
\phantomsection
\addcontentsline{toc}{section}{插图}
\listoffigures
\phantomsection
\addcontentsline{toc}{section}{表格}
\listoftables
\phantomsection
\addcontentsline{toc}{section}{示例}
\listofegcode



\end{document} 